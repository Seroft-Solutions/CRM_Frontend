<%#
 Copyright 2013-2025 the original author or authors from the JHipster project.
-%>
"use client";

import React from "react";
import { FormItem, FormLabel, FormControl, FormMessage } from "@/components/ui/form";
import { PaginatedRelationshipCombobox } from "./paginated-relationship-combobox";

// Import all hooks statically for the specific entity
<%_ 
// Helper function to categorize relationship
function categorizeRelationship(rel) {
  const name = rel.relationshipName.toLowerCase();
  const otherEntity = rel.otherEntityName.toLowerCase();
  
  const geographicKeywords = ['state', 'district', 'city', 'area', 'country', 'region', 'location'];
  const userKeywords = ['user', 'assignedTo', 'createdBy', 'updatedBy', 'channelParty', 'owner'];
  const classificationKeywords = ['priority', 'status', 'type', 'category', 'level', 'grade'];
  const businessKeywords = ['customer', 'supplier', 'vendor', 'product', 'source'];
  const channelKeywords = ['channel'];
  const assignmentKeywords = ['assignedTo', 'assignee'];
  
  if (geographicKeywords.some(kw => name.includes(kw) || otherEntity.includes(kw))) {
    return 'geographic';
  }
  if (channelKeywords.some(kw => name.includes(kw) || otherEntity.includes(kw))) {
    return 'channel';
  }
  if (assignmentKeywords.some(kw => name.includes(kw)) || name === 'assignedto') {
    return 'assignment';
  }
  if (userKeywords.some(kw => name.includes(kw) || otherEntity.includes(kw)) || rel.otherEntity?.builtInUser) {
    return 'user';
  }
  if (classificationKeywords.some(kw => name.includes(kw) || otherEntity.includes(kw))) {
    return 'classification';
  }
  if (businessKeywords.some(kw => name.includes(kw) || otherEntity.includes(kw))) {
    return 'business';
  }
  return 'other';
}

// Build relationship configs with API information
const relationshipConfigs = persistableRelationships.map(rel => {
  const category = categorizeRelationship(rel);
  return {
    name: rel.relationshipFieldName,
    type: rel.relationshipType,
    targetEntity: rel.otherEntityName,
    displayField: rel.otherEntity.builtInUser ? 'login' : rel.otherEntityField,
    primaryKey: rel.otherEntity.builtInUser ? 'id' : (rel.otherEntity.primaryKey?.name || 'id'),
    required: rel.relationshipRequired || false,
    multiple: rel.collection || false,
    category: category,
    api: {
      useGetAllHook: rel.otherEntity.builtInUser ? 'useGetAllPublicUsers' : `useGetAll${rel.otherEntity.entityClassPlural}`,
      useSearchHook: rel.otherEntity.builtInUser ? 'useSearchPublicUsers' : `useSearch${rel.otherEntity.entityClassPlural}`,
      useCountHook: rel.otherEntity.builtInUser ? undefined : `useCount${rel.otherEntity.entityClassPlural}`,
      entityName: rel.otherEntity.builtInUser ? 'PublicUsers' : rel.otherEntity.entityClassPlural,
    }
  };
});

// Collect unique API imports based on relationship configs
const apiImports = new Map();
relationshipConfigs.forEach(relConfig => {
  if (relConfig.api && !relConfig.api.entityName.includes('PublicUsers')) {
    // Get the resource name from the relationship's otherEntity data
    const rel = persistableRelationships.find(r => r.relationshipFieldName === relConfig.name);
    const resourceName = rel.otherEntity.entityFileName + '-resource';
    
    if (!apiImports.has(resourceName)) {
      apiImports.set(resourceName, new Set());
    }
    
    apiImports.get(resourceName).add(relConfig.api.useGetAllHook);
    if (relConfig.api.useSearchHook) apiImports.get(resourceName).add(relConfig.api.useSearchHook);
    if (relConfig.api.useCountHook) apiImports.get(resourceName).add(relConfig.api.useCountHook);
  } else if (relConfig.api && relConfig.api.useGetAllHook && relConfig.api.useGetAllHook.includes('PublicUsers')) {
    // Handle built-in user entities separately
    const resourceName = 'public-user-resource';
    if (!apiImports.has(resourceName)) {
      apiImports.set(resourceName, new Set());
    }
    apiImports.get(resourceName).add(relConfig.api.useGetAllHook);
    if (relConfig.api.useSearchHook) apiImports.get(resourceName).add(relConfig.api.useSearchHook);
    if (relConfig.api.useCountHook) apiImports.get(resourceName).add(relConfig.api.useCountHook);
  }
});
-%>

<% for (const [resourceName, hooks] of apiImports) { -%>
import {
<% for (const hook of hooks) { -%>
  <%= hook %>,
<% } -%>
} from "@/core/api/generated/spring/endpoints/<%= resourceName %>/<%= resourceName %>.gen";
<% } -%>

import type { RelationshipConfig } from "./form-types";

interface RelationshipRendererProps {
  relConfig: RelationshipConfig;
  field: any;
  form: any;
  actions: any;
  config: any;
}

// Generic relationship component that uses hooks based on the relationship name
export function RelationshipRenderer({ 
  relConfig, 
  field, 
  form, 
  actions, 
  config 
}: RelationshipRendererProps) {
  
  // Use hooks based on relationship name - this ensures hooks are called consistently
  const renderRelationshipWithHooks = () => {
    switch (relConfig.name) {
<% relationshipConfigs.forEach(relConfigItem => { -%>
<% if (relConfigItem.api && relConfigItem.api.useGetAllHook) { -%>
      case '<%= relConfigItem.name %>':
<% if (relConfigItem.targetEntity === 'userProfile' && (relConfigItem.name === 'channelParties' || relConfigItem.name === 'assignedTo')) { -%>
      case '<%= relConfigItem.name === 'channelParties' ? 'assignedTo' : 'channelParties' %>':
<% } -%>
        return (
          <PaginatedRelationshipCombobox
            value={field.value}
            onValueChange={(value) => {
              field.onChange(value);
              if (relConfig.cascadingFilter) {
                const dependentRelationships = config.relationships.filter((depRel: any) => 
                  depRel.cascadingFilter?.parentField === relConfig.name
                );
                dependentRelationships.forEach((depRel: any) => {
                  form.setValue(depRel.name, undefined);
                });
              }
            }}
            displayField={relConfig.displayField}
            placeholder={relConfig.ui.placeholder}
            multiple={relConfig.multiple}
            useGetAllHook={<%= relConfigItem.api.useGetAllHook %>}
            useSearchHook={<%= relConfigItem.api.useSearchHook %>}
            useCountHook={<%= relConfigItem.api.useCountHook || 'undefined' %>}
            entityName={relConfig.api.entityName}
            searchField={relConfig.displayField}
            canCreate={relConfig.creation?.canCreate}
            createEntityPath={relConfig.creation?.createPath || ""}
            createPermission={relConfig.creation?.createPermission || ""}
            onEntityCreated={(entityId) => actions.handleEntityCreated(entityId, relConfig.name)}
            parentFilter={relConfig.cascadingFilter ? form.watch(relConfig.cascadingFilter.parentField) : undefined}
            parentField={relConfig.cascadingFilter?.parentField}
            disabled={
              relConfig.cascadingFilter 
                ? !form.watch(relConfig.cascadingFilter.parentField) 
                : relConfig.ui.disabled
            }
            {...actions.getNavigationProps(relConfig.name)}
          />
        );
        
<% } -%>
<% }); -%>
      default:
        // For relationships without proper API configuration, show a fallback message
        return (
          <div className="text-muted-foreground text-sm p-4 border border-dashed rounded">
            Relationship configuration incomplete for: {relConfig.name}
            <br />
            <small>API hooks not defined in form config</small>
          </div>
        );
    }
  };

  return (
    <FormItem>
      <FormLabel className="text-sm font-medium">
        {relConfig.ui.label}
        {relConfig.required && " *"}
      </FormLabel>
      <FormControl>
        {renderRelationshipWithHooks()}
      </FormControl>
      <FormMessage />
    </FormItem>
  );
}
