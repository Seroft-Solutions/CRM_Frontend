This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
Call.info
generator.js
generator.ts
INSTRUCTIONS.md
package.json
PAGINATED_RELATIONSHIPS_README.md
README.md
templates/components/auth/permission-guard.tsx
templates/components/auth/unauthorized-page.tsx
templates/components/context-aware-back-button.tsx
templates/components/toaster-provider.tsx.ejs
templates/entity/[id]/edit/page.tsx.ejs
templates/entity/[id]/page.tsx.ejs
templates/entity/actions/entity-actions.ts.ejs
templates/entity/components/bulk-relationship-assignment.tsx.ejs
templates/entity/components/entity-details.tsx.ejs
templates/entity/components/entity-form.tsx.ejs
templates/entity/components/entity-table.tsx.ejs
templates/entity/components/entity-toast.ts.ejs
templates/entity/components/paginated-relationship-combobox.tsx.ejs
templates/entity/components/relationship-cell.tsx.ejs
templates/entity/components/relationship-combobox.tsx.ejs
templates/entity/components/relationship-return-handler.tsx.ejs
templates/entity/components/table/entity-search-filters.tsx.ejs
templates/entity/components/table/entity-table-header.tsx.ejs
templates/entity/components/table/entity-table-main.tsx.ejs
templates/entity/components/table/entity-table-row.tsx.ejs
templates/entity/layout.tsx.ejs
templates/entity/new/page.tsx.ejs
templates/entity/page.tsx.ejs
tsconfig.json
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="Call.info">
## Current Call Form Steps

**Step 1: Call Classification**
- Priority
- Call Type
- Sub Call Type
- Call Category

**Step 2: Source & Party**
- Source
- Party

**Step 3: Location**
- State ‚Üí District ‚Üí City ‚Üí Area (hierarchical)

**Step 4: Channel Details**
- Channel Type
- Channel Party

**Step 5: Assignment & Date**
- Assigned To
- Call Date Time
- Call Status

**Step 6: Review**
- Summary of all selections

## Details View Cards
Same 5 themed sections with icons:
- üè∑Ô∏è Call Classification
- üè¢ Source & Party
- üìç Location
- üì° Channel Details
- üë§ Assignment & Date
- üìù Call Remarks (additional section)

## Additional Features
- Custom toast system (call-toast.ts)
- Form state persistence
- Hierarchical location cascading
- ToasterProvider layout
</file>

<file path="generator.js">
"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g = Object.create((typeof Iterator === "function" ? Iterator : Object).prototype);
    return g.next = verb(0), g["throw"] = verb(1), g["return"] = verb(2), typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.NextJsGenerator = void 0;
var fs = require("fs");
var path = require("path");
var ejs = require("ejs");
var pluralize_1 = require("pluralize");
/**
 * Generator for Next.js components based on JHipster entity definitions
 */
var NextJsGenerator = /** @class */ (function () {
    function NextJsGenerator(projectRoot, jhipsterDir, templateDir, outputDir) {
        this.projectRoot = projectRoot;
        this.jhipsterDir = jhipsterDir;
        this.templateDir = templateDir;
        this.outputDir = outputDir;
    }
    /**
     * Generate CRUD components for all entities
     */
    NextJsGenerator.prototype.generateAll = function () {
        return __awaiter(this, void 0, void 0, function () {
            var entityFiles, _i, entityFiles_1, entityFile, entityName;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        entityFiles = fs.readdirSync(this.jhipsterDir).filter(function (file) { return file.endsWith('.json'); });
                        console.log("Found ".concat(entityFiles.length, " entity definitions in ").concat(this.jhipsterDir));
                        _i = 0, entityFiles_1 = entityFiles;
                        _a.label = 1;
                    case 1:
                        if (!(_i < entityFiles_1.length)) return [3 /*break*/, 4];
                        entityFile = entityFiles_1[_i];
                        entityName = entityFile.replace('.json', '');
                        return [4 /*yield*/, this.generateEntity(entityName)];
                    case 2:
                        _a.sent();
                        _a.label = 3;
                    case 3:
                        _i++;
                        return [3 /*break*/, 1];
                    case 4: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Generate CRUD components for a specific entity
     */
    NextJsGenerator.prototype.generateEntity = function (entityName) {
        return __awaiter(this, void 0, void 0, function () {
            var entityDefinitionPath, entityDefinition, vars, entityDir;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        console.log("Generating components for entity: ".concat(entityName));
                        entityDefinitionPath = path.join(this.jhipsterDir, "".concat(entityName, ".json"));
                        console.log("Reading entity definition from: ".concat(entityDefinitionPath));
                        entityDefinition = JSON.parse(fs.readFileSync(entityDefinitionPath, 'utf8'));
                        vars = this.prepareTemplateVariables(entityName, entityDefinition);
                        entityDir = path.join(this.outputDir, 'app', '(protected)', vars.routePath);
                        console.log("Creating directories at: ".concat(entityDir));
                        this.ensureDir(entityDir);
                        this.ensureDir(path.join(entityDir, 'new'));
                        this.ensureDir(path.join(entityDir, '[id]'));
                        this.ensureDir(path.join(entityDir, '[id]', 'edit'));
                        this.ensureDir(path.join(entityDir, 'components'));
                        // Generate files from templates
                        console.log("Generating component files...");
                        return [4 /*yield*/, this.generateFile('entity/page.tsx.ejs', path.join(entityDir, 'page.tsx'), vars)];
                    case 1:
                        _a.sent();
                        return [4 /*yield*/, this.generateFile('entity/new/page.tsx.ejs', path.join(entityDir, 'new', 'page.tsx'), vars)];
                    case 2:
                        _a.sent();
                        return [4 /*yield*/, this.generateFile('entity/[id]/page.tsx.ejs', path.join(entityDir, '[id]', 'page.tsx'), vars)];
                    case 3:
                        _a.sent();
                        return [4 /*yield*/, this.generateFile('entity/[id]/edit/page.tsx.ejs', path.join(entityDir, '[id]', 'edit', 'page.tsx'), vars)];
                    case 4:
                        _a.sent();
                        return [4 /*yield*/, this.generateFile('entity/components/entity-table.tsx.ejs', path.join(entityDir, 'components', "".concat(vars.entityFileName, "-table.tsx")), vars)];
                    case 5:
                        _a.sent();
                        return [4 /*yield*/, this.generateFile('entity/components/entity-form.tsx.ejs', path.join(entityDir, 'components', "".concat(vars.entityFileName, "-form.tsx")), vars)];
                    case 6:
                        _a.sent();
                        return [4 /*yield*/, this.generateFile('entity/components/entity-details.tsx.ejs', path.join(entityDir, 'components', "".concat(vars.entityFileName, "-details.tsx")), vars)];
                    case 7:
                        _a.sent();
                        console.log("Successfully generated components for ".concat(entityName));
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Prepare variables for EJS templates
     */
    NextJsGenerator.prototype.prepareTemplateVariables = function (entityName, entityDefinition) {
        var entityFileName = this.camelToKebab(entityName);
        var entityClass = entityName;
        var entityClassPlural = (0, pluralize_1.plural)(entityName);
        var entityInstance = this.lowerFirstCamelCase(entityName);
        var pluralizedRoute = (0, pluralize_1.plural)(entityFileName);
        // Process relationships to add computed properties
        var processedRelationships = this.processRelationships(entityDefinition.relationships || []);
        var persistableRelationships = processedRelationships.filter(function (r) { return r.relationshipType !== 'one-to-many'; });
        // Get unique other entities for API imports
        var otherEntitiesWithPersistableRelationship = this.getUniqueOtherEntities(persistableRelationships);
        return {
            entityName: entityName,
            entityFileName: entityFileName,
            entityClass: entityClass,
            entityClassPlural: entityClassPlural,
            entityClassHumanized: this.humanize(entityClass),
            entityClassPluralHumanized: this.humanize(entityClassPlural),
            entityInstance: this.lowerFirstCamelCase(entityInstance),
            entityRoute: pluralizedRoute,
            routePath: pluralizedRoute,
            primaryKey: { name: 'id', type: 'number' },
            fields: entityDefinition.fields,
            relationships: processedRelationships,
            persistableRelationships: persistableRelationships,
            otherEntitiesWithPersistableRelationship: otherEntitiesWithPersistableRelationship,
            searchEngineAny: entityDefinition.searchEngine,
            anyFieldIsDateDerived: entityDefinition.fields.some(function (f) {
                return f.fieldTypeTimed || f.fieldTypeLocalDate || f.fieldTypeZonedDateTime || f.fieldTypeInstant;
            }),
            anyFieldIsBlobDerived: entityDefinition.fields.some(function (f) { return f.fieldTypeBinary; }),
            readOnly: entityDefinition.readOnly || false,
            pagination: entityDefinition.pagination || 'no',
            service: entityDefinition.service || 'no',
            dto: entityDefinition.dto || 'no',
        };
    };
    /**
     * Generate a file from a template
     */
    NextJsGenerator.prototype.generateFile = function (templatePath, outputPath, variables) {
        return __awaiter(this, void 0, void 0, function () {
            var fullTemplatePath, template, output;
            return __generator(this, function (_a) {
                fullTemplatePath = path.join(this.templateDir, templatePath);
                if (!fs.existsSync(fullTemplatePath)) {
                    console.error("Template file not found: ".concat(fullTemplatePath));
                    return [2 /*return*/];
                }
                template = fs.readFileSync(fullTemplatePath, 'utf8');
                try {
                    output = ejs.render(template, variables, {
                        escape: function (str) { return str; }, // Don't escape output
                    });
                    fs.writeFileSync(outputPath, output);
                    console.log("Generated: ".concat(outputPath));
                }
                catch (error) {
                    console.error("Error generating file ".concat(outputPath, ":"), error);
                }
                return [2 /*return*/];
            });
        });
    };
    /**
     * Create directory if it doesn't exist
     */
    NextJsGenerator.prototype.ensureDir = function (dirPath) {
        if (!fs.existsSync(dirPath)) {
            fs.mkdirSync(dirPath, { recursive: true });
        }
    };
    /**
     * Process relationships to add computed properties
     */
    NextJsGenerator.prototype.processRelationships = function (relationships) {
        var _this = this;
        return relationships.map(function (rel) {
            var otherEntityName = rel.otherEntityName;
            var otherEntityClass = _this.upperFirstCamelCase(otherEntityName);
            var otherEntityClassPlural = (0, pluralize_1.plural)(otherEntityClass);
            var otherEntityInstance = _this.lowerFirstCamelCase(otherEntityName);
            var otherEntityInstancePlural = (0, pluralize_1.plural)(otherEntityInstance);
            var otherEntityFileName = _this.camelToKebab(otherEntityName);
            // Determine relationship field names
            var relationshipName = rel.relationshipName;
            var relationshipFieldName = relationshipName;
            var relationshipFieldNamePlural = (0, pluralize_1.plural)(relationshipName);
            // Determine if this is a collection relationship
            var isCollection = rel.relationshipType === 'one-to-many' || rel.relationshipType === 'many-to-many';
            // Determine display field - default to 'name' if not specified
            var otherEntityField = rel.otherEntityField || 'name';
            // Determine if relationship is required
            var relationshipRequired = rel.relationshipRequired || false;
            return __assign(__assign({}, rel), { 
                // Original relationship properties
                otherEntityName: otherEntityName, relationshipName: relationshipName, relationshipFieldName: relationshipFieldName, relationshipFieldNamePlural: relationshipFieldNamePlural, relationshipNameHumanized: _this.humanize(relationshipName), relationshipRequired: relationshipRequired, collection: isCollection, otherEntityField: otherEntityField, 
                // Computed other entity properties
                otherEntity: {
                    entityName: otherEntityName,
                    entityClass: otherEntityClass,
                    entityClassPlural: otherEntityClassPlural,
                    entityInstance: otherEntityInstance,
                    entityInstancePlural: otherEntityInstancePlural,
                    entityFileName: otherEntityFileName,
                    entityNamePlural: otherEntityInstancePlural,
                    primaryKey: { name: 'id' }, // Default primary key
                    builtInUser: rel.relationshipWithBuiltInEntity || false,
                } });
        });
    };
    /**
     * Get unique other entities for API imports
     */
    NextJsGenerator.prototype.getUniqueOtherEntities = function (relationships) {
        var entityMap = new Map();
        relationships.forEach(function (rel) {
            var otherEntity = rel.otherEntity;
            if (!entityMap.has(otherEntity.entityName)) {
                entityMap.set(otherEntity.entityName, otherEntity);
            }
        });
        return Array.from(entityMap.values());
    };
    /**
     * Convert camelCase to kebab-case
     */
    NextJsGenerator.prototype.camelToKebab = function (str) {
        return str.replace(/([a-z0-9])([A-Z])/g, '$1-$2').toLowerCase();
    };
    /**
     * Convert first letter to uppercase
     */
    NextJsGenerator.prototype.upperFirstCamelCase = function (str) {
        return str.charAt(0).toUpperCase() + str.slice(1);
    };
    /**
     * Convert first letter to lowercase
     */
    NextJsGenerator.prototype.lowerFirstCamelCase = function (str) {
        return str.charAt(0).toLowerCase() + str.slice(1);
    };
    /**
     * Convert camelCase or PascalCase to Human Case
     */
    NextJsGenerator.prototype.humanize = function (str) {
        return str
            // Split camelCase
            .replace(/([a-z0-9])([A-Z])/g, '$1 $2')
            // uppercase first letter
            .replace(/^./, function (s) { return s.toUpperCase(); });
    };
    return NextJsGenerator;
}());
exports.NextJsGenerator = NextJsGenerator;
// CLI script to generate components
if (require.main === module) {
    (function () { return __awaiter(void 0, void 0, void 0, function () {
        var projectRoot, jhipsterDir, templateDir, outputDir, generator, entityName, error_1;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    _a.trys.push([0, 5, , 6]);
                    projectRoot = 'D:\\code\\CRMCup\\CRM_Frontend';
                    jhipsterDir = path.join(projectRoot, '.jhipster');
                    templateDir = path.join(projectRoot, 'codgen', 'nextjs', 'templates');
                    outputDir = path.join(projectRoot, 'src');
                    console.log('Using paths:');
                    console.log('- Project root:', projectRoot);
                    console.log('- JHipster directory:', jhipsterDir);
                    console.log('- Template directory:', templateDir);
                    console.log('- Output directory:', outputDir);
                    generator = new NextJsGenerator(projectRoot, jhipsterDir, templateDir, outputDir);
                    entityName = process.argv[2];
                    if (!entityName) return [3 /*break*/, 2];
                    return [4 /*yield*/, generator.generateEntity(entityName)];
                case 1:
                    _a.sent();
                    return [3 /*break*/, 4];
                case 2: return [4 /*yield*/, generator.generateAll()];
                case 3:
                    _a.sent();
                    _a.label = 4;
                case 4: return [3 /*break*/, 6];
                case 5:
                    error_1 = _a.sent();
                    console.error('Error generating components:', error_1);
                    process.exit(1);
                    return [3 /*break*/, 6];
                case 6: return [2 /*return*/];
            }
        });
    }); })();
}
</file>

<file path="generator.ts">
import * as fs from 'fs';
import * as path from 'path';
import * as ejs from 'ejs';
import pluralize from 'pluralize';

interface TemplateVariables {
  entityName: string;
  entityFileName: string;
  entityClass: string;
  entityClassPlural: string;
  entityClassHumanized: string;
  entityClassPluralHumanized: string;
  entityInstance: string;
  entityRoute: string;
  routePath: string;
  primaryKey: { name: string; type: string };
  fields: Field[];
  relationships: ProcessedRelationship[];
  persistableRelationships: ProcessedRelationship[];
  otherEntitiesWithPersistableRelationship: ProcessedRelationship['otherEntity'][];
  searchEngineAny?: boolean;
  anyFieldIsDateDerived: boolean;
  anyFieldIsBlobDerived: boolean;
  readOnly: boolean;
  pagination: string;
  service: string;
  dto: string;
}

interface Field {
  fieldName: string;
  fieldType: string;
  fieldTypeBinary?: boolean;
  fieldTypeTimed?: boolean;
  fieldTypeLocalDate?: boolean;
  fieldTypeZonedDateTime?: boolean;
  fieldTypeInstant?: boolean;
  fieldTypeBoolean?: boolean;
  fieldTypeNumeric?: boolean;
  fieldIsEnum?: boolean;
  enumValues?: Array<{ name: string }>;
  fieldValidateRules?: string[];
  fieldValidateRulesMin?: number;
  fieldValidateRulesMax?: number;
  fieldValidateRulesMinlength?: number;
  fieldValidateRulesMaxlength?: number;
  fieldValidateRulesPattern?: string;
}

interface EntityDefinition {
  fields: Field[];
  relationships?: Relationship[];
  searchEngine?: boolean;
  readOnly?: boolean;
  pagination?: string;
  service?: string;
  dto?: string;
}

interface Relationship {
  otherEntityName: string;
  relationshipName: string;
  relationshipType: string;
  otherEntityField?: string;
  relationshipRequired?: boolean;
  relationshipWithBuiltInEntity?: boolean;
}

interface ProcessedRelationship extends Relationship {
  relationshipFieldName: string;
  relationshipFieldNamePlural: string;
  relationshipNameHumanized: string;
  collection: boolean;
  otherEntity: {
    entityName: string;
    entityClass: string;
    entityClassPlural: string;
    entityInstance: string;
    entityInstancePlural: string;
    entityFileName: string;
    entityNamePlural: string;
    primaryKey: { name: string };
    builtInUser: boolean;
  };
}

/**
 * Generator for Next.js components based on JHipster entity definitions
 */
export class NextJsGenerator {
  constructor(
    private readonly projectRoot: string,
    private readonly jhipsterDir: string,
    private readonly templateDir: string,
    private readonly outputDir: string
  ) {}

  /**
   * Generate shared components that are used across all entities
   */
  public async generateSharedComponents(): Promise<void> {
    console.log('Generating shared components...');
    
    // Create components directory structure
    const componentsDir = path.join(this.outputDir, 'components');
    const authDir = path.join(componentsDir, 'auth');
    
    this.ensureDir(componentsDir);
    this.ensureDir(authDir);
    
    // Generate ToasterProvider component for global toast notifications
    const toasterTemplate = path.join(this.templateDir, 'components', 'toaster-provider.tsx.ejs');
    const toasterOutput = path.join(componentsDir, 'toaster-provider.tsx');
    
    if (fs.existsSync(toasterTemplate)) {
      const template = fs.readFileSync(toasterTemplate, 'utf8');
      fs.writeFileSync(toasterOutput, template);
      console.log(`Generated shared component: ${toasterOutput}`);
    } else {
      console.warn(`ToasterProvider template not found: ${toasterTemplate}`);
    }
    
    // Generate PermissionGuard component
    const permissionGuardTemplate = path.join(this.templateDir, 'components', 'auth', 'permission-guard.tsx');
    const permissionGuardOutput = path.join(authDir, 'permission-guard.tsx');
    
    if (fs.existsSync(permissionGuardTemplate)) {
      const template = fs.readFileSync(permissionGuardTemplate, 'utf8');
      fs.writeFileSync(permissionGuardOutput, template);
      console.log(`Generated shared component: ${permissionGuardOutput}`);
    } else {
      console.warn(`Permission guard template not found: ${permissionGuardTemplate}`);
    }
    
    // Generate UnauthorizedPage component
    const unauthorizedPageTemplate = path.join(this.templateDir, 'components', 'auth', 'unauthorized-page.tsx');
    const unauthorizedPageOutput = path.join(authDir, 'unauthorized-page.tsx');
    
    if (fs.existsSync(unauthorizedPageTemplate)) {
      const template = fs.readFileSync(unauthorizedPageTemplate, 'utf8');
      fs.writeFileSync(unauthorizedPageOutput, template);
      console.log(`Generated shared component: ${unauthorizedPageOutput}`);
    } else {
      console.warn(`Unauthorized page template not found: ${unauthorizedPageTemplate}`);
    }
    
    // Generate ContextAwareBackButton component
    const contextBackButtonTemplate = path.join(this.templateDir, 'components', 'context-aware-back-button.tsx');
    const contextBackButtonOutput = path.join(componentsDir, 'context-aware-back-button.tsx');
    
    if (fs.existsSync(contextBackButtonTemplate)) {
      const template = fs.readFileSync(contextBackButtonTemplate, 'utf8');
      fs.writeFileSync(contextBackButtonOutput, template);
      console.log(`Generated shared component: ${contextBackButtonOutput}`);
    } else {
      console.warn(`Context aware back button template not found: ${contextBackButtonTemplate}`);
    }
    
    console.log('Shared components generated successfully');
  }

  /**
   * Generate CRUD components for all entities
   */
  public async generateAll(): Promise<void> {
    // Generate shared components first
    await this.generateSharedComponents();
    
    const entityFiles = fs.readdirSync(this.jhipsterDir).filter(file => file.endsWith('.json'));
    
    console.log(`Found ${entityFiles.length} entity definitions in ${this.jhipsterDir}`);
    
    for (const entityFile of entityFiles) {
      const entityName = entityFile.replace('.json', '');
      await this.generateEntity(entityName);
    }
  }

  /**
   * Generate CRUD components for a specific entity
   */
  public async generateEntity(entityName: string): Promise<void> {
    console.log(`Generating components for entity: ${entityName}`);
    
    // Read entity definition
    const entityDefinitionPath = path.join(this.jhipsterDir, `${entityName}.json`);
    console.log(`Reading entity definition from: ${entityDefinitionPath}`);
    
    const entityDefinition = JSON.parse(fs.readFileSync(entityDefinitionPath, 'utf8'));
    
    // Prepare variables for templates
    const vars = this.prepareTemplateVariables(entityName, entityDefinition);
    
    // Generate directory structure for entity
    const entityDir = path.join(this.outputDir, 'app', '(protected)', vars.routePath);
    console.log(`Creating directories at: ${entityDir}`);
    
    this.ensureDir(entityDir);
    this.ensureDir(path.join(entityDir, 'new'));
    this.ensureDir(path.join(entityDir, '[id]'));
    this.ensureDir(path.join(entityDir, '[id]', 'edit'));
    this.ensureDir(path.join(entityDir, 'components'));
    this.ensureDir(path.join(entityDir, 'actions'));
    
    // Generate files from templates
    console.log(`Generating component files...`);
    
    await this.generateFile('entity/page.tsx.ejs', path.join(entityDir, 'page.tsx'), vars);
    await this.generateFile('entity/layout.tsx.ejs', path.join(entityDir, 'layout.tsx'), vars);
    await this.generateFile('entity/new/page.tsx.ejs', path.join(entityDir, 'new', 'page.tsx'), vars);
    await this.generateFile('entity/[id]/page.tsx.ejs', path.join(entityDir, '[id]', 'page.tsx'), vars);
    await this.generateFile('entity/[id]/edit/page.tsx.ejs', path.join(entityDir, '[id]', 'edit', 'page.tsx'), vars);
    
    // Generate toast utility
    await this.generateFile('entity/components/entity-toast.ts.ejs', 
      path.join(entityDir, 'components', `${vars.entityFileName}-toast.ts`), vars);
    
    // Generate main table component
    await this.generateFile('entity/components/entity-table.tsx.ejs', 
      path.join(entityDir, 'components', `${vars.entityFileName}-table.tsx`), vars);
    
    // Generate split table components
    await this.generateFile('entity/components/table/entity-search-filters.tsx.ejs', 
      path.join(entityDir, 'components', `${vars.entityFileName}-search-filters.tsx`), vars);
    await this.generateFile('entity/components/table/entity-table-header.tsx.ejs', 
      path.join(entityDir, 'components', `${vars.entityFileName}-table-header.tsx`), vars);
    await this.generateFile('entity/components/table/entity-table-row.tsx.ejs', 
      path.join(entityDir, 'components', `${vars.entityFileName}-table-row.tsx`), vars);
    
    // Generate other components
    await this.generateFile('entity/components/entity-form.tsx.ejs', 
      path.join(entityDir, 'components', `${vars.entityFileName}-form.tsx`), vars);
    await this.generateFile('entity/components/entity-details.tsx.ejs', 
      path.join(entityDir, 'components', `${vars.entityFileName}-details.tsx`), vars);
    
    // Generate relationship management components
    await this.generateFile('entity/components/bulk-relationship-assignment.tsx.ejs', 
      path.join(entityDir, 'components', 'bulk-relationship-assignment.tsx'), vars);
    await this.generateFile('entity/components/relationship-cell.tsx.ejs', 
      path.join(entityDir, 'components', 'relationship-cell.tsx'), vars);
    
    // Generate paginated relationship combobox if there are relationships
    if (vars.persistableRelationships.length > 0) {
      await this.generateFile('entity/components/paginated-relationship-combobox.tsx.ejs', 
        path.join(entityDir, 'components', 'paginated-relationship-combobox.tsx'), vars);
    }
    
    // Generate server actions
    await this.generateFile('entity/actions/entity-actions.ts.ejs', 
      path.join(entityDir, 'actions', `${vars.entityFileName}-actions.ts`), vars);
    
    console.log(`Successfully generated components for ${entityName}`);
  }

  /**
   * Prepare variables for EJS templates
   */
  private prepareTemplateVariables(entityName: string, entityDefinition: EntityDefinition): TemplateVariables {
    const entityFileName = this.camelToKebab(entityName);
    const entityClass = entityName;
    const entityClassPlural = pluralize(entityName);
    const entityInstance = this.lowerFirstCamelCase(entityName);
    const pluralizedRoute = pluralize(entityFileName);

    // Filter out tenantId fields from code generation
    const filteredFields = this.filterFields(entityDefinition.fields);

    // Process relationships to add computed properties
    const processedRelationships = this.processRelationships(entityDefinition.relationships || []);
    const persistableRelationships = processedRelationships.filter((r) => r.relationshipType !== 'one-to-many');
    
    // Get unique other entities for API imports
    const otherEntitiesWithPersistableRelationship = this.getUniqueOtherEntities(persistableRelationships);

    return {
      entityName,
      entityFileName,
      entityClass,
      entityClassPlural,
      entityClassHumanized: this.humanize(entityClass),
      entityClassPluralHumanized: this.humanize(entityClassPlural),
      entityInstance: this.lowerFirstCamelCase(entityInstance),
      entityRoute: pluralizedRoute,
      routePath: pluralizedRoute,
      primaryKey: { name: 'id', type: 'number' },
      fields: filteredFields,
      relationships: processedRelationships,
      persistableRelationships,
      otherEntitiesWithPersistableRelationship,
      searchEngineAny: entityDefinition.searchEngine,
      anyFieldIsDateDerived: filteredFields.some((f) => 
        f.fieldTypeTimed || f.fieldTypeLocalDate || f.fieldTypeZonedDateTime || f.fieldTypeInstant),
      anyFieldIsBlobDerived: filteredFields.some((f) => f.fieldTypeBinary),
      readOnly: entityDefinition.readOnly || false,
      pagination: entityDefinition.pagination || 'no',
      service: entityDefinition.service || 'no',
      dto: entityDefinition.dto || 'no',
    };
  }

  /**
   * Generate a file from a template
   */
  private async generateFile(templatePath: string, outputPath: string, variables: TemplateVariables): Promise<void> {
    const fullTemplatePath = path.join(this.templateDir, templatePath);
    
    if (!fs.existsSync(fullTemplatePath)) {
      console.error(`Template file not found: ${fullTemplatePath}`);
      return;
    }
    
    const template = fs.readFileSync(fullTemplatePath, 'utf8');
    
    try {
      const output = ejs.render(template, variables, {
        escape: (str: string) => str, // Don't escape output
      });
      
      fs.writeFileSync(outputPath, output);
      console.log(`Generated: ${outputPath}`);
    } catch (error) {
      console.error(`Error generating file ${outputPath}:`, error);
    }
  }

  /**
   * Create directory if it doesn't exist
   */
  private ensureDir(dirPath: string): void {
    if (!fs.existsSync(dirPath)) {
      fs.mkdirSync(dirPath, { recursive: true });
    }
  }

  /**
   * Process relationships to add computed properties
   */
  private processRelationships(relationships: Relationship[]): ProcessedRelationship[] {
    return relationships.map(rel => {
      const otherEntityName = rel.otherEntityName;
      const otherEntityClass = this.upperFirstCamelCase(otherEntityName);
      const otherEntityClassPlural = pluralize(otherEntityClass);
      const otherEntityInstance = this.lowerFirstCamelCase(otherEntityName);
      const otherEntityInstancePlural = pluralize(otherEntityInstance);
      const otherEntityFileName = this.camelToKebab(otherEntityName);
      
      // Determine relationship field names
      const relationshipName = rel.relationshipName;
      const relationshipFieldName = relationshipName;
      const relationshipFieldNamePlural = pluralize(relationshipName);
      
      // Determine if this is a collection relationship
      const isCollection = rel.relationshipType === 'one-to-many' || rel.relationshipType === 'many-to-many';
      
      // Determine display field - use 'login' for built-in user entity, otherwise default to 'name'
      const otherEntityField = rel.otherEntityField || (rel.relationshipWithBuiltInEntity ? 'login' : 'name');
      
      // Determine if relationship is required
      const relationshipRequired = rel.relationshipRequired || false;
      
      // Determine if this is a built-in user entity
      const isBuiltInUser = rel.relationshipWithBuiltInEntity && otherEntityName === 'user';
      
      return {
        ...rel,
        // Original relationship properties
        otherEntityName,
        relationshipName,
        relationshipFieldName,
        relationshipFieldNamePlural,
        relationshipNameHumanized: this.humanize(relationshipName),
        relationshipRequired,
        collection: isCollection,
        otherEntityField,
        
        // Computed other entity properties
        otherEntity: {
          entityName: otherEntityName,
          entityClass: otherEntityClass,
          entityClassPlural: otherEntityClassPlural,
          entityInstance: otherEntityInstance,
          entityInstancePlural: otherEntityInstancePlural,
          entityFileName: otherEntityFileName,
          entityNamePlural: otherEntityInstancePlural,
          routePath: pluralize(otherEntityFileName), // Add pluralized route path
          primaryKey: { name: 'id' }, // Default primary key
          builtInUser: Boolean(isBuiltInUser),
        }
      };
    });
  }

  /**
   * Get unique other entities for API imports
   */
  private getUniqueOtherEntities(relationships: ProcessedRelationship[]): ProcessedRelationship['otherEntity'][] {
    const entityMap = new Map();
    
    relationships.forEach(rel => {
      const otherEntity = rel.otherEntity;
      if (!entityMap.has(otherEntity.entityName)) {
        entityMap.set(otherEntity.entityName, otherEntity);
      }
    });
    
    return Array.from(entityMap.values());
  }

  /**
   * Filter out system fields and process field types
   */
  private filterFields(fields: Field[]): Field[] {
    const excludedFields = ['tenantId'];
    
    return fields.filter(field => {
      const shouldExclude = excludedFields.includes(field.fieldName);
      if (shouldExclude) {
        console.log(`Excluding system field from code generation: ${field.fieldName}`);
      }
      return !shouldExclude;
    }).map(field => this.processFieldType(field));
  }

  /**
   * Process field type to set boolean flags for template usage
   */
  private processFieldType(field: Field): Field {
    const processedField = { ...field };
    
    // Set type-specific boolean flags based on fieldType
    switch (field.fieldType) {
      case 'Integer':
      case 'Long':
      case 'Float':
      case 'Double':
      case 'BigDecimal':
        processedField.fieldTypeNumeric = true;
        break;
      
      case 'Boolean':
        processedField.fieldTypeBoolean = true;
        break;
      
      case 'LocalDate':
        processedField.fieldTypeLocalDate = true;
        processedField.fieldTypeTimed = true;
        break;
      
      case 'ZonedDateTime':
        processedField.fieldTypeZonedDateTime = true;
        processedField.fieldTypeTimed = true;
        break;
      
      case 'Instant':
        processedField.fieldTypeInstant = true;
        processedField.fieldTypeTimed = true;
        break;
      
      case 'TextBlob':
      case 'ImageBlob':
      case 'AnyBlob':
        processedField.fieldTypeBinary = true;
        break;
    }
    
    // Check if field is an enum (has enumValues)
    if (field.enumValues && field.enumValues.length > 0) {
      processedField.fieldIsEnum = true;
    }
    
    return processedField;
  }

  /**
   * Convert camelCase to kebab-case
   */
  private camelToKebab(str: string): string {
    return str.replace(/([a-z0-9])([A-Z])/g, '$1-$2').toLowerCase();
  }

  /**
   * Convert first letter to uppercase
   */
  private upperFirstCamelCase(str: string): string {
    return str.charAt(0).toUpperCase() + str.slice(1);
  }

  /**
   * Convert first letter to lowercase
   */
  private lowerFirstCamelCase(str: string): string {
    return str.charAt(0).toLowerCase() + str.slice(1);
  }

  /**
   * Convert camelCase or PascalCase to Human Case
   */
  private humanize(str: string): string {
    return str
      // Split camelCase
      .replace(/([a-z0-9])([A-Z])/g, '$1 $2')
      // uppercase first letter
      .replace(/^./, s => s.toUpperCase());
  }
}

// CLI script to generate components
if (require.main === module) {
  (async () => {
    try {
      // FIXED ABSOLUTE PATHS
      const projectRoot = 'D:\\code\\CRMCup\\CRM_Frontend';
      const jhipsterDir = path.join(projectRoot, '.jhipster');
      const templateDir = path.join(projectRoot, 'codgen', 'nextjs', 'templates');
      const outputDir = path.join(projectRoot, 'src');
      
      console.log('Using paths:');
      console.log('- Project root:', projectRoot);
      console.log('- JHipster directory:', jhipsterDir);
      console.log('- Template directory:', templateDir);
      console.log('- Output directory:', outputDir);
      
      const generator = new NextJsGenerator(
        projectRoot,
        jhipsterDir,
        templateDir,
        outputDir
      );
      
      const entityName = process.argv[2];
      if (entityName) {
        await generator.generateEntity(entityName);
      } else {
        await generator.generateAll();
      }
    } catch (error) {
      console.error('Error generating components:', error);
      process.exit(1);
    }
  })();
}
</file>

<file path="INSTRUCTIONS.md">
# Instructions for Using the Next.js CRUD Generator

## Installation

1. First, install the required dependencies:
   ```bash
   cd D:\code\CRMCup\CRM_Frontend\codgen\nextjs
   npm install ejs
   ```

## Running the Generator

You can run the generator in one of two ways:

### Option 1: Direct execution (recommended)

1. Navigate to the generator directory:
   ```bash
   cd D:\code\CRMCup\CRM_Frontend\codgen\nextjs
   ```

2. Run the simple test generator to verify it's working:
   ```bash
   node simple-generator.js
   ```

3. When the test generator works, run the full generator:
   ```bash
   # For all entities:
   node generator.js
   
   # For a specific entity:
   node generator.js Party
   ```

### Option 2: Using npm scripts

1. In your project's main package.json, we've added two scripts:
   ```json
   "generate-nextjs": "cd codgen/nextjs && npm run generate",
   "generate-nextjs:entity": "cd codgen/nextjs && npm run generate:entity"
   ```

2. Run the generator:
   ```bash
   npm run generate-nextjs
   ```

## Troubleshooting

If you encounter any issues:

1. Make sure all paths in the generator script are correct
2. Check if the entity JSON files in the .jhipster directory are valid
3. Verify that the template files exist in the templates directory

## Expected Output

The generator will create Next.js components in the following structure:
```
src/app/(protected)/[entity-name]s/
‚îú‚îÄ‚îÄ components/
‚îÇ   ‚îú‚îÄ‚îÄ [entity-name]-table.tsx
‚îÇ   ‚îú‚îÄ‚îÄ [entity-name]-form.tsx
‚îÇ   ‚îî‚îÄ‚îÄ [entity-name]-details.tsx
‚îú‚îÄ‚îÄ new/
‚îÇ   ‚îî‚îÄ‚îÄ page.tsx
‚îú‚îÄ‚îÄ [id]/
‚îÇ   ‚îú‚îÄ‚îÄ page.tsx
‚îÇ   ‚îî‚îÄ‚îÄ edit/
‚îÇ       ‚îî‚îÄ‚îÄ page.tsx
‚îî‚îÄ‚îÄ page.tsx
```
</file>

<file path="package.json">
{
  "name": "@crm/nextjs-generator",
  "version": "1.0.0",
  "description": "Next.js CRUD component generator for JHipster entities",
  "main": "generator.js",
  "scripts": {
    "generate": "node generate.js",
    "generate:entity": "node generate.js"
  },
  "dependencies": {
    "ejs": "^3.1.9",
    "pluralize": "^8.0.0",
    "ts-node": "^10.9.2"
  },
  "devDependencies": {
    "@types/ejs": "^3.1.5",
    "typescript": "^5.8.3"
  }
}
</file>

<file path="PAGINATED_RELATIONSHIPS_README.md">
# Paginated Relationship Combobox Implementation

## Overview
Successfully implemented paginated/infinite query support for relationship fields in the Next.js code generator templates. This allows handling large datasets in relationship dropdowns with search functionality and infinite scrolling.

## Changes Made

### 1. New Component: `PaginatedRelationshipCombobox`
- **Location**: `templates/entity/components/paginated-relationship-combobox.tsx.ejs`
- **Features**:
  - ‚úÖ Infinite query support with pagination
  - ‚úÖ Search functionality with debounced input (300ms)
  - ‚úÖ Both single and multiple selection support
  - ‚úÖ Loading states and infinite scroll
  - ‚úÖ Proper error handling
  - ‚úÖ Unique keys to prevent React warnings

### 2. Updated Entity Form Template
- **Location**: `templates/entity/components/entity-form.tsx.ejs`
- **Changes**:
  - ‚úÖ Replaced static `RelationshipCombobox` with `PaginatedRelationshipCombobox`
  - ‚úÖ Added infinite query hook imports (`useGetAll[Entity]Infinite`, `useSearch[Entity]Infinite`)
  - ‚úÖ Fixed TextBlob field rendering (now uses `<Textarea>` instead of `<Input>`)
  - ‚úÖ Added proper error handling for built-in user relationships

### 3. Updated Generator
- **Location**: `generator.ts`
- **Changes**:
  - ‚úÖ Added automatic generation of `paginated-relationship-combobox.tsx` for entities with relationships
  - ‚úÖ Only generates the component when there are persistable relationships

## Key Features

### Infinite Query Support
```typescript
const infiniteQuery = useInfiniteQueryHook(
  shouldUseSearch ? {} : { size: 20 },
  {
    query: {
      enabled: !shouldUseSearch,
      getNextPageParam: (lastPage, allPages) => {
        // Smart pagination logic that handles both array and paginated responses
      }
    }
  }
);
```

### Search with Debouncing
```typescript
// 300ms debounced search
React.useEffect(() => {
  const timer = setTimeout(() => {
    setDeferredSearchQuery(searchQuery);
  }, 300);
  return () => clearTimeout(timer);
}, [searchQuery]);
```

### Smart Data Handling
The component automatically handles different API response formats:
- Direct arrays: `[{id: 1, name: "Item 1"}, ...]`
- Paginated responses: `{content: [{id: 1, name: "Item 1"}], ...}`

### Usage Example
```tsx
<PaginatedRelationshipCombobox
  value={field.value}
  onValueChange={field.onChange}
  displayField="name"
  placeholder="Select city"
  multiple={false}
  useInfiniteQueryHook={useGetAllCitiesInfinite}
  searchHook={useSearchCitiesInfinite}
  entityName="Cities"
  searchField="name"
/>
```

## API Integration

### Required Infinite Query Hooks
The generated endpoints provide these hooks automatically:
- `useGetAll[Entity]Infinite` - For paginated loading
- `useSearch[Entity]Infinite` - For search functionality

### Parameters Supported
- **Pagination**: `page`, `size`
- **Search**: `query` parameter
- **Filtering**: Entity-specific filters (e.g., `name.contains`)

## Benefits

1. **Performance**: Only loads data as needed, reducing initial load time
2. **User Experience**: Smooth infinite scrolling with search
3. **Scalability**: Handles large datasets (1000+ items) efficiently
4. **Flexibility**: Works with both single and multiple selections
5. **Error Handling**: Proper loading states and error messages

## Generated Files Structure
```
src/app/(protected)/[entity-plural]/
‚îú‚îÄ‚îÄ components/
‚îÇ   ‚îú‚îÄ‚îÄ [entity]-form.tsx                    # Updated to use paginated combobox
‚îÇ   ‚îú‚îÄ‚îÄ paginated-relationship-combobox.tsx # New paginated component
‚îÇ   ‚îî‚îÄ‚îÄ ... (other components)
```

## Testing
- ‚úÖ Generated Party form with City relationship
- ‚úÖ Generated City form with District relationship
- ‚úÖ Fixed React key warnings
- ‚úÖ Fixed TextBlob field rendering
- ‚úÖ Proper API integration

## Browser Console Error Fixes
- Fixed "children with same key" error by using unique keys: `${entityName}-${option.id}`
- Enhanced data structure handling for different API response formats
- Added proper loading states and error boundaries

The implementation is now ready for production use and provides a smooth, scalable solution for handling relationships in forms.
</file>

<file path="README.md">
# Next.js CRUD Generator for JHipster Entities

This tool generates Next.js CRUD components with shadcn UI for JHipster entity definitions.

## Correct Paths

The generator now uses these hardcoded paths for clarity:
- JHipster entity definitions: `D:\code\CRMCup\CRM_Frontend\.jhipster`
- Template files: `D:\code\CRMCup\CRM_Frontend\codgen\nextjs\templates`
- Output directory: `D:\code\CRMCup\CRM_Frontend\src\app\(protected)`

## Usage

1. First, make sure you're in the correct directory:
   ```bash
   cd D:\code\CRMCup\CRM_Frontend\codgen\nextjs
   ```

2. Install dependencies if you haven't already:
   ```bash
   npm install
   ```

3. Test the generator with a simple test:
   ```bash
   node simple-generator.js
   ```

4. Run the full generator:
   ```bash
   # For all entities
   npx ts-node generator.ts
   
   # For a specific entity
   npx ts-node generator.ts Party
   ```

## Troubleshooting

If you encounter any issues:
- Make sure the paths in the scripts match your actual directory structure
- Verify that all JHipster entity JSON files exist in the `.jhipster` directory
- Check that the template files exist in the `templates` directory

## Generated Components

The generator will create the following structure for each entity:

```
src/app/(protected)/[entity-name-plural]/
‚îú‚îÄ‚îÄ components/
‚îÇ   ‚îú‚îÄ‚îÄ [entity-name]-table.tsx
‚îÇ   ‚îú‚îÄ‚îÄ [entity-name]-form.tsx
‚îÇ   ‚îî‚îÄ‚îÄ [entity-name]-details.tsx
‚îú‚îÄ‚îÄ new/
‚îÇ   ‚îî‚îÄ‚îÄ page.tsx
‚îú‚îÄ‚îÄ [id]/
‚îÇ   ‚îú‚îÄ‚îÄ page.tsx
‚îÇ   ‚îî‚îÄ‚îÄ edit/
‚îÇ       ‚îî‚îÄ‚îÄ page.tsx
‚îî‚îÄ‚îÄ page.tsx
```

## Features

- Modern Next.js App Router components
- shadcn UI components
- React Hook Form with Zod validation
- Integration with React Query hooks
- Pagination, sorting, and filtering
</file>

<file path="templates/components/auth/permission-guard.tsx">
"use client";

import { ReactNode } from "react";
import { useAuth } from "@/providers/session-provider";
import { UnauthorizedPage } from "./unauthorized-page";

interface PermissionGuardProps {
  children: ReactNode;
  requiredPermission: string;
  fallback?: ReactNode;
  showUnauthorizedPage?: boolean;
  unauthorizedTitle?: string;
  unauthorizedDescription?: string;
}

/**
 * Permission Guard Component
 * 
 * Renders children only if the user has the required permission.
 * Uses the optimized session provider to reduce redundant session calls.
 * 
 * Permission naming convention:
 * - {entityName}:create - Can create new entities
 * - {entityName}:read   - Can view entities  
 * - {entityName}:update - Can edit entities
 * - {entityName}:delete - Can delete entities
 * 
 * @param children - Content to render if permission is granted
 * @param requiredPermission - Permission string to check (e.g., "user:create", "party:read")
 * @param fallback - Optional fallback content to render if permission is denied
 * @param showUnauthorizedPage - Whether to show full unauthorized page (default: true for page-level guards)
 * @param unauthorizedTitle - Custom title for unauthorized page
 * @param unauthorizedDescription - Custom description for unauthorized page
 */
export function PermissionGuard({ 
  children, 
  requiredPermission, 
  fallback = null,
  showUnauthorizedPage = true,
  unauthorizedTitle,
  unauthorizedDescription
}: PermissionGuardProps) {
  const { session, status, isLoading } = useAuth();

  // Loading state
  if (isLoading) {
    return (
      <div className="flex items-center justify-center min-h-[200px]">
        <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-primary"></div>
      </div>
    );
  }

  // Not authenticated
  if (!session?.user) {
    if (showUnauthorizedPage) {
      return (
        <UnauthorizedPage
          title="Authentication Required"
          description="You need to be signed in to access this resource."
          requiredPermission={requiredPermission}
        />
      );
    }
    return <>{fallback}</>;
  }

  // Check if user has the required permission
  const userRoles = session.user.roles || [];
  const hasPermission = userRoles.includes(requiredPermission);

  if (!hasPermission) {
    if (showUnauthorizedPage) {
      return (
        <UnauthorizedPage
          title={unauthorizedTitle}
          description={unauthorizedDescription}
          requiredPermission={requiredPermission}
        />
      );
    }
    return <>{fallback}</>;
  }

  return <>{children}</>;
}

/**
 * Inline Permission Guard Component
 * 
 * For smaller UI elements like buttons, use this component which doesn't show 
 * the full unauthorized page but just hides the content.
 */
export function InlinePermissionGuard({ 
  children, 
  requiredPermission, 
  fallback = null 
}: {
  children: ReactNode;
  requiredPermission: string;
  fallback?: ReactNode;
}) {
  return (
    <PermissionGuard
      requiredPermission={requiredPermission}
      fallback={fallback}
      showUnauthorizedPage={false}
    >
      {children}
    </PermissionGuard>
  );
}

/**
 * Hook to check if user has a specific permission
 * Uses the auth provider for better performance
 * 
 * @param permission - Permission string to check
 * @returns boolean indicating if user has the permission
 */
export function usePermission(permission: string): boolean {
  const { session, status } = useAuth();

  if (status === "loading" || !session?.user) {
    return false;
  }

  const userRoles = session.user.roles || [];
  return userRoles.includes(permission);
}

/**
 * Hook to check if user has any of the specified roles
 * Uses the auth provider for better performance
 * 
 * @param roles - Array of permission strings to check
 * @returns boolean indicating if user has at least one of the roles
 */
export function useAnyPermission(roles: string[]): boolean {
  const { session, status } = useAuth();

  if (status === "loading" || !session?.user) {
    return false;
  }

  const userRoles = session.user.roles || [];
  return roles.some(permission => userRoles.includes(permission));
}

/**
 * Hook to check if user has all of the specified roles
 * Uses the auth provider for better performance
 * 
 * @param roles - Array of permission strings to check
 * @returns boolean indicating if user has all of the roles
 */
export function useAllRoles(roles: string[]): boolean {
  const { session, status } = useAuth();

  if (status === "loading" || !session?.user) {
    return false;
  }

  const userRoles = session.user.roles || [];
  return roles.every(permission => userRoles.includes(permission));
}
</file>

<file path="templates/components/auth/unauthorized-page.tsx">
import Link from "next/link";
import { ShieldX, ArrowLeft, Home } from "lucide-react";
import { Button } from "@/components/ui/button";
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card";

interface UnauthorizedPageProps {
  title?: string;
  description?: string;
  requiredPermission?: string;
  showBackButton?: boolean;
  backUrl?: string;
}

export function UnauthorizedPage({
  title = "Access Denied",
  description = "You don't have permission to access this resource.",
  requiredPermission,
  showBackButton = true,
  backUrl = "/",
}: UnauthorizedPageProps) {
  return (
    <div className="min-h-[calc(100vh-200px)] flex items-center justify-center p-4">
      <Card className="w-full max-w-md">
        <CardHeader className="text-center">
          <div className="mx-auto mb-4 h-12 w-12 rounded-full bg-destructive/10 flex items-center justify-center">
            <ShieldX className="h-6 w-6 text-destructive" />
          </div>
          <CardTitle className="text-2xl font-bold">{title}</CardTitle>
          <CardDescription className="text-base">
            {description}
          </CardDescription>
          {requiredPermission && (
            <div className="mt-4 p-3 bg-muted rounded-lg">
              <p className="text-sm text-muted-foreground">
                Required permission: <code className="bg-background px-2 py-1 rounded text-xs font-mono">{requiredPermission}</code>
              </p>
            </div>
          )}
        </CardHeader>
        <CardContent className="space-y-4">
          <div className="text-center text-sm text-muted-foreground">
            <p>If you believe this is an error, please contact your system administrator.</p>
          </div>
          <div className="flex flex-col sm:flex-row gap-2">
            {showBackButton && (
              <Button variant="outline" className="flex-1" asChild>
                <Link href={backUrl}>
                  <ArrowLeft className="h-4 w-4 mr-2" />
                  Go Back
                </Link>
              </Button>
            )}
            <Button className="flex-1" asChild>
              <Link href="/">
                <Home className="h-4 w-4 mr-2" />
                Home
              </Link>
            </Button>
          </div>
        </CardContent>
      </Card>
    </div>
  );
}
</file>

<file path="templates/components/context-aware-back-button.tsx">
"use client";

import { useEffect, useState } from "react";
import Link from "next/link";
import { ArrowLeft } from "lucide-react";
import { Button } from "@/components/ui/button";

interface ContextAwareBackButtonProps {
  defaultRoute: string;
  defaultLabel?: string;
  entityName: string;
}

export function ContextAwareBackButton({ 
  defaultRoute, 
  defaultLabel = "Back to Previous Page", 
  entityName 
}: ContextAwareBackButtonProps) {
  const [backRoute, setBackRoute] = useState(defaultRoute);

  useEffect(() => {
    const returnUrl = localStorage.getItem('returnUrl');
    if (returnUrl) {
      setBackRoute(returnUrl);
    }
  }, []);

  const handleBackClick = () => {
    // Clean up form state if coming from a form
    const currentPath = window.location.pathname;
    const isFromForm = currentPath.includes('/new') || currentPath.includes('/edit');
    
    if (isFromForm && entityName) {
      // Get current session ID and clean up form state
      const formSession = sessionStorage.getItem(`${entityName}FormSession`);
      if (formSession) {
        localStorage.removeItem(`${entityName}FormState_${formSession}`);
        sessionStorage.removeItem(`${entityName}FormSession`);
        
        // Clean up all old form states for this entity
        const keysToRemove: string[] = [];
        for (let i = 0; i < localStorage.length; i++) {
          const key = localStorage.key(i);
          if (key?.startsWith(`${entityName}FormState_`)) {
            keysToRemove.push(key);
          }
        }
        keysToRemove.forEach(key => localStorage.removeItem(key));
      }
    }
    
    // Clean up navigation context
    localStorage.removeItem('entityCreationContext');
    localStorage.removeItem('referrerInfo');
    localStorage.removeItem('returnUrl');
  };

  return (
    <Button variant="ghost" size="sm" asChild>
      <Link href={backRoute} onClick={handleBackClick}>
        <ArrowLeft className="h-4 w-4 mr-2" />
        Back to Previous Page
      </Link>
    </Button>
  );
}
</file>

<file path="templates/components/toaster-provider.tsx.ejs">
"use client";

import { Toaster } from "sonner";

export function ToasterProvider() {
  return (
    <Toaster
      position="bottom-right"
      expand={false}
      richColors
      closeButton
      duration={4000}
      visibleToasts={3}
      toastOptions={{
        style: {
          fontFamily: 'var(--font-sans)',
        },
        classNames: {
          error: 'border-red-500 bg-red-50 text-red-900',
          success: 'border-green-500 bg-green-50 text-green-900',
          warning: 'border-yellow-500 bg-yellow-50 text-yellow-900',
          info: 'border-blue-500 bg-blue-50 text-blue-900',
        },
      }}
    />
  );
}
</file>

<file path="templates/entity/[id]/edit/page.tsx.ejs">
<%#
 Copyright 2013-2025 the original author or authors from the JHipster project.

 This file is part of the JHipster project, see https://www.jhipster.tech/
 for more information.

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

      https://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
-%>
import Link from "next/link";
import { ArrowLeft } from "lucide-react";
import { Button } from "@/components/ui/button";

import { <%= entityClass %>Form } from "../../components/<%= entityFileName %>-form";
import { PageHeader } from "@/components/page-header";
import { PageTitle } from "@/components/page-title";
import { PermissionGuard } from "@/components/auth/permission-guard";
import { ContextAwareBackButton } from "@/components/context-aware-back-button";

interface Edit<%= entityClass %>PageProps {
  params: Promise<{
    id: string;
  }>;
}

export const metadata = {
  title: "Edit <%= entityClass %>",
};

export default async function Edit<%= entityClass %>Page({ params }: Edit<%= entityClass %>PageProps) {
  const { id: idParam } = await params;
  const id = parseInt(idParam, 10);

  return (
    <PermissionGuard 
      requiredPermission="<%= entityInstance %>:update"
      unauthorizedTitle="Access Denied to Edit <%= entityClassHumanized %>"
      unauthorizedDescription="You don't have permission to edit <%= entityClassHumanized.toLowerCase() %> records."
    >
      <div className="space-y-6">
        <div className="flex items-center justify-between">
          <PageHeader>
            <ContextAwareBackButton 
              defaultRoute="/<%= routePath %>"
              defaultLabel="Back to <%= entityClassPluralHumanized %>"
              entityName="<%= entityClass %>"
            />
          </PageHeader>
        </div>

        <div className="bg-white rounded-lg border border-gray-200 p-6 shadow-sm">
          <div className="flex items-center gap-3 mb-6">
            <div className="w-1 h-8 bg-blue-600 rounded-full"></div>
            <div>
              <h1 className="text-2xl font-semibold text-gray-900">Edit <%= entityClassHumanized %></h1>
              <p className="text-sm text-gray-600 mt-1">Update the information for this <%= entityClassHumanized.toLowerCase() %></p>
            </div>
          </div>
          
          <<%= entityClass %>Form id={id} />
        </div>
      </div>
    </PermissionGuard>
  );
}
</file>

<file path="templates/entity/[id]/page.tsx.ejs">
<%#
 Copyright 2013-2025 the original author or authors from the JHipster project.

 This file is part of the JHipster project, see https://www.jhipster.tech/
 for more information.

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

      https://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
-%>
import Link from "next/link";
import { ArrowLeft, Pencil } from "lucide-react";
import { Button } from "@/components/ui/button";

import { <%= entityClass %>Details } from "../components/<%= entityFileName %>-details";
import { PageHeader } from "@/components/page-header";
import { PageTitle } from "@/components/page-title";
import { PermissionGuard, InlinePermissionGuard } from "@/components/auth/permission-guard";
import { ContextAwareBackButton } from "@/components/context-aware-back-button";

interface <%= entityClass %>PageProps {
  params: Promise<{
    id: string;
  }>;
}

export const metadata = {
  title: "<%= entityClass %> Details",
};

export default async function <%= entityClass %>Page({ params }: <%= entityClass %>PageProps) {
  const { id: idParam } = await params;
  const id = parseInt(idParam, 10);

  return (
    <PermissionGuard 
      requiredPermission="<%= entityInstance %>:read"
      unauthorizedTitle="Access Denied to <%= entityClassHumanized %> Details"
      unauthorizedDescription="You don't have permission to view this <%= entityClassHumanized.toLowerCase() %>."
    >
      <div className="space-y-6">
        <div className="flex items-center justify-between">
          <PageHeader>
            <ContextAwareBackButton 
              defaultRoute="/<%= routePath %>"
              defaultLabel="Back to <%= entityClassPluralHumanized %>"
              entityName="<%= entityClass %>"
            />
          </PageHeader>
        </div>

        <div className="bg-white rounded-lg border border-gray-200 p-6 shadow-sm">
          <div className="flex items-center gap-3 mb-6">
            <div className="w-1 h-8 bg-blue-600 rounded-full"></div>
            <div>
              <h1 className="text-2xl font-semibold text-gray-900"><%= entityClassHumanized %> Details</h1>
              <p className="text-sm text-gray-600 mt-1">View detailed information for this <%= entityClassHumanized.toLowerCase() %></p>
            </div>
          </div>
          
          <<%= entityClass %>Details id={id} />
        </div>
      </div>
    </PermissionGuard>
  );
}
</file>

<file path="templates/entity/actions/entity-actions.ts.ejs">
<%#
 Copyright 2013-2025 the original author or authors from the JHipster project.
-%>
"use server";

import { revalidatePath } from "next/cache";
import { redirect } from "next/navigation";
import { toast } from "sonner";
import { <%= entityInstance %>Toast } from "../components/<%= entityFileName %>-toast";

export async function create<%= entityClass %>Action(formData: FormData) {
  try {
    // Process form data and create entity
    const result = await create<%= entityClass %>(formData);
    
    revalidatePath("/<%= routePath %>");
    <%= entityInstance %>Toast.created();
    
    return { success: true, data: result };
  } catch (error) {
    console.error("Failed to create <%= entityClass.toLowerCase() %>:", error);
    <%= entityInstance %>Toast.createError(error?.message);
    return { success: false, error: error?.message };
  }
}

export async function update<%= entityClass %>Action(id: number, formData: FormData) {
  try {
    const result = await update<%= entityClass %>(id, formData);
    
    revalidatePath("/<%= routePath %>");
    revalidatePath(`/<%= routePath %>/${id}`);
    <%= entityInstance %>Toast.updated();
    
    return { success: true, data: result };
  } catch (error) {
    console.error("Failed to update <%= entityClass.toLowerCase() %>:", error);
    <%= entityInstance %>Toast.updateError(error?.message);
    return { success: false, error: error?.message };
  }
}

export async function delete<%= entityClass %>Action(id: number) {
  try {
    await delete<%= entityClass %>(id);
    
    revalidatePath("/<%= routePath %>");
    <%= entityInstance %>Toast.deleted();
    
    return { success: true };
  } catch (error) {
    console.error("Failed to delete <%= entityClass.toLowerCase() %>:", error);
    <%= entityInstance %>Toast.deleteError(error?.message);
    return { success: false, error: error?.message };
  }
}

export async function bulkDelete<%= entityClass %>Action(ids: number[]) {
  try {
    const results = await Promise.allSettled(
      ids.map(id => delete<%= entityClass %>(id))
    );
    
    const successCount = results.filter(r => r.status === 'fulfilled').length;
    const errorCount = results.filter(r => r.status === 'rejected').length;
    
    revalidatePath("/<%= routePath %>");
    
    if (errorCount === 0) {
      <%= entityInstance %>Toast.bulkDeleted(successCount);
    } else if (successCount > 0) {
      toast.warning(`${successCount} deleted, ${errorCount} failed`);
    } else {
      <%= entityInstance %>Toast.bulkDeleteError();
    }
    
    return { success: errorCount === 0, successCount, errorCount };
  } catch (error) {
    console.error("Bulk delete failed:", error);
    <%= entityInstance %>Toast.bulkDeleteError(error?.message);
    return { success: false, error: error?.message };
  }
}
</file>

<file path="templates/entity/components/bulk-relationship-assignment.tsx.ejs">
"use client";

import * as React from "react";
import { Loader2, Check } from "lucide-react";
import { Button } from "@/components/ui/button";
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
} from "@/components/ui/dialog";
import {
  Command,
  CommandEmpty,
  CommandGroup,
  CommandInput,
  CommandItem,
  CommandList,
} from "@/components/ui/command";
import {
  Popover,
  PopoverContent,
  PopoverTrigger,
} from "@/components/ui/popover";
import { Label } from "@/components/ui/label";
import { cn } from "@/lib/utils";
import { toast } from "sonner";
import { <%= entityInstance %>Toast } from "./<%= entityFileName %>-toast";

<%
// Get all the relationships that could be edited
const displayableRelationships = relationships.filter(rel => 
  rel.relationshipType !== 'one-to-many' && 
  !rel.collection && 
  rel.otherEntityField
);
%>

interface BulkRelationshipAssignmentProps {
  open: boolean;
  onOpenChange: (open: boolean) => void;
  selectedEntityIds: number[];
  relationshipConfigs: Array<{
    name: string;
    displayName: string;
    options: Array<{ id: number; [key: string]: any }>;
    displayField: string;
    isEditable: boolean;
  }>;
  onBulkUpdate: (entityIds: number[], relationshipName: string, newValue: number | null) => Promise<void>;
}

export function BulkRelationshipAssignment({
  open,
  onOpenChange,
  selectedEntityIds,
  relationshipConfigs,
  onBulkUpdate,
}: BulkRelationshipAssignmentProps) {
  const [selectedRelationship, setSelectedRelationship] = React.useState<string>("");
  const [selectedValue, setSelectedValue] = React.useState<number | null>(null);
  const [isUpdating, setIsUpdating] = React.useState(false);
  const [relationshipOpen, setRelationshipOpen] = React.useState(false);
  const [valueOpen, setValueOpen] = React.useState(false);

  // Get editable relationships
  const editableRelationships = relationshipConfigs.filter(config => config.isEditable);

  // Get current relationship config
  const currentRelationshipConfig = editableRelationships.find(
    config => config.name === selectedRelationship
  );

  // Get display value for selected relationship
  const getRelationshipDisplayValue = () => {
    if (!selectedRelationship) return "Select relationship...";
    const config = currentRelationshipConfig;
    return config ? config.displayName : selectedRelationship;
  };

  // Get display value for selected value
  const getValueDisplayValue = () => {
    if (!currentRelationshipConfig) return "Select relationship first...";
    if (selectedValue === null) return "None (clear relationship)";
    
    const option = currentRelationshipConfig.options.find(opt => opt.id === selectedValue);
    return option ? option[currentRelationshipConfig.displayField] : "Select value...";
  };

  // Handle bulk update
  const handleBulkUpdate = async () => {
    if (!selectedRelationship) {
      <%= entityInstance %>Toast.validationError(["relationship field"]);
      return;
    }

    setIsUpdating(true);
    
    try {
      await onBulkUpdate(selectedEntityIds, selectedRelationship, selectedValue);
      
      const action = selectedValue === null ? "cleared" : "updated";
      <%= entityInstance %>Toast.custom.success(
        `üîó Bulk ${action.charAt(0).toUpperCase() + action.slice(1)}!`,
        `${selectedRelationship} ${action} for ${selectedEntityIds.length} item${
          selectedEntityIds.length > 1 ? 's' : ''
        }`
      );
      
      // Close dialog and reset state
      onOpenChange(false);
    } catch (error) {
      console.error('Bulk update error:', error);
      <%= entityInstance %>Toast.custom.error(
        "‚ùå Bulk Update Failed",
        `Failed to update ${selectedRelationship}`
      );
    } finally {
      setIsUpdating(false);
    }
  };

  // Reset form when dialog closes
  React.useEffect(() => {
    if (!open) {
      setSelectedRelationship("");
      setSelectedValue(null);
      setIsUpdating(false); // Ensure updating state is reset
    }
  }, [open]);

  return (
    <Dialog open={open} onOpenChange={onOpenChange}>
      <DialogContent className="sm:max-w-[425px]">
        <DialogHeader>
          <DialogTitle>Bulk Association Assignment</DialogTitle>
          <DialogDescription>
            Update association fields for {selectedEntityIds.length} selected item
            {selectedEntityIds.length > 1 ? 's' : ''}.
          </DialogDescription>
        </DialogHeader>

        <div className="grid gap-4 py-4">
          {editableRelationships.length === 0 ? (
            <div className="text-center text-muted-foreground py-4">
              No editable relationship fields configured.
              <br />
              Configure relationships in the table settings to enable bulk editing.
            </div>
          ) : (
            <>
              {/* Relationship Selection */}
              <div className="grid grid-cols-4 items-center gap-4">
                <Label htmlFor="relationship" className="text-right">
                  Field
                </Label>
                <div className="col-span-3">
                  <Popover open={relationshipOpen} onOpenChange={setRelationshipOpen}>
                    <PopoverTrigger asChild>
                      <Button
                        variant="outline"
                        role="combobox"
                        aria-expanded={relationshipOpen}
                        className="w-full justify-between"
                        disabled={isUpdating}
                      >
                        <span className="truncate">{getRelationshipDisplayValue()}</span>
                        <Check className="ml-2 h-4 w-4 shrink-0 opacity-50" />
                      </Button>
                    </PopoverTrigger>
                    <PopoverContent className="w-full p-0" align="start">
                      <Command>
                        <CommandInput placeholder="Search relationships..." />
                        <CommandList>
                          <CommandEmpty>No relationships found.</CommandEmpty>
                          <CommandGroup>
                            {editableRelationships.map((config) => (
                              <CommandItem
                                key={config.name}
                                value={config.displayName}
                                onSelect={() => {
                                  setSelectedRelationship(config.name);
                                  setSelectedValue(null); // Reset value when relationship changes
                                  setRelationshipOpen(false);
                                }}
                              >
                                <Check
                                  className={cn(
                                    "mr-2 h-4 w-4",
                                    selectedRelationship === config.name ? "opacity-100" : "opacity-0"
                                  )}
                                />
                                {config.displayName}
                              </CommandItem>
                            ))}
                          </CommandGroup>
                        </CommandList>
                      </Command>
                    </PopoverContent>
                  </Popover>
                </div>
              </div>

              {/* Value Selection */}
              <div className="grid grid-cols-4 items-center gap-4">
                <Label htmlFor="value" className="text-right">
                  Value
                </Label>
                <div className="col-span-3">
                  <Popover open={valueOpen} onOpenChange={setValueOpen}>
                    <PopoverTrigger asChild>
                      <Button
                        variant="outline"
                        role="combobox"
                        aria-expanded={valueOpen}
                        className="w-full justify-between"
                        disabled={isUpdating || !currentRelationshipConfig}
                      >
                        <span className="truncate">{getValueDisplayValue()}</span>
                        <Check className="ml-2 h-4 w-4 shrink-0 opacity-50" />
                      </Button>
                    </PopoverTrigger>
                    <PopoverContent className="w-full p-0" align="start">
                      <Command>
                        <CommandInput placeholder="Search options..." />
                        <CommandList>
                          <CommandEmpty>No options found.</CommandEmpty>
                          <CommandGroup>
                            {/* None option */}
                            <CommandItem
                              value="__none__"
                              onSelect={() => {
                                setSelectedValue(null);
                                setValueOpen(false);
                              }}
                            >
                              <Check
                                className={cn(
                                  "mr-2 h-4 w-4",
                                  selectedValue === null ? "opacity-100" : "opacity-0"
                                )}
                              />
                              <span className="text-muted-foreground">None (clear)</span>
                            </CommandItem>
                            
                            {/* Available options */}
                            {currentRelationshipConfig?.options.map((option) => (
                              <CommandItem
                                key={option.id}
                                value={option[currentRelationshipConfig.displayField]}
                                onSelect={() => {
                                  setSelectedValue(option.id);
                                  setValueOpen(false);
                                }}
                              >
                                <Check
                                  className={cn(
                                    "mr-2 h-4 w-4",
                                    selectedValue === option.id ? "opacity-100" : "opacity-0"
                                  )}
                                />
                                {option[currentRelationshipConfig.displayField]}
                              </CommandItem>
                            ))}
                          </CommandGroup>
                        </CommandList>
                      </Command>
                    </PopoverContent>
                  </Popover>
                </div>
              </div>
            </>
          )}
        </div>

        <DialogFooter>
          <Button
            variant="outline"
            onClick={() => onOpenChange(false)}
            disabled={isUpdating}
          >
            Cancel
          </Button>
          <Button
            onClick={handleBulkUpdate}
            disabled={isUpdating || !selectedRelationship || editableRelationships.length === 0}
          >
            {isUpdating ? (
              <>
                <Loader2 className="mr-2 h-4 w-4 animate-spin" />
                Updating...
              </>
            ) : (
              "Update All"
            )}
          </Button>
        </DialogFooter>
      </DialogContent>
    </Dialog>
  );
}
</file>

<file path="templates/entity/components/entity-details.tsx.ejs">
<%#
 Copyright 2013-2025 the original author or authors from the JHipster project.
-%>
"use client";

import { useState } from "react";
import Link from "next/link";
import { useRouter } from "next/navigation";
import { format } from "date-fns";
import { Trash2, ArrowLeft, Pencil } from "lucide-react";
import { toast } from "sonner";
import { <%= entityInstance %>Toast, handle<%= entityClass %>Error } from "./<%= entityFileName %>-toast";
import { Button } from "@/components/ui/button";
import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
} from "@/components/ui/alert-dialog";
import { Badge } from "@/components/ui/badge";

import {
  useGet<%= entityClass %>,
  useDelete<%= entityClass %>,
} from "@/core/api/generated/spring/endpoints/<%= entityFileName %>-resource/<%= entityFileName %>-resource.gen";

<%
// Helper function to convert camelCase to Title Case
function camelToTitleCase(str) {
  return str
    .replace(/([A-Z])/g, ' $1')
    .replace(/^./, str => str.toUpperCase())
    .trim();
}

// Filter relationships to avoid undefined properties
const safeRelationships = (relationships || []).filter(
  rel => rel && rel.relationshipName && rel.otherEntity && 
  rel.relationshipType !== 'one-to-many' && !rel.collection && rel.otherEntityField
);
%>

interface <%= entityClass %>DetailsProps {
  id: number;
}

export function <%= entityClass %>Details({ id }: <%= entityClass %>DetailsProps) {
  const router = useRouter();
  const [showDeleteDialog, setShowDeleteDialog] = useState(false);

  // Fetch entity details
  const { data: entity, isLoading } = useGet<%= entityClass %>(id, {
    query: {
      enabled: !!id,
    },
  });

  // Delete mutation
  const { mutate: deleteEntity } = useDelete<%= entityClass %>({
    mutation: {
      onSuccess: () => {
        <%= entityInstance %>Toast.deleted();
        router.push("/<%= entityRoute %>");
      },
      onError: (error) => {
        handle<%= entityClass %>Error(error);
      },
    },
  });

  const handleDelete = () => {
    deleteEntity({ id });
    setShowDeleteDialog(false);
  };

  if (isLoading) {
    return (
      <div className="flex items-center justify-center h-64">
        <div className="text-lg">Loading...</div>
      </div>
    );
  }

  if (!entity) {
    return (
      <div className="flex items-center justify-center h-64">
        <div className="text-lg text-muted-foreground">Entity not found</div>
      </div>
    );
  }

  return (
    <>
      <div className="grid grid-cols-1 lg:grid-cols-2 xl:grid-cols-3 gap-6">
        {/* Basic Information */}
        <div className="lg:col-span-1 xl:col-span-2 space-y-6">
          <Card>
            <CardHeader>
              <CardTitle className="text-lg font-semibold text-foreground border-b pb-3">
                Basic Information
              </CardTitle>
            </CardHeader>
            <CardContent>
              <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
                <% for (field of fields) { 
                  const fieldName = field.fieldName;
                  const fieldLabel = camelToTitleCase(fieldName);
                %>
                <div className="space-y-2">
                  <dt className="text-xs font-semibold text-muted-foreground uppercase tracking-wide"><%= fieldLabel %></dt>
                  <dd className="text-sm font-medium">
                    <% if (field.fieldTypeBoolean) { %>
                    <Badge variant={entity.<%= fieldName %> ? "default" : "secondary"} className="text-sm">
                      {entity.<%= fieldName %> ? "Yes" : "No"}
                    </Badge>
                    <% } else if (field.fieldTypeTimed || field.fieldTypeLocalDate) { %>
                    <span className="text-foreground">
                      {entity.<%= fieldName %> ? format(new Date(entity.<%= fieldName %>), "PPP") : "‚Äî"}
                    </span>
                    <% } else if (field.fieldTypeBinary && !field.blobContentTypeText) { %>
                    <div>
                      {entity.<%= fieldName %> ? (
                        <% if (field.blobContentTypeImage) { %>
                        <img
                          src={`data:${entity.<%= fieldName %>ContentType};base64,${entity.<%= fieldName %>}`}
                          alt="<%= fieldLabel %>"
                          className="max-h-32 rounded-lg border shadow-sm"
                        />
                        <% } else { %>
                        <Badge variant="outline" className="text-sm">Binary data</Badge>
                        <% } %>
                      ) : "‚Äî"}
                    </div>
                    <% } else if (field.fieldIsEnum) { %>
                    <Badge variant="outline" className="text-sm font-medium">{entity.<%= fieldName %> || "‚Äî"}</Badge>
                    <% } else { %>
                    <span className="text-foreground break-words">{entity.<%= fieldName %> || "‚Äî"}</span>
                    <% } %>
                  </dd>
                </div>
                <% } %>
              </div>
            </CardContent>
          </Card>
        </div>

        <% if (safeRelationships.length > 0) { %>
        {/* Relationships */}
        <div className="lg:col-span-1 xl:col-span-1 space-y-6">
          <Card>
            <CardHeader>
              <CardTitle className="text-lg font-semibold text-foreground border-b pb-3">
                Related Information
              </CardTitle>
            </CardHeader>
            <CardContent>
              <div className="space-y-4">
                <% for (const rel of safeRelationships) { 
                  const relationshipFieldName = rel.relationshipFieldName;
                  const relationshipLabel = camelToTitleCase(rel.relationshipName);
                  const displayField = rel.otherEntity.builtInUser ? 'login' : rel.otherEntityField;
                %>
                <div className="space-y-2">
                  <dt className="text-xs font-semibold text-muted-foreground uppercase tracking-wide"><%= relationshipLabel %></dt>
                  <dd className="text-sm font-medium">
                    <% if (rel.collection) { %>
                    {entity.<%= relationshipFieldName %>?.length ? (
                      <div className="flex flex-wrap gap-2">
                        {entity.<%= relationshipFieldName %>.map((item, index) => (
                          <Badge key={index} variant="outline" className="text-sm">
                            {item.<%= displayField %> || item.id}
                          </Badge>
                        ))}
                      </div>
                    ) : "‚Äî"}
                    <% } else { %>
                    {entity.<%= relationshipFieldName %> ? (
                      <Badge variant="outline" className="text-sm font-medium">
                        {(entity.<%= relationshipFieldName %> as any).<%= displayField %> || entity.<%= relationshipFieldName %>.id}
                      </Badge>
                    ) : "‚Äî"}
                    <% } %>
                  </dd>
                </div>
                <% } %>
              </div>
            </CardContent>
          </Card>
        </div>
        <% } %>
      </div>

      {/* Action Buttons */}
      <div className="mt-8 pt-6 border-t">
        <div className="flex flex-col sm:flex-row gap-3 sm:justify-end">
          <Button variant="outline" asChild className="flex items-center gap-2 justify-center">
            <Link href={`/<%= entityRoute %>/${id}/edit`}>
              <Pencil className="h-4 w-4" />
              Edit
            </Link>
          </Button>
          <Button 
            variant="destructive"
            onClick={() => setShowDeleteDialog(true)}
            className="flex items-center gap-2 justify-center"
          >
            <Trash2 className="h-4 w-4" />
            Delete
          </Button>
        </div>
      </div>

      <AlertDialog open={showDeleteDialog} onOpenChange={setShowDeleteDialog}>
        <AlertDialogContent>
          <AlertDialogHeader>
            <AlertDialogTitle>Are you sure?</AlertDialogTitle>
            <AlertDialogDescription>
              This action cannot be undone. This will permanently delete the
              <%= entityClass.toLowerCase() %> and remove its data from the server.
            </AlertDialogDescription>
          </AlertDialogHeader>
          <AlertDialogFooter>
            <AlertDialogCancel>Cancel</AlertDialogCancel>
            <AlertDialogAction
              onClick={handleDelete}
              className="bg-destructive text-destructive-foreground hover:bg-destructive/90"
            >
              Delete
            </AlertDialogAction>
          </AlertDialogFooter>
        </AlertDialogContent>
      </AlertDialog>
    </>
  );
}
</file>

<file path="templates/entity/components/entity-form.tsx.ejs">
<%#
 Copyright 2013-2025 the original author or authors from the JHipster project.
-%>
"use client";

import { useState, useEffect } from "react";
import * as React from "react";
import { useRouter } from "next/navigation";
import { zodResolver } from "@hookform/resolvers/zod";
import { useForm } from "react-hook-form";
import { z } from "zod";
import { CalendarIcon, Save, ArrowLeft, ArrowRight, Check, ChevronRight } from "lucide-react";
import { toast } from "sonner";
import { <%= entityInstance %>Toast, handle<%= entityClass %>Error } from "./<%= entityFileName %>-toast";
import { Button } from "@/components/ui/button";
import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import {
  Form,
  FormControl,
  FormDescription,
  FormField,
  FormItem,
  FormLabel,
  FormMessage,
} from "@/components/ui/form";
import { Input } from "@/components/ui/input";
import { Textarea } from "@/components/ui/textarea";
import { Checkbox } from "@/components/ui/checkbox";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { Calendar } from "@/components/ui/calendar";
import {
  Popover,
  PopoverContent,
  PopoverTrigger,
} from "@/components/ui/popover";
import { Progress } from "@/components/ui/progress";
import { Badge } from "@/components/ui/badge";
import { format } from "date-fns";
import { cn } from "@/lib/utils";
<%_ if (persistableRelationships.length > 0) { _%>
import { PaginatedRelationshipCombobox } from "./paginated-relationship-combobox";
<%_ } _%>

import { 
  useCreate<%= entityClass %>,
  useUpdate<%= entityClass %>,
  useGet<%= entityClass %>,
} from "@/core/api/generated/spring/endpoints/<%= entityFileName %>-resource/<%= entityFileName %>-resource.gen";
<%_ 
// Helper function to convert camelCase to Title Case
function camelToTitleCase(str) {
  return str
    .replace(/([A-Z])/g, ' $1')
    .replace(/^./, str => str.toUpperCase())
    .trim();
}

// Organize fields by category
const basicFields = fields.filter(field => !field.id && !field.fieldTypeBinary);
const textFields = basicFields.filter(field => 
  !field.fieldTypeBoolean && !field.fieldTypeTimed && !field.fieldTypeLocalDate && 
  !field.fieldIsEnum && !field.fieldTypeNumeric
);
const numberFields = basicFields.filter(field => field.fieldTypeNumeric);
const dateFields = basicFields.filter(field => field.fieldTypeTimed || field.fieldTypeLocalDate);
const enumFields = basicFields.filter(field => field.fieldIsEnum);
const booleanFields = basicFields.filter(field => field.fieldTypeBoolean);
const binaryFields = fields.filter(field => field.fieldTypeBinary);

// Enhanced relationship dependency detection using actual JHipster relationship definitions
function buildRelationshipDependencyMap(relationships) {
  const dependencyMap = new Map();
  const reverseMap = new Map(); // child -> parent mapping
  
  // Build dependency map from JHipster relationship definitions
  relationships.forEach(rel => {
    const relName = rel.relationshipName;
    const otherEntityName = rel.otherEntityName.toLowerCase();
    
    // Look for parent relationships in other entities
    relationships.forEach(otherRel => {
      const otherRelName = otherRel.relationshipName;
      const otherRelEntityName = otherRel.otherEntityName.toLowerCase();
      
      // Case 1: Direct parent-child relationship via otherEntityRelationshipName
      if (rel.otherEntityRelationshipName && 
          otherRel.relationshipName === rel.otherEntityRelationshipName &&
          rel.relationshipType === 'many-to-one' &&
          otherRel.relationshipType === 'one-to-many') {
        reverseMap.set(relName, otherRelName);
      }
      
      // Case 2: Geographic hierarchy patterns (state->district->city->area)
      const geoHierarchy = [
        { child: 'district', parent: 'state' },
        { child: 'city', parent: 'district' },
        { child: 'area', parent: 'city' }
      ];
      
      geoHierarchy.forEach(({ child, parent }) => {
        if (relName.toLowerCase().includes(child) && otherRelName.toLowerCase().includes(parent)) {
          reverseMap.set(relName, otherRelName);
        }
      });
      
      // Case 3: Type hierarchy (callType -> subCallType)
      if (relName.toLowerCase().includes('sub') && 
          relName.toLowerCase().includes('type') &&
          otherRelName.toLowerCase().includes('type') &&
          !otherRelName.toLowerCase().includes('sub') &&
          otherRelEntityName.includes(otherEntityName.replace('sub', ''))) {
        reverseMap.set(relName, otherRelName);
      }
    });
  });
  
  return reverseMap;
}

// Build cascading filter map for relationships
function buildCascadingFilters(relationships) {
  const dependencyMap = buildRelationshipDependencyMap(relationships);
  const cascadingFilters = new Map();
  
  // For each child relationship, store its parent for filtering
  dependencyMap.forEach((parentRel, childRel) => {
    cascadingFilters.set(childRel, {
      parentField: parentRel,
      filterField: 'callType' // This would be determined by the actual entity relationship
    });
  });
  
  return cascadingFilters;
}

// Intelligent relationship grouping with dependency detection
const geographicKeywords = ['state', 'district', 'city', 'area', 'country', 'region', 'location'];
const userKeywords = ['user', 'assignedTo', 'createdBy', 'updatedBy', 'channelParty', 'owner'];
const classificationKeywords = ['priority', 'status', 'type', 'category', 'level', 'grade'];
const businessKeywords = ['party', 'customer', 'supplier', 'vendor', 'product', 'source', 'channel'];

function categorizeRelationship(rel) {
  const name = rel.relationshipName.toLowerCase();
  const otherEntity = rel.otherEntityName.toLowerCase();
  
  if (geographicKeywords.some(kw => name.includes(kw) || otherEntity.includes(kw))) {
    return 'geographic';
  }
  if (userKeywords.some(kw => name.includes(kw) || otherEntity.includes(kw)) || rel.otherEntity.builtInUser) {
    return 'user';
  }
  if (classificationKeywords.some(kw => name.includes(kw) || otherEntity.includes(kw))) {
    return 'classification';
  }
  if (businessKeywords.some(kw => name.includes(kw) || otherEntity.includes(kw))) {
    return 'business';
  }
  return 'other';
}

// Enhanced function to sort relationships by dependencies with circular dependency protection
function sortRelationshipsByDependency(relationships) {
  const dependencyMap = buildRelationshipDependencyMap(relationships);
  const sorted = [];
  const processed = new Set();
  const visiting = new Set();
  
  function addRelationship(rel) {
    const relName = rel.relationshipName;
    
    if (processed.has(relName)) return;
    
    // Circular dependency detection
    if (visiting.has(relName)) {
      console.warn(`Circular dependency detected for ${relName}, breaking cycle`);
      return;
    }
    
    visiting.add(relName);
    
    // Add parent first if it exists and hasn't been processed
    const parentRelName = dependencyMap.get(relName);
    if (parentRelName) {
      const parentRel = relationships.find(r => r.relationshipName === parentRelName);
      if (parentRel && !processed.has(parentRelName)) {
        addRelationship(parentRel);
      }
    }
    
    visiting.delete(relName);
    
    if (!processed.has(relName)) {
      sorted.push(rel);
      processed.add(relName);
    }
  }
  
  // Add all relationships, dependencies will be resolved automatically
  relationships.forEach(addRelationship);
  
  return sorted;
}

// Group relationships by category
const relationshipGroups = {
  geographic: persistableRelationships.filter(rel => categorizeRelationship(rel) === 'geographic'),
  user: persistableRelationships.filter(rel => categorizeRelationship(rel) === 'user'),
  classification: persistableRelationships.filter(rel => categorizeRelationship(rel) === 'classification'),
  business: persistableRelationships.filter(rel => categorizeRelationship(rel) === 'business'),
  other: persistableRelationships.filter(rel => categorizeRelationship(rel) === 'other')
};

// Sort each group by dependencies
Object.keys(relationshipGroups).forEach(key => {
  relationshipGroups[key] = sortRelationshipsByDependency(relationshipGroups[key]);
});

// Build cascading filters for intelligent form behavior
const cascadingFilters = buildCascadingFilters(persistableRelationships);

// Legacy variables for template compatibility
const hasUserRelationships = relationshipGroups.user.length > 0;

// Define wizard steps dynamically based on available fields
const steps = [
  ...(textFields.length > 0 || numberFields.length > 0 || enumFields.length > 0 ? [{ id: 'basic', title: 'Basic Information', description: 'Enter essential details' }] : []),
  ...(dateFields.length > 0 ? [{ id: 'dates', title: 'Date & Time', description: 'Set relevant dates' }] : []),
  ...(booleanFields.length > 0 || binaryFields.length > 0 ? [{ id: 'settings', title: 'Settings & Files', description: 'Configure options' }] : []),
  ...(relationshipGroups.geographic.length > 0 ? [{ id: 'geographic', title: 'Location Details', description: 'Select geographic information' }] : []),
  ...(relationshipGroups.user.length > 0 ? [{ id: 'users', title: 'People & Assignment', description: 'Assign users and responsibilities' }] : []),
  ...(relationshipGroups.classification.length > 0 ? [{ id: 'classification', title: 'Classification', description: 'Set priority, status, and categories' }] : []),
  ...(relationshipGroups.business.length > 0 ? [{ id: 'business', title: 'Business Relations', description: 'Connect with customers and products' }] : []),
  ...(relationshipGroups.other.length > 0 ? [{ id: 'other', title: 'Additional Relations', description: 'Other connections and references' }] : []),
  { id: 'review', title: 'Review', description: 'Confirm your details' }
];
_%>
<%_ for (const otherEntity of otherEntitiesWithPersistableRelationship.filter(e => !e.builtInUser)) { _%>
import { 
  useGetAll<%= otherEntity.entityClassPlural %>,
  useSearch<%= otherEntity.entityClassPlural %>,
  useCount<%= otherEntity.entityClassPlural %>
} from "@/core/api/generated/spring/endpoints/<%= otherEntity.entityFileName %>-resource/<%= otherEntity.entityFileName %>-resource.gen";
<%_ } _%>
<%_ if (otherEntitiesWithPersistableRelationship.some(e => e.builtInUser)) { _%>
import { 
  useGetAllPublicUsers,
  useSearchPublicUsers
} from "@/core/api/generated/spring/endpoints/public-user-resource/public-user-resource.gen";
<%_ } _%>
import type { <%= entityClass %>DTO } from "@/core/api/generated/spring/schemas/<%= entityClass %>DTO";
<%_ if (hasUserRelationships) { _%>
import type { UserDTO } from "@/core/api/generated/spring/schemas/UserDTO";
<%_ } _%>

interface <%= entityClass %>FormProps {
  id?: number;
}

// Create Zod schema for form validation
const formSchema = z.object({
<%_ for (field of fields.filter(field => !field.id)) { 
    const fieldName = field.fieldName;
    const fieldValidateRules = field.fieldValidateRules || [];
    const isRequired = fieldValidateRules.includes('required');
_%>
  <%= fieldName %>: <% if (field.fieldTypeBoolean) { %>z.boolean()<% } else if (field.fieldTypeNumeric) { %>z.string()<% if (fieldValidateRules.includes('min')) { %>.refine(val => !val || Number(val) >= <%= field.fieldValidateRulesMin %>, { message: "Must be at least <%= field.fieldValidateRulesMin %>" })<% } %><% if (fieldValidateRules.includes('max')) { %>.refine(val => !val || Number(val) <= <%= field.fieldValidateRulesMax %>, { message: "Must be at most <%= field.fieldValidateRulesMax %>" })<% } %><% } else if (field.fieldTypeTimed || field.fieldTypeLocalDate) { %>z.date()<% } else if (field.fieldIsEnum) { %>z.string()<% if (!isRequired) { %>.transform(val => val === "__none__" ? undefined : val)<% } %><% } else { %>z.string()<% if (fieldValidateRules.includes('minlength')) { %>.min(<%= field.fieldValidateRulesMinlength %>)<% } %><% if (fieldValidateRules.includes('maxlength')) { %>.max(<%= field.fieldValidateRulesMaxlength %>)<% } %><% if (fieldValidateRules.includes('pattern')) { %>.regex(/<%= field.fieldValidateRulesPattern %>/)<% } %><% } %><% if (!isRequired) { %>.optional()<% } %>,
<%_ } _%>
<%_ for (const rel of persistableRelationships) { 
    const relationshipFieldName = rel.relationshipFieldName;
    const relationshipRequired = rel.relationshipRequired;
    const relationshipType = rel.otherEntity.builtInUser ? 'string' : 'number';
_%>
  <%= relationshipFieldName %>: z.<% if (rel.collection) { %>array(z.<%= relationshipType %>())<% } else { %><%= relationshipType %>()<% } %><% if (!relationshipRequired) { %>.optional()<% } %>,
<%_ } _%>
});

const STEPS = <%= JSON.stringify(steps) %>;

export function <%= entityClass %>Form({ id }: <%= entityClass %>FormProps) {
  const router = useRouter();
  const isNew = !id;
  const [currentStep, setCurrentStep] = useState(0);
  const [confirmSubmission, setConfirmSubmission] = useState(false);
  const [isRestoring, setIsRestoring] = useState(false);
  const [restorationAttempted, setRestorationAttempted] = useState(false);
  const [formSessionId] = useState(() => {
    // Generate unique session ID for this form instance
    const existingSession = sessionStorage.getItem('<%= entityClass %>_FormSession');
    if (existingSession && isNew) {
      return existingSession;
    }
    const newSessionId = `${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    if (isNew) {
      sessionStorage.setItem('<%= entityClass %>_FormSession', newSessionId);
    }
    return newSessionId;
  });

  // Create or update mutation
  const { mutate: createEntity, isPending: isCreating } = useCreate<%= entityClass %>({
    mutation: {
      onSuccess: (data) => {
        // Clean up form state completely
        cleanupFormState();
        
        const returnUrl = localStorage.getItem('returnUrl');
        const relationshipInfo = localStorage.getItem('relationshipFieldInfo');
        
        if (returnUrl && relationshipInfo) {
          const entityId = data?.id || data?.<%= primaryKey.name %>;
          if (entityId) {
            localStorage.setItem('newlyCreatedEntityId', entityId.toString());
          }
          <%= entityInstance %>Toast.created();
          router.push(returnUrl);
        } else {
          <%= entityInstance %>Toast.created();
          router.push("/<%= entityRoute %>");
        }
      },
      onError: (error) => {
        handle<%= entityClass %>Error(error);
      },
    },
  });

  const { mutate: updateEntity, isPending: isUpdating } = useUpdate<%= entityClass %>({
    mutation: {
      onSuccess: () => {
        // Clean up form state completely
        cleanupFormState();
        
        <%= entityInstance %>Toast.updated();
        router.push("/<%= entityRoute %>");
      },
      onError: (error) => {
        handle<%= entityClass %>Error(error);
      },
    },
  });

  // Fetch entity for editing
  const { data: entity, isLoading: isLoadingEntity } = useGet<%= entityClass %>(id || 0, {
    query: {
      enabled: !!id,
      queryKey: ["get-<%= entityFileName %>", id]
    },
  });

  // Form initialization
  const form = useForm<z.infer<typeof formSchema>>({
    resolver: zodResolver(formSchema),
    mode: "onChange",
    defaultValues: {
<%_ for (field of fields.filter(field => !field.id)) { 
    const fieldName = field.fieldName;
_%>
<% if (field.fieldTypeBoolean) { %>
      <%= fieldName %>: false,
<% } else if (field.fieldTypeNumeric) { %>
      <%= fieldName %>: "",
<% } else if (field.fieldTypeTimed || field.fieldTypeLocalDate) { %>
      <%= fieldName %>: new Date(),
<% } else if (field.fieldIsEnum) { %>
      <%= fieldName %>: <% if (!field.fieldValidateRules?.includes('required')) { %>undefined<% } else { %>"<%= field.enumValues[0].name %>"<% } %>,
<% } else { %>
      <%= fieldName %>: "",
<% } %>
<%_ } _%>
<%_ for (const rel of persistableRelationships) { 
    const relationshipFieldName = rel.relationshipFieldName;
_%>
<% if (rel.collection) { %>
      <%= relationshipFieldName %>: [],
<% } else { %>
      <%= relationshipFieldName %>: undefined,
<% } %>
<%_ } _%>
    },
  });

  // Form state persistence functions
  const saveFormState = React.useCallback(() => {
    if (!isNew) return; // Don't save state for edit forms
    
    const formData = form.getValues();
    const formState = {
      data: formData,
      currentStep,
      timestamp: Date.now(),
      entity: '<%= entityClass %>',
      sessionId: formSessionId
    };
    
    const storageKey = `<%= entityClass %>FormState_${formSessionId}`;
    localStorage.setItem(storageKey, JSON.stringify(formState));
    console.log('Form state saved with session:', { storageKey, sessionId: formSessionId });
  }, [form, currentStep, isNew, formSessionId]);

  const restoreFormState = React.useCallback(() => {
    if (!isNew) return false; // Don't restore for edit forms
    
    // Check if this is a cross-entity creation (coming from another form)
    const entityCreationContext = localStorage.getItem('entityCreationContext');
    if (entityCreationContext) {
      try {
        const context = JSON.parse(entityCreationContext);
        // If we're creating this entity from another entity's form, don't restore
        if (context.sourceEntity && context.sourceEntity !== '<%= entityClass %>') {
          console.log('Cross-entity creation detected, skipping restoration');
          return false;
        }
      } catch (error) {
        console.error('Error parsing entity creation context:', error);
      }
    }
    
    const currentSessionId = sessionStorage.getItem('<%= entityClass %>_FormSession');
    if (!currentSessionId || currentSessionId !== formSessionId) {
      console.log('Session mismatch, skipping restoration');
      return false;
    }
    
    const storageKey = `<%= entityClass %>FormState_${formSessionId}`;
    const savedStateStr = localStorage.getItem(storageKey);
    
    if (savedStateStr) {
      try {
        const savedState = JSON.parse(savedStateStr);
        const isRecent = Date.now() - savedState.timestamp < 30 * 60 * 1000; // 30 minutes
        const isSameSession = savedState.sessionId === formSessionId;
        const isSameEntity = savedState.entity === '<%= entityClass %>';
        
        if (isRecent && isSameSession && isSameEntity) {
          setIsRestoring(true);
          
          // Restore form values
          Object.keys(savedState.data).forEach(key => {
            const value = savedState.data[key];
            if (value !== undefined && value !== null) {
              form.setValue(key as any, value);
            }
          });
          
          // Restore current step
          setCurrentStep(savedState.currentStep || 0);
          
          // Don't clear saved state immediately, let it be cleared on submission
          setTimeout(() => setIsRestoring(false), 100);
          <%= entityInstance %>Toast.formRestored();
          
          console.log('Form state restored for session:', formSessionId);
          return true;
        } else {
          console.log('Restoration conditions not met:', { isRecent, isSameSession, isSameEntity });
          localStorage.removeItem(storageKey);
        }
      } catch (error) {
        console.error('Failed to restore form state:', error);
        localStorage.removeItem(storageKey);
      }
    }
    return false;
  }, [form, isNew, formSessionId]);

  // Clear old form states for this entity type
  const clearOldFormStates = React.useCallback(() => {
    const keysToRemove: string[] = [];
    for (let i = 0; i < localStorage.length; i++) {
      const key = localStorage.key(i);
      if (key?.startsWith('<%= entityClass %>FormState_') && !key.endsWith(formSessionId)) {
        keysToRemove.push(key);
      }
    }
    keysToRemove.forEach(key => localStorage.removeItem(key));
    console.log('Cleared old form states:', keysToRemove);
  }, [formSessionId]);

  // Handle newly created relationship entities
  const handleEntityCreated = React.useCallback((entityId: number, relationshipName: string) => {
    const currentValue = form.getValues(relationshipName as any);
    
    if (Array.isArray(currentValue)) {
      const newValue = [...currentValue, entityId];
      form.setValue(relationshipName as any, newValue);
    } else {
      form.setValue(relationshipName as any, entityId);
    }
    
    form.trigger(relationshipName as any);
  }, [form]);

  // Form restoration and event listeners
  useEffect(() => {
    if (!restorationAttempted && isNew) {
      setRestorationAttempted(true);
      
      // Clear old form states first
      clearOldFormStates();
      
      // Check for newly created entity first
      const newEntityId = localStorage.getItem('newlyCreatedEntityId');
      const relationshipInfo = localStorage.getItem('relationshipFieldInfo');
      
      if (newEntityId && relationshipInfo) {
        try {
          const info = JSON.parse(relationshipInfo);
          console.log('Found newly created entity:', { newEntityId, info });
          
          // Restore form state first, then add the new entity
          const restored = restoreFormState();
          
          setTimeout(() => {
            handleEntityCreated(parseInt(newEntityId), Object.keys(info)[0] || 'id');
            
            // Clean up
            localStorage.removeItem('newlyCreatedEntityId');
            localStorage.removeItem('relationshipFieldInfo');
            localStorage.removeItem('returnUrl');
            localStorage.removeItem('entityCreationContext');
          }, restored ? 500 : 100);
          
        } catch (error) {
          console.error('Error processing newly created entity:', error);
          restoreFormState();
        }
      } else {
        // Just restore form state
        restoreFormState();
      }
    }

    // Listen for save form state events
    const handleSaveFormState = () => {
      if (isNew) {
        console.log('Save form state event received');
        saveFormState();
      }
    };

    window.addEventListener('saveFormState', handleSaveFormState);
    
    return () => {
      window.removeEventListener('saveFormState', handleSaveFormState);
    };
  }, [restorationAttempted, isNew, restoreFormState, saveFormState, handleEntityCreated, clearOldFormStates]);

  // Update form values when entity data is loaded
  useEffect(() => {
    if (entity && !isRestoring) {
      const formValues = {
<%_ for (field of fields.filter(field => !field.id)) { 
    const fieldName = field.fieldName;
_%>
<% if (field.fieldTypeTimed || field.fieldTypeLocalDate) { %>
        <%= fieldName %>: entity.<%= fieldName %> ? new Date(entity.<%= fieldName %>) : undefined,
<% } else if (field.fieldTypeNumeric) { %>
        <%= fieldName %>: entity.<%= fieldName %> != null ? String(entity.<%= fieldName %>) : "",
<% } else { %>
        <%= fieldName %>: entity.<%= fieldName %> || "",
<% } %>
<%_ } _%>
<%_ for (const rel of persistableRelationships) { 
    const relationshipFieldName = rel.relationshipFieldName;
    const otherEntityPkName = rel.otherEntity.builtInUser ? 'id' : (rel.otherEntity.primaryKey?.name || 'id');
_%>
<% if (rel.collection) { %>
        <%= relationshipFieldName %>: entity.<%= relationshipFieldName %>?.map(item => item.<%= otherEntityPkName %>),
<% } else { %>
        <%= relationshipFieldName %>: entity.<%= relationshipFieldName %>?.<%= otherEntityPkName %>,
<% } %>
<%_ } _%>
      };
      form.reset(formValues);
    }
  }, [entity, form, isRestoring]);

  // Auto-save form state on field changes (debounced)
  useEffect(() => {
    if (!isNew || isRestoring) return;
    
    const subscription = form.watch(() => {
      const timeoutId = setTimeout(() => {
        saveFormState();
      }, 2000); // Auto-save every 2 seconds after changes
      
      return () => clearTimeout(timeoutId);
    });
    
    return () => subscription.unsubscribe();
  }, [form, isRestoring, isNew, saveFormState]);
  const onSubmit = async (data: z.infer<typeof formSchema>) => {
    if (currentStep !== STEPS.length - 1) return;

    const entityToSave = {
      ...(!isNew && entity ? { id: entity.id } : {}),
<%_ for (field of fields.filter(field => !field.id)) { 
    const fieldName = field.fieldName;
_%>
<% if (field.fieldTypeNumeric) { %>
      <%= fieldName %>: data.<%= fieldName %> ? Number(data.<%= fieldName %>) : undefined,
<% } else { %>
      <%= fieldName %>: data.<%= fieldName %> === "__none__" ? undefined : data.<%= fieldName %>,
<% } %>
<%_ } _%>
<%_ for (const rel of persistableRelationships) { 
    const relationshipFieldName = rel.relationshipFieldName;
    const otherEntityPkName = rel.otherEntity.builtInUser ? 'id' : (rel.otherEntity.primaryKey?.name || 'id');
_%>
<% if (rel.collection) { %>
      <%= relationshipFieldName %>: data.<%= relationshipFieldName %>?.map(id => ({ <%= otherEntityPkName %>: id })),
<% } else { %>
      <%= relationshipFieldName %>: data.<%= relationshipFieldName %> ? { <%= otherEntityPkName %>: data.<%= relationshipFieldName %> } : null,
<% } %>
<%_ } _%>
      ...(entity && !isNew ? {
        ...Object.keys(entity).reduce((acc, key) => {
          const isFormField = [<%_ for (field of fields.filter(field => !field.id)) { _%>'<%= field.fieldName %>',<%_ } _%><%_ for (const rel of persistableRelationships) { _%>'<%= rel.relationshipFieldName %>',<%_ } _%>].includes(key);
          if (!isFormField && entity[key as keyof typeof entity] !== undefined) {
            acc[key] = entity[key as keyof typeof entity];
          }
          return acc;
        }, {} as any)
      } : {})
    } as <%= entityClass %>DTO;

    if (isNew) {
      createEntity({ data: entityToSave });
    } else if (id) {
      updateEntity({ id, data: entityToSave });
    }
  };

  // Form cleanup function
  const cleanupFormState = React.useCallback(() => {
    const storageKey = `<%= entityClass %>FormState_${formSessionId}`;
    localStorage.removeItem(storageKey);
    sessionStorage.removeItem('<%= entityClass %>_FormSession');
    
    // Clear all old form states for this entity type
    const keysToRemove: string[] = [];
    for (let i = 0; i < localStorage.length; i++) {
      const key = localStorage.key(i);
      if (key?.startsWith('<%= entityClass %>FormState_')) {
        keysToRemove.push(key);
      }
    }
    keysToRemove.forEach(key => localStorage.removeItem(key));
    
    // Reset form to default values
    form.reset();
    setCurrentStep(0);
    setConfirmSubmission(false);
    
    console.log('Form state cleaned up completely');
  }, [formSessionId, form]);

  // Navigation functions
  const handleCancel = () => {
    cleanupFormState();
    
    const returnUrl = localStorage.getItem('returnUrl');
    const backRoute = returnUrl || "/<%= entityRoute %>";
    
    // Clean up navigation localStorage
    localStorage.removeItem('entityCreationContext');
    localStorage.removeItem('referrerInfo');
    localStorage.removeItem('returnUrl');
    
    router.push(backRoute);
  };

  const validateStep = async () => {
    const currentStepId = STEPS[currentStep].id;
    let fieldsToValidate: string[] = [];

    switch (currentStepId) {
      case 'basic':
        fieldsToValidate = [<%_ for (field of [...textFields, ...numberFields, ...enumFields]) { _%>'<%= field.fieldName %>',<%_ } _%>];
        break;
      case 'dates':
        fieldsToValidate = [<%_ for (field of dateFields) { _%>'<%= field.fieldName %>',<%_ } _%>];
        break;
      case 'settings':
        fieldsToValidate = [<%_ for (field of [...booleanFields, ...binaryFields]) { _%>'<%= field.fieldName %>',<%_ } _%>];
        break;
      case 'geographic':
        fieldsToValidate = [<%_ 
        if (relationshipGroups.geographic) {
          for (const rel of relationshipGroups.geographic) { _%>'<%= rel.relationshipFieldName %>',<%_ }
        } _%>];
        break;
      case 'users':
        fieldsToValidate = [<%_ 
        if (relationshipGroups.user) {
          for (const rel of relationshipGroups.user) { _%>'<%= rel.relationshipFieldName %>',<%_ }
        } _%>];
        break;
      case 'classification':
        fieldsToValidate = [<%_ 
        if (relationshipGroups.classification) {
          for (const rel of relationshipGroups.classification) { _%>'<%= rel.relationshipFieldName %>',<%_ }
        } _%>];
        break;
      case 'business':
        fieldsToValidate = [<%_ 
        if (relationshipGroups.business) {
          for (const rel of relationshipGroups.business) { _%>'<%= rel.relationshipFieldName %>',<%_ }
        } _%>];
        break;
      case 'other':
        fieldsToValidate = [<%_ 
        if (relationshipGroups.other) {
          for (const rel of relationshipGroups.other) { _%>'<%= rel.relationshipFieldName %>',<%_ }
        } _%>];
        break;
    }

    const result = await form.trigger(fieldsToValidate);
    return result;
  };

  const nextStep = async () => {
    const isValid = await validateStep();
    if (isValid && currentStep < STEPS.length - 1) {
      setCurrentStep(currentStep + 1);
    }
  };

  const prevStep = () => {
    if (currentStep > 0) {
      setCurrentStep(currentStep - 1);
      if (currentStep === STEPS.length - 1) {
        setConfirmSubmission(false);
      }
    }
  };

  const progress = ((currentStep + 1) / STEPS.length) * 100;

  if (id && isLoadingEntity) {
    return (
      <div className="flex items-center justify-center h-64">
        <div className="text-lg">Loading...</div>
      </div>
    );
  }

  return (
    <div className="w-full space-y-6">
      {/* Progress Bar */}
      <div className="space-y-4">
        <div className="flex justify-between text-sm font-medium">
          <span>Step {currentStep + 1} of {STEPS.length}</span>
          <span>{Math.round(progress)}% Complete</span>
        </div>
        <Progress value={progress} className="h-2" />
      </div>

      {/* Step Indicators */}
      <div className="flex justify-center">
        <div className="flex items-center space-x-2 sm:space-x-4 overflow-x-auto">
          {STEPS.map((step, index) => (
            <div key={step.id} className="flex items-center">
              <div className={cn(
                "flex items-center justify-center w-8 h-8 sm:w-10 sm:h-10 rounded-full border-2 transition-all flex-shrink-0",
                index < currentStep 
                  ? "bg-primary border-primary text-primary-foreground" 
                  : index === currentStep 
                  ? "border-primary text-primary bg-primary/10" 
                  : "border-muted-foreground/30 text-muted-foreground"
              )}>
                {index < currentStep ? (
                  <Check className="w-4 h-4 sm:w-5 sm:h-5" />
                ) : (
                  <span className="text-xs sm:text-sm font-medium">{index + 1}</span>
                )}
              </div>
              {index < STEPS.length - 1 && (
                <ChevronRight className="w-3 h-3 sm:w-4 sm:h-4 text-muted-foreground mx-1 sm:mx-2 flex-shrink-0" />
              )}
            </div>
          ))}
        </div>
      </div>

      {/* Current Step Info */}
      <div className="text-center space-y-1">
        <h2 className="text-lg sm:text-xl font-semibold">{STEPS[currentStep].title}</h2>
        <p className="text-sm text-muted-foreground">{STEPS[currentStep].description}</p>
      </div>

      {/* Form Content */}
      <Form {...form}>
        <form onSubmit={form.handleSubmit(onSubmit)} className="space-y-6">
          <Card>
            <CardContent className="p-4 sm:p-6">
              {/* Step 1: Basic Information */}
              {STEPS[currentStep].id === 'basic' && (
                <div className="space-y-6">
                  <div className="grid grid-cols-1 md:grid-cols-2 xl:grid-cols-3 gap-4 sm:gap-6">
                    <% for (field of [...textFields, ...numberFields, ...enumFields]) { 
                      const fieldName = field.fieldName;
                      const fieldLabel = camelToTitleCase(fieldName);
                      const fieldValidateRules = field.fieldValidateRules || [];
                      const isRequired = fieldValidateRules.includes('required');
                    %>
                    <FormField
                      control={form.control}
                      name="<%= fieldName %>"
                      render={({ field }) => (
                        <% if (field.fieldIsEnum) { %>
                        <FormItem>
                          <FormLabel className="text-sm font-medium"><%= fieldLabel %><% if (isRequired) { %> *<% } %></FormLabel>
                          <Select onValueChange={field.onChange} defaultValue={field.value}>
                            <FormControl>
                              <SelectTrigger>
                                <SelectValue placeholder="Select <%= fieldLabel.toLowerCase() %>" />
                              </SelectTrigger>
                            </FormControl>
                            <SelectContent>
                              <% if (!isRequired) { %>
                              <SelectItem value="__none__">None</SelectItem>
                              <% } %>
                              <% for (const enumValue of field.enumValues || []) { %>
                              <SelectItem value="<%= enumValue.name || enumValue.value || 'EMPTY_VALUE' %>">
                                <%= enumValue.name || enumValue.value || 'Empty' %>
                              </SelectItem>
                              <% } %>
                            </SelectContent>
                          </Select>
                          <FormMessage />
                        </FormItem>
                        <% } else { %>
                        <FormItem>
                          <FormLabel className="text-sm font-medium"><%= fieldLabel %><% if (isRequired) { %> *<% } %></FormLabel>
                          <FormControl>
                            <Input 
                              {...field}
                              <% if (field.fieldTypeNumeric) { %>type="number"<% } %>
                              placeholder="Enter <%= fieldLabel.toLowerCase() %>"
                              className="transition-colors"
                            />
                          </FormControl>
                          <FormMessage />
                        </FormItem>
                        <% } %>
                      )}
                    />
                    <% } %>
                  </div>
                </div>
              )}

              {/* Step 2: Date & Time */}
              <% if (dateFields.length > 0) { %>
              {STEPS[currentStep].id === 'dates' && (
                <div className="space-y-6">
                  <div className="grid grid-cols-1 md:grid-cols-2 xl:grid-cols-3 gap-4 sm:gap-6">
                    <% for (field of dateFields) { 
                      const fieldName = field.fieldName;
                      const fieldLabel = camelToTitleCase(fieldName);
                      const fieldValidateRules = field.fieldValidateRules || [];
                      const isRequired = fieldValidateRules.includes('required');
                    %>
                    <FormField
                      control={form.control}
                      name="<%= fieldName %>"
                      render={({ field }) => (
                        <FormItem className="flex flex-col">
                          <FormLabel className="text-sm font-medium"><%= fieldLabel %><% if (isRequired) { %> *<% } %></FormLabel>
                          <Popover>
                            <PopoverTrigger asChild>
                              <FormControl>
                                <Button
                                  variant="outline"
                                  className={cn(
                                    "w-full pl-3 text-left font-normal",
                                    !field.value && "text-muted-foreground"
                                  )}
                                >
                                  {field.value ? format(field.value, "PPP") : <span>Select date</span>}
                                  <CalendarIcon className="ml-auto h-4 w-4 opacity-50" />
                                </Button>
                              </FormControl>
                            </PopoverTrigger>
                            <PopoverContent className="w-auto p-0" align="start">
                              <Calendar
                                mode="single"
                                selected={field.value}
                                onSelect={field.onChange}
                                initialFocus
                              />
                            </PopoverContent>
                          </Popover>
                          <FormMessage />
                        </FormItem>
                      )}
                    />
                    <% } %>
                  </div>
                </div>
              )}
              <% } %>

              {/* Step 3: Settings & Files */}
              <% if (booleanFields.length > 0 || binaryFields.length > 0) { %>
              {STEPS[currentStep].id === 'settings' && (
                <div className="space-y-6">
                  <% if (booleanFields.length > 0) { %>
                  <div className="space-y-4">
                    <h4 className="font-medium">Settings</h4>
                    <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                      <% for (field of booleanFields) { 
                        const fieldName = field.fieldName;
                        const fieldLabel = camelToTitleCase(fieldName);
                      %>
                      <FormField
                        control={form.control}
                        name="<%= fieldName %>"
                        render={({ field }) => (
                          <FormItem className="flex flex-row items-center justify-between rounded-lg border p-4">
                            <div className="space-y-0.5">
                              <FormLabel className="text-base font-medium"><%= fieldLabel %></FormLabel>
                            </div>
                            <FormControl>
                              <Checkbox checked={field.value} onCheckedChange={field.onChange} />
                            </FormControl>
                          </FormItem>
                        )}
                      />
                      <% } %>
                    </div>
                  </div>
                  <% } %>

                  <% if (binaryFields.length > 0) { %>
                  <div className="space-y-4">
                    <h4 className="font-medium">Files & Additional Information</h4>
                    <div className="grid grid-cols-1 gap-4">
                      <% for (field of binaryFields) { 
                        const fieldName = field.fieldName;
                        const fieldLabel = camelToTitleCase(fieldName);
                        const fieldValidateRules = field.fieldValidateRules || [];
                        const isRequired = fieldValidateRules.includes('required');
                      %>
                      <FormField
                        control={form.control}
                        name="<%= fieldName %>"
                        render={({ field }) => (
                          <FormItem>
                            <FormLabel className="text-sm font-medium"><%= fieldLabel %><% if (isRequired) { %> *<% } %></FormLabel>
                            <FormControl>
                              <% if (field.fieldTypeBinary && (field.blobContentTypeText || field.fieldType === 'TextBlob')) { %>
                              <Textarea
                                {...field}
                                placeholder="Enter <%= fieldLabel.toLowerCase() %>"
                                className="min-h-[100px]"
                              />
                              <% } else { %>
                              <Input
                                type="file"
                                <% if (field.blobContentTypeImage) { %>accept="image/*"<% } %>
                                onChange={(e) => {
                                  const file = e.target.files?.[0];
                                  if (file) {
                                    const reader = new FileReader();
                                    reader.onload = (event) => {
                                      if (event.target?.result) {
                                        const base64 = event.target.result.toString().split(',')[1];
                                        field.onChange(base64);
                                      }
                                    };
                                    reader.readAsDataURL(file);
                                  }
                                }}
                              />
                              <% } %>
                            </FormControl>
                            <FormMessage />
                          </FormItem>
                        )}
                      />
                      <% } %>
                    </div>
                  </div>
                  <% } %>
                </div>
              )}
              <% } %>

              {/* Classification Step with Intelligent Cascading */}
              <%_ if (relationshipGroups.classification && relationshipGroups.classification.length > 0) { _%>
              {STEPS[currentStep].id === 'classification' && (
                <div className="space-y-6">
                  <div className="text-center mb-6">
                    <h3 className="text-lg font-medium">Classification</h3>
                    <p className="text-muted-foreground">Set priority, status, and categories</p>
                  </div>
                  <div className="grid grid-cols-1 md:grid-cols-2 xl:grid-cols-3 gap-4 sm:gap-6">
                    <%_ for (const rel of relationshipGroups.classification) { 
                      const relationshipFieldName = rel.relationshipFieldName;
                      const relationshipLabel = camelToTitleCase(rel.relationshipName);
                      const relationshipRequired = rel.relationshipRequired;
                      const otherEntity = rel.otherEntity;
                      const displayField = rel.otherEntityField;
                      
                      // Check if this relationship has a parent for cascading
                      const hasParentFilter = cascadingFilters.has(rel.relationshipName);
                      const parentFieldName = hasParentFilter ? cascadingFilters.get(rel.relationshipName).parentField : null;
                      
                      // Special handling for subCallType -> callType relationship
                      const isSubCallType = rel.relationshipName.toLowerCase().includes('subcalltype');
                      const callTypeField = isSubCallType ? 'callType' : null;
                    _%>
                    <FormField
                      control={form.control}
                      name="<%= relationshipFieldName %>"
                      render={({ field }) => (
                        <FormItem>
                          <FormLabel className="text-sm font-medium">
                            <%= relationshipLabel %><% if (relationshipRequired) { %> *<% } %>
                          </FormLabel>
                          <FormControl>
                            <PaginatedRelationshipCombobox
                              value={field.value}
                              onValueChange={(value) => {
                                field.onChange(value);
                                <%_ if (isSubCallType) { _%>
                                // Clear subCallType when callType changes
                                if ('<%= relationshipFieldName %>' === 'callType') {
                                  form.setValue('subCallType', undefined);
                                }
                                <%_ } _%>
                              }}
                              displayField="<%= displayField %>"
                              placeholder="Select <%= relationshipLabel.toLowerCase() %>"
                              multiple={<%= rel.collection %>}
                              useGetAllHook={useGetAll<%= otherEntity.entityClassPlural %>}
                              useSearchHook={useSearch<%= otherEntity.entityClassPlural %>}
                              useCountHook={useCount<%= otherEntity.entityClassPlural %>}
                              entityName="<%= otherEntity.entityClassPlural %>"
                              searchField="<%= displayField %>"
                              canCreate={true}
                              createEntityPath="/<%= otherEntity.routePath %>/new"
                              createPermission="<%= otherEntity.entityInstance || otherEntity.entityName.toLowerCase() %>:create"
                              onEntityCreated={(entityId) => handleEntityCreated(entityId, '<%= relationshipFieldName %>')}
                              <%_ if (isSubCallType && callTypeField) { _%>
                              parentFilter={form.watch('<%= callTypeField %>')}
                              parentField="<%= callTypeField %>"
                              disabled={!form.watch('<%= callTypeField %>')}
                              <%_ } _%>
                            />
                          </FormControl>
                          <FormMessage />
                        </FormItem>
                      )}
                    />
                    <%_ } _%>
                  </div>
                </div>
              )}
              <%_ } _%>

              {/* Geographic Step with Cascading */}
              <%_ if (relationshipGroups.geographic && relationshipGroups.geographic.length > 0) { _%>
              {STEPS[currentStep].id === 'geographic' && (
                <div className="space-y-6">
                  <div className="text-center mb-6">
                    <h3 className="text-lg font-medium">Location Information</h3>
                    <p className="text-muted-foreground">Select location details in hierarchical order</p>
                  </div>
                  <div className="grid grid-cols-1 md:grid-cols-2 xl:grid-cols-4 gap-4 sm:gap-6">
                    <%_ 
                    // Manually define geographic order for proper cascading
                    const geoOrder = ['state', 'district', 'city', 'area'];
                    const sortedGeoRels = relationshipGroups.geographic.sort((a, b) => {
                      const aIndex = geoOrder.findIndex(geo => a.relationshipName.toLowerCase().includes(geo));
                      const bIndex = geoOrder.findIndex(geo => b.relationshipName.toLowerCase().includes(geo));
                      return (aIndex === -1 ? 999 : aIndex) - (bIndex === -1 ? 999 : bIndex);
                    });
                    
                    for (let i = 0; i < sortedGeoRels.length; i++) {
                      const rel = sortedGeoRels[i];
                      const relationshipFieldName = rel.relationshipFieldName;
                      const relationshipLabel = camelToTitleCase(rel.relationshipName);
                      const relationshipRequired = rel.relationshipRequired;
                      const otherEntity = rel.otherEntity;
                      const displayField = rel.otherEntityField;
                      
                      const parentRel = i > 0 ? sortedGeoRels[i - 1] : null;
                      const parentFieldName = parentRel ? parentRel.relationshipFieldName : null;
                    _%>
                    <FormField
                      control={form.control}
                      name="<%= relationshipFieldName %>"
                      render={({ field }) => (
                        <FormItem>
                          <FormLabel className="text-sm font-medium">
                            <%= relationshipLabel %><% if (relationshipRequired) { %> *<% } %>
                          </FormLabel>
                          <FormControl>
                            <PaginatedRelationshipCombobox
                              value={field.value}
                              onValueChange={(value) => {
                                field.onChange(value);
                                // Clear dependent geographic selections
                                <%_ for (let j = i + 1; j < sortedGeoRels.length; j++) { 
                                  const dependentRel = sortedGeoRels[j];
                                _%>
                                form.setValue('<%= dependentRel.relationshipFieldName %>', undefined);
                                <%_ } _%>
                              }}
                              displayField="<%= displayField %>"
                              placeholder="Select <%= relationshipLabel.toLowerCase() %>"
                              multiple={<%= rel.collection %>}
                              useGetAllHook={useGetAll<%= otherEntity.entityClassPlural %>}
                              useSearchHook={useSearch<%= otherEntity.entityClassPlural %>}
                              useCountHook={useCount<%= otherEntity.entityClassPlural %>}
                              entityName="<%= otherEntity.entityClassPlural %>"
                              searchField="<%= displayField %>"
                              canCreate={true}
                              createEntityPath="/<%= otherEntity.routePath %>/new"
                              createPermission="<%= otherEntity.entityInstance || otherEntity.entityName.toLowerCase() %>:create"
                              onEntityCreated={(entityId) => handleEntityCreated(entityId, '<%= relationshipFieldName %>')}
                              <%_ if (parentFieldName) { _%>
                              parentFilter={form.watch('<%= parentFieldName %>')}
                              parentField="<%= parentFieldName %>"
                              disabled={!form.watch('<%= parentFieldName %>')}
                              <%_ } _%>
                            />
                          </FormControl>
                          <FormMessage />
                        </FormItem>
                      )}
                    />
                    <%_ } _%>
                  </div>
                </div>
              )}
              <%_ } _%>

              {/* User Assignment Step */}
              <%_ if (relationshipGroups.user && relationshipGroups.user.length > 0) { _%>
              {STEPS[currentStep].id === 'users' && (
                <div className="space-y-6">
                  <div className="text-center mb-6">
                    <h3 className="text-lg font-medium">People & Assignment</h3>
                    <p className="text-muted-foreground">Assign users and responsibilities</p>
                  </div>
                  <div className="grid grid-cols-1 md:grid-cols-2 xl:grid-cols-3 gap-4 sm:gap-6">
                    <%_ for (const rel of relationshipGroups.user) { 
                      const relationshipFieldName = rel.relationshipFieldName;
                      const relationshipLabel = camelToTitleCase(rel.relationshipName);
                      const relationshipRequired = rel.relationshipRequired;
                      const otherEntity = rel.otherEntity;
                      const displayField = otherEntity.builtInUser ? 'login' : rel.otherEntityField;
                    _%>
                    <FormField
                      control={form.control}
                      name="<%= relationshipFieldName %>"
                      render={({ field }) => (
                        <FormItem>
                          <FormLabel className="text-sm font-medium">
                            <%= relationshipLabel %><% if (relationshipRequired) { %> *<% } %>
                          </FormLabel>
                          <FormControl>
                            <%_ if (otherEntity.builtInUser) { _%>
                            <PaginatedRelationshipCombobox
                              value={field.value}
                              onValueChange={field.onChange}
                              displayField="<%= displayField %>"
                              placeholder="Select <%= relationshipLabel.toLowerCase() %>"
                              multiple={<%= rel.collection %>}
                              useGetAllHook={useGetAllPublicUsers}
                              useSearchHook={useSearchPublicUsers}
                              entityName="PublicUsers"
                              searchField="<%= displayField %>"
                              canCreate={false}
                              createEntityPath=""
                              createPermission=""
                              onEntityCreated={(entityId) => handleEntityCreated(entityId, '<%= relationshipFieldName %>')}
                            />
                            <%_ } else { _%>
                            <PaginatedRelationshipCombobox
                              value={field.value}
                              onValueChange={field.onChange}
                              displayField="<%= displayField %>"
                              placeholder="Select <%= relationshipLabel.toLowerCase() %>"
                              multiple={<%= rel.collection %>}
                              useGetAllHook={useGetAll<%= otherEntity.entityClassPlural %>}
                              useSearchHook={useSearch<%= otherEntity.entityClassPlural %>}
                              useCountHook={useCount<%= otherEntity.entityClassPlural %>}
                              entityName="<%= otherEntity.entityClassPlural %>"
                              searchField="<%= displayField %>"
                              canCreate={true}
                              createEntityPath="/<%= otherEntity.routePath %>/new"
                              createPermission="<%= otherEntity.entityInstance || otherEntity.entityName.toLowerCase() %>:create"
                              onEntityCreated={(entityId) => handleEntityCreated(entityId, '<%= relationshipFieldName %>')}
                            />
                            <%_ } _%>
                          </FormControl>
                          <FormMessage />
                        </FormItem>
                      )}
                    />
                    <%_ } _%>
                  </div>
                </div>
              )}
              <%_ } _%>

              {/* Business Relations Step */}
              <%_ if (relationshipGroups.business && relationshipGroups.business.length > 0) { _%>
              {STEPS[currentStep].id === 'business' && (
                <div className="space-y-6">
                  <div className="text-center mb-6">
                    <h3 className="text-lg font-medium">Business Relations</h3>
                    <p className="text-muted-foreground">Connect with customers, products, and sources</p>
                  </div>
                  <div className="grid grid-cols-1 md:grid-cols-2 gap-4 sm:gap-6">
                    <%_ for (const rel of relationshipGroups.business) { 
                      const relationshipFieldName = rel.relationshipFieldName;
                      const relationshipLabel = camelToTitleCase(rel.relationshipName);
                      const relationshipRequired = rel.relationshipRequired;
                      const otherEntity = rel.otherEntity;
                      const displayField = rel.otherEntityField;
                    _%>
                    <FormField
                      control={form.control}
                      name="<%= relationshipFieldName %>"
                      render={({ field }) => (
                        <FormItem>
                          <FormLabel className="text-sm font-medium">
                            <%= relationshipLabel %><% if (relationshipRequired) { %> *<% } %>
                          </FormLabel>
                          <FormControl>
                            <PaginatedRelationshipCombobox
                              value={field.value}
                              onValueChange={field.onChange}
                              displayField="<%= displayField %>"
                              placeholder="Select <%= relationshipLabel.toLowerCase() %>"
                              multiple={<%= rel.collection %>}
                              useGetAllHook={useGetAll<%= otherEntity.entityClassPlural %>}
                              useSearchHook={useSearch<%= otherEntity.entityClassPlural %>}
                              useCountHook={useCount<%= otherEntity.entityClassPlural %>}
                              entityName="<%= otherEntity.entityClassPlural %>"
                              searchField="<%= displayField %>"
                              canCreate={true}
                              createEntityPath="/<%= otherEntity.routePath %>/new"
                              createPermission="<%= otherEntity.entityInstance || otherEntity.entityName.toLowerCase() %>:create"
                              onEntityCreated={(entityId) => handleEntityCreated(entityId, '<%= relationshipFieldName %>')}
                            />
                          </FormControl>
                          <FormMessage />
                        </FormItem>
                      )}
                    />
                    <%_ } _%>
                  </div>
                </div>
              )}
              <%_ } _%>

              {/* Other Relations Step */}
              <%_ if (relationshipGroups.other && relationshipGroups.other.length > 0) { _%>
              {STEPS[currentStep].id === 'other' && (
                <div className="space-y-6">
                  <div className="text-center mb-6">
                    <h3 className="text-lg font-medium">Additional Relations</h3>
                    <p className="text-muted-foreground">Other connections and references</p>
                  </div>
                  <div className="grid grid-cols-1 md:grid-cols-2 gap-4 sm:gap-6">
                    <%_ for (const rel of relationshipGroups.other) { 
                      const relationshipFieldName = rel.relationshipFieldName;
                      const relationshipLabel = camelToTitleCase(rel.relationshipName);
                      const relationshipRequired = rel.relationshipRequired;
                      const otherEntity = rel.otherEntity;
                      const displayField = rel.otherEntityField;
                    _%>
                    <FormField
                      control={form.control}
                      name="<%= relationshipFieldName %>"
                      render={({ field }) => (
                        <FormItem>
                          <FormLabel className="text-sm font-medium">
                            <%= relationshipLabel %><% if (relationshipRequired) { %> *<% } %>
                          </FormLabel>
                          <FormControl>
                            <PaginatedRelationshipCombobox
                              value={field.value}
                              onValueChange={field.onChange}
                              displayField="<%= displayField %>"
                              placeholder="Select <%= relationshipLabel.toLowerCase() %>"
                              multiple={<%= rel.collection %>}
                              useGetAllHook={useGetAll<%= otherEntity.entityClassPlural %>}
                              useSearchHook={useSearch<%= otherEntity.entityClassPlural %>}
                              useCountHook={useCount<%= otherEntity.entityClassPlural %>}
                              entityName="<%= otherEntity.entityClassPlural %>"
                              searchField="<%= displayField %>"
                              canCreate={true}
                              createEntityPath="/<%= otherEntity.routePath %>/new"
                              createPermission="<%= otherEntity.entityInstance || otherEntity.entityName.toLowerCase() %>:create"
                              onEntityCreated={(entityId) => handleEntityCreated(entityId, '<%= relationshipFieldName %>')}
                            />
                          </FormControl>
                          <FormMessage />
                        </FormItem>
                      )}
                    />
                    <%_ } _%>
                  </div>
                </div>
              )}
              <%_ } _%>

              {/* Review Step */}
              {STEPS[currentStep].id === 'review' && (
                <div className="space-y-6">
                  <div className="text-center">
                    <h3 className="text-lg font-medium mb-2">Review Your Information</h3>
                    <p className="text-muted-foreground">Please review all the information before submitting</p>
                  </div>
                  
                  {/* Basic Fields Review */}
                  <%_ if (fields.filter(field => !field.id).length > 0) { _%>
                  <div className="space-y-4">
                    <h4 className="font-medium text-lg border-b pb-2">Basic Information</h4>
                    <div className="grid grid-cols-1 md:grid-cols-2 xl:grid-cols-3 gap-6">
                      <%_ for (field of fields.filter(field => !field.id)) { 
                        const fieldName = field.fieldName;
                        const fieldLabel = camelToTitleCase(fieldName);
                      _%>
                      <div className="space-y-1">
                        <dt className="text-sm font-medium text-muted-foreground"><%= fieldLabel %></dt>
                        <dd className="text-sm">
                          <%_ if (field.fieldTypeBoolean) { _%>
                          <Badge variant={form.watch('<%= fieldName %>') ? "default" : "secondary"}>
                            {form.watch('<%= fieldName %>') ? "Yes" : "No"}
                          </Badge>
                          <%_ } else if (field.fieldTypeTimed || field.fieldTypeLocalDate) { _%>
                          {form.watch('<%= fieldName %>') ? format(form.watch('<%= fieldName %>'), "PPP") : "‚Äî"}
                          <%_ } else if (field.fieldIsEnum) { _%>
                          <Badge variant="outline">{form.watch('<%= fieldName %>') || "‚Äî"}</Badge>
                          <%_ } else { _%>
                          {form.watch('<%= fieldName %>') || "‚Äî"}
                          <%_ } _%>
                        </dd>
                      </div>
                      <%_ } _%>
                    </div>
                  </div>
                  <%_ } _%>

                  {/* Relationship Reviews */}
                  <%_ ['classification', 'geographic', 'user', 'business', 'other'].forEach(groupName => { 
                    if (relationshipGroups[groupName] && relationshipGroups[groupName].length > 0) { 
                      const groupIcon = {
                        classification: 'üè∑Ô∏è',
                        geographic: 'üìç',
                        user: 'üë•',
                        business: 'üè¢',
                        other: 'üîó'
                      }[groupName];
                      const groupTitle = {
                        classification: 'Classification',
                        geographic: 'Location Details',
                        user: 'People & Assignment',
                        business: 'Business Relations',
                        other: 'Additional Relations'
                      }[groupName];
                  _%>
                  <div className="space-y-4">
                    <h4 className="font-medium text-lg border-b pb-2"><%= groupIcon %> <%= groupTitle %></h4>
                    <div className="grid grid-cols-1 md:grid-cols-2 xl:grid-cols-3 gap-6">
                      <%_ for (const rel of relationshipGroups[groupName]) { 
                        const relationshipFieldName = rel.relationshipFieldName;
                        const relationshipLabel = camelToTitleCase(rel.relationshipName);
                      _%>
                      <div className="space-y-1">
                        <dt className="text-sm font-medium text-muted-foreground"><%= relationshipLabel %></dt>
                        <dd className="text-sm">
                          <Badge variant="outline">
                            <%_ if (rel.collection) { _%>
                            {Array.isArray(form.watch('<%= relationshipFieldName %>')) ? 
                              `${form.watch('<%= relationshipFieldName %>').length} selected` : 'None selected'}
                            <%_ } else { _%>
                            {form.watch('<%= relationshipFieldName %>') ? 'Selected' : 'Not selected'}
                            <%_ } _%>
                          </Badge>
                        </dd>
                      </div>
                      <%_ } _%>
                    </div>
                  </div>
                  <%_ } 
                  }); _%>
                </div>
              )}
            </CardContent>
          </Card>

          {/* Navigation Buttons */}
          <div className="flex flex-col sm:flex-row gap-3 sm:justify-between">
            <Button
              type="button"
              variant="outline"
              onClick={currentStep === 0 ? handleCancel : prevStep}
              className="flex items-center gap-2 justify-center"
            >
              <ArrowLeft className="h-4 w-4" />
              {currentStep === 0 ? "Cancel" : "Previous"}
            </Button>

            {currentStep === STEPS.length - 1 ? (
              !confirmSubmission ? (
                <Button 
                  type="button"
                  onClick={() => setConfirmSubmission(true)}
                  className="flex items-center gap-2 bg-orange-600 hover:bg-orange-700 justify-center"
                >
                  <Check className="h-4 w-4" />
                  Confirm {isNew ? "Create" : "Update"}
                </Button>
              ) : (
                <Button 
                  type="submit" 
                  disabled={isCreating || isUpdating}
                  className="flex items-center gap-2 bg-green-600 hover:bg-green-700 justify-center"
                >
                  <Save className="h-4 w-4" />
                  {isCreating || isUpdating ? "Submitting..." : `${isNew ? "Create" : "Update"} <%= entityClassHumanized %>`}
                </Button>
              )
            ) : (
              <Button
                type="button"
                onClick={nextStep}
                className="flex items-center gap-2 justify-center"
              >
                Next Step
                <ArrowRight className="h-4 w-4" />
              </Button>
            )}
          </div>
        </form>
      </Form>
    </div>
  );
}
</file>

<file path="templates/entity/components/entity-table.tsx.ejs">
<%#
 Copyright 2013-2025 the original author or authors from the JHipster project.
-%>
<%
// Define table relationships once at the top to avoid redeclaration
const displayableRelationships = relationships.filter(rel => 
  rel.relationshipType !== 'one-to-many' && 
  !rel.collection && 
  rel.otherEntityField
);

// Organize fields by type for better filter organization
const enumFields = fields.filter(f => f.fieldIsEnum);
const booleanFields = fields.filter(f => f.fieldTypeBoolean);
const dateFields = fields.filter(f => f.fieldTypeLocalDate || f.fieldTypeTimed);
const textFields = fields.filter(f => !f.fieldIsEnum && !f.fieldTypeBoolean && !f.fieldTypeLocalDate && !f.fieldTypeTimed && !f.fieldTypeBinary);
%>
"use client";

import { useState } from "react";
import { toast } from "sonner";
import { <%= entityInstance %>Toast, handle<%= entityClass %>Error } from "./<%= entityFileName %>-toast";
import { Search, X } from "lucide-react";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import {
  Table,
  TableBody,
  TableCell,
  TableRow,
} from "@/components/ui/table";
import { 
  Pagination, 
  PaginationContent, 
  PaginationItem, 
  PaginationLink, 
  PaginationNext, 
  PaginationPrevious 
} from "@/components/ui/pagination";
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
} from "@/components/ui/alert-dialog";

import {
  useGetAll<%= entityClassPlural %>,
  useDelete<%= entityClass %>,
  useCount<%= entityClassPlural %>,
  usePartialUpdate<%= entityClass %>,
  <% if (searchEngineAny) { %>useSearch<%= entityClassPlural %>,<% } %>
} from "@/core/api/generated/spring/endpoints/<%= entityFileName %>-resource/<%= entityFileName %>-resource.gen";

<% 
// Generate imports for relationship data fetching
const relationshipImports = [];
displayableRelationships.forEach(rel => {
  const otherEntityName = rel.otherEntityName;
  const otherEntityFileName = rel.otherEntity.entityFileName || otherEntityName.toLowerCase();
  const otherEntityClassPlural = rel.otherEntity.entityClassPlural || (otherEntityName + 's');
  
  // Handle built-in user entity
  if (rel.relationshipWithBuiltInEntity && otherEntityName === 'user') {
    relationshipImports.push(`useGetAllPublicUsers`);
  } else {
    relationshipImports.push(`useGetAll${otherEntityClassPlural}`);
  }
});

// Remove duplicates
const uniqueImports = [...new Set(relationshipImports)];
%>

<% if (uniqueImports.length > 0) { %>
// Relationship data imports
<% 
const importsByEntity = {};
const publicUserImports = [];

displayableRelationships.forEach(rel => {
  const otherEntityName = rel.otherEntityName;
  const otherEntityFileName = rel.otherEntity.entityFileName || otherEntityName.toLowerCase();
  const otherEntityClassPlural = rel.otherEntity.entityClassPlural || (otherEntityName + 's');
  
  // Handle built-in user entity separately
  if (rel.relationshipWithBuiltInEntity && otherEntityName === 'user') {
    publicUserImports.push(`useGetAllPublicUsers`);
  } else {
    if (!importsByEntity[otherEntityFileName]) {
      importsByEntity[otherEntityFileName] = [];
    }
    importsByEntity[otherEntityFileName].push(`useGetAll${otherEntityClassPlural}`);
  }
});

// Import public user resources if needed
if (publicUserImports.length > 0) {
  const uniquePublicUserImports = [...new Set(publicUserImports)];
%>
import {
  <%= uniquePublicUserImports.join(',\n  ') %>
} from "@/core/api/generated/spring/endpoints/public-user-resource/public-user-resource.gen";
<% } %>

<% 
// Import regular entity resources
Object.keys(importsByEntity).forEach(entityFileName => {
  const imports = [...new Set(importsByEntity[entityFileName])];
%>
import {
  <%= imports.join(',\n  ') %>
} from "@/core/api/generated/spring/endpoints/<%= entityFileName %>-resource/<%= entityFileName %>-resource.gen";
<% }); %>
<% } %>

import { <%= entityClass %>SearchAndFilters } from "./<%= entityFileName %>-search-filters";
import { <%= entityClass %>TableHeader } from "./<%= entityFileName %>-table-header";
import { <%= entityClass %>TableRow } from "./<%= entityFileName %>-table-row";
import { BulkRelationshipAssignment } from "./bulk-relationship-assignment";

// Define sort ordering constants
const ASC = "asc";
const DESC = "desc";

interface FilterState {
  [key: string]: string | string[] | Date | undefined;
}

interface DateRange {
  from: Date | undefined;
  to: Date | undefined;
}

export function <%= entityClass %>Table() {
  const [page, setPage] = useState(1);
  const [sort, setSort] = useState("<%= primaryKey.name %>");
  const [order, setOrder] = useState(ASC);
  const [searchTerm, setSearchTerm] = useState("");
  const [deleteId, setDeleteId] = useState<number | null>(null);
  const [showDeleteDialog, setShowDeleteDialog] = useState(false);
  const [filters, setFilters] = useState<FilterState>({});
  const [dateRange, setDateRange] = useState<DateRange>({ from: undefined, to: undefined });
  const [selectedRows, setSelectedRows] = useState<Set<number>>(new Set());
  const [showBulkDeleteDialog, setShowBulkDeleteDialog] = useState(false);
  const [showBulkRelationshipDialog, setShowBulkRelationshipDialog] = useState(false);

  // Calculate API pagination parameters (0-indexed)
  const apiPage = page - 1;
  const pageSize = 10;

  <% if (displayableRelationships.length > 0) { %>
  // Fetch relationship data for dropdowns
  <% 
  const fetchedEntities = new Set();
  displayableRelationships.forEach(rel => {
    const otherEntityName = rel.otherEntityName;
    const otherEntityFileName = rel.otherEntity.entityFileName || otherEntityName.toLowerCase();
    const otherEntityClassPlural = rel.otherEntity.entityClassPlural || (otherEntityName + 's');
    
    if (!fetchedEntities.has(otherEntityFileName)) {
      fetchedEntities.add(otherEntityFileName);
      
      if (rel.relationshipWithBuiltInEntity && otherEntityName === 'user') {
  %>
  const { data: <%= otherEntityName.toLowerCase() %>Options = [] } = useGetAllPublicUsers(
    { page: 0, size: 1000 },
    { query: { enabled: true } }
  );
  <% 
      } else {
  %>
  const { data: <%= otherEntityName.toLowerCase() %>Options = [] } = useGetAll<%= otherEntityClassPlural %>(
    { page: 0, size: 1000 },
    { query: { enabled: true } }
  );
  <% 
      }
    }
  });
  %>
  <% } %>

  // Helper function to find entity ID by name
  const findEntityIdByName = (entities: any[], name: string, displayField: string = 'name') => {
    const entity = entities?.find(e => e[displayField]?.toLowerCase().includes(name.toLowerCase()));
    return entity?.id;
  };

  // Build filter parameters for API
  const buildFilterParams = () => {
    const params: Record<string, any> = {};
    
    <% if (displayableRelationships.length > 0) { %>
    // Map relationship filters from name-based to ID-based
    const relationshipMappings = {
      <% displayableRelationships.forEach(rel => { 
        const displayField = rel.otherEntity.builtInUser ? 'login' : rel.otherEntityField;
        const optionsVar = rel.otherEntityName.toLowerCase() + 'Options';
      %>
      '<%= rel.relationshipName %>.<%= displayField %>': { 
        apiParam: '<%= rel.relationshipName %>Id.equals', 
        options: <%= optionsVar %>, 
        displayField: '<%= displayField %>' 
      },
      <% }); %>
    };
    <% } %>
    
    // Add filters
    Object.entries(filters).forEach(([key, value]) => {
      if (value !== undefined && value !== "" && value !== null) {
        <% if (displayableRelationships.length > 0) { %>
        // Handle relationship filters
        if (relationshipMappings[key]) {
          const mapping = relationshipMappings[key];
          const entityId = findEntityIdByName(mapping.options, value as string, mapping.displayField);
          if (entityId) {
            params[mapping.apiParam] = entityId;
          }
        }
        <% } %>
        <% booleanFields.forEach(field => { %>
        // Handle <%= field.fieldName %> boolean filter
        <% if (displayableRelationships.length > 0) { %>else <% } %>if (key === '<%= field.fieldName %>') {
          params['<%= field.fieldName %>.equals'] = value === 'true';
        }
        <% }); %>
        <% enumFields.forEach(field => { %>
        // Handle <%= field.fieldName %> enum filter
        <% if (displayableRelationships.length > 0 || booleanFields.length > 0) { %>else <% } %>if (key === '<%= field.fieldName %>') {
          params['<%= field.fieldName %>.equals'] = value;
        }
        <% }); %>
        <% dateFields.forEach(field => { %>
        // Handle <%= field.fieldName %> date filter
        <% if (displayableRelationships.length > 0 || booleanFields.length > 0 || enumFields.length > 0) { %>else <% } %>if (key === '<%= field.fieldName %>') {
          if (value instanceof Date) {
            params['<%= field.fieldName %>.equals'] = value.toISOString().split('T')[0];
          } else if (typeof value === 'string' && value.trim() !== '') {
            params['<%= field.fieldName %>.equals'] = value;
          }
        }
        <% }); %>
        <% textFields.forEach(field => { %>
        // Handle <%= field.fieldName %> text filter with contains
        <% if (displayableRelationships.length > 0 || booleanFields.length > 0 || enumFields.length > 0 || dateFields.length > 0) { %>else <% } %>if (key === '<%= field.fieldName %>') {
          if (typeof value === 'string' && value.trim() !== '') {
            params['<%= field.fieldName %>.contains'] = value;
          }
        }
        <% }); %>
        // Handle other filters
        <% if (displayableRelationships.length > 0 || booleanFields.length > 0 || enumFields.length > 0 || dateFields.length > 0 || textFields.length > 0) { %>else <% } %>if (Array.isArray(value) && value.length > 0) {
          // Handle array values (for multi-select filters)
          params[key] = value;
        } else if (typeof value === 'string' && value.trim() !== '') {
          // Fallback for unknown string fields - use contains
          params[`${key}.contains`] = value;
        }
      }
    });

    // Add date range filters
    <% dateFields.forEach(field => { %>
    if (dateRange.from) {
      params['<%= field.fieldName %>.greaterThanOrEqual'] = dateRange.from.toISOString();
    }
    if (dateRange.to) {
      params['<%= field.fieldName %>.lessThanOrEqual'] = dateRange.to.toISOString();
    }
    <% }); %>

    return params;
  };

  const filterParams = buildFilterParams();

  // Fetch data with React Query
  <% if (searchEngineAny) { %>
  const { data, isLoading, refetch } = searchTerm 
    ? useSearch<%= entityClassPlural %>(
        {
          query: searchTerm,
          page: apiPage,
          size: pageSize,
          sort: `${sort},${order}`,
          ...filterParams,
        },
        {
          query: {
            enabled: true,
          },
        }
      )
    : useGetAll<%= entityClassPlural %>(
        {
          page: apiPage,
          size: pageSize,
          sort: `${sort},${order}`,
          ...filterParams,
        },
        {
          query: {
            enabled: true,
          },
        }
      );
  <% } else { %>
  const { data, isLoading, refetch } = useGetAll<%= entityClassPlural %>(
    {
      page: apiPage,
      size: pageSize,
      sort: `${sort},${order}`,
      ...filterParams,
    },
    {
      query: {
        enabled: true,
      },
    }
  );
  <% } %>

  // Get total count for pagination
  const { data: countData } = useCount<%= entityClassPlural %>(
    filterParams,
    {
      query: {
        enabled: true,
      },
    }
  );

  // Partial update mutation for relationship editing
  const { mutate: updateEntity, isPending: isUpdating } = usePartialUpdate<%= entityClass %>({
    mutation: {
      onSuccess: () => {
        <%= entityInstance %>Toast.updated();
        refetch();
      },
      onError: (error) => {
        handle<%= entityClass %>Error(error);
        throw error;
      },
    },
  });

  // Delete mutation
  const { mutate: deleteEntity, isPending: isDeleting } = useDelete<%= entityClass %>({
    mutation: {
      onSuccess: () => {
        <%= entityInstance %>Toast.deleted();
        refetch();
      },
      onError: (error) => {
        handle<%= entityClass %>Error(error);
      },
    },
  });

  // Handle sort column click
  const handleSort = (column: string) => {
    if (sort === column) {
      setOrder(order === ASC ? DESC : ASC);
    } else {
      setSort(column);
      setOrder(ASC);
    }
  };

  // Get sort direction icon
  const getSortIcon = (column: string) => {
    if (sort !== column) {
      return "ChevronsUpDown";
    }
    return order === ASC ? "ChevronUp" : "ChevronDown";
  };

  // Handle delete
  const handleDelete = (id: number) => {
    setDeleteId(id);
    setShowDeleteDialog(true);
  };

  const confirmDelete = () => {
    if (deleteId) {
      deleteEntity({ id: deleteId });
    }
    setShowDeleteDialog(false);
  };

  // Handle filter change
  const handleFilterChange = (column: string, value: any) => {
    setFilters(prev => ({
      ...prev,
      [column]: value
    }));
    setPage(1);
  };

  // Clear all filters
  const clearAllFilters = () => {
    setFilters({});
    setSearchTerm("");
    setDateRange({ from: undefined, to: undefined });
    setPage(1);
  };

  <% if (searchEngineAny) { %>
  // Handle search
  const handleSearch = (e: React.ChangeEvent<HTMLInputElement>) => {
    setSearchTerm(e.target.value);
    setPage(1);
  };
  <% } %>

  // Calculate total pages
  const totalItems = countData || 0;
  const totalPages = Math.ceil(totalItems / pageSize);

  // Handle row selection
  const handleSelectRow = (id: number) => {
    const newSelected = new Set(selectedRows);
    if (newSelected.has(id)) {
      newSelected.delete(id);
    } else {
      newSelected.add(id);
    }
    setSelectedRows(newSelected);
  };

  // Handle select all
  const handleSelectAll = () => {
    if (data && selectedRows.size === data.length) {
      setSelectedRows(new Set());
    } else if (data) {
      setSelectedRows(new Set(data.map(item => item.<%= primaryKey.name %>)));
    }
  };

  // Handle bulk delete
  const handleBulkDelete = () => {
    setShowBulkDeleteDialog(true);
  };

  const confirmBulkDelete = async () => {
    const deletePromises = Array.from(selectedRows).map(id => 
      new Promise<void>((resolve, reject) => {
        deleteEntity({ id }, {
          onSuccess: () => resolve(),
          onError: (error) => reject(error)
        });
      })
    );

    try {
      await Promise.all(deletePromises);
      <%= entityInstance %>Toast.bulkDeleted(selectedRows.size);
      setSelectedRows(new Set());
      refetch();
    } catch (error) {
      <%= entityInstance %>Toast.bulkDeleteError();
    }
    setShowBulkDeleteDialog(false);
  };

  // Handle relationship updates
  const handleRelationshipUpdate = async (entityId: number, relationshipName: string, newValue: number | null) => {
    return new Promise<void>((resolve, reject) => {
      // For JHipster partial updates, need entity ID and relationship structure
      const updateData: any = {
        <%= primaryKey.name %>: entityId
      };
      
      if (newValue) {
        updateData[relationshipName] = { <%= primaryKey.name %>: newValue };
      } else {
        updateData[relationshipName] = null;
      }

      updateEntity({ 
        id: entityId,
        data: updateData
      }, {
        onSuccess: () => {
          <%= entityInstance %>Toast.relationshipUpdated(relationshipName);
          resolve();
        },
        onError: (error) => {
          handle<%= entityClass %>Error(error);
          reject(error);
        }
      });
    });
  };

  // Handle bulk relationship updates
  const handleBulkRelationshipUpdate = async (entityIds: number[], relationshipName: string, newValue: number | null) => {
    let successCount = 0;
    let errorCount = 0;
    
    // Process updates sequentially to avoid overwhelming the server
    for (const id of entityIds) {
      try {
        await handleRelationshipUpdate(id, relationshipName, newValue);
        successCount++;
      } catch (error) {
        console.error(`Failed to update entity ${id}:`, error);
        errorCount++;
      }
    }
    
    // Refresh data after updates
    refetch();
    
    // Throw error if all failed, otherwise consider it partially successful
    if (errorCount === entityIds.length) {
      throw new Error(`All ${errorCount} updates failed`);
    } else if (errorCount > 0) {
      console.warn(`${errorCount} out of ${entityIds.length} updates failed`);
    }
  };

  // Prepare relationship configurations for components
  const relationshipConfigs = [
    <% for (const rel of displayableRelationships) { 
      const otherEntityName = rel.otherEntityName;
      const displayField = rel.otherEntity.builtInUser ? 'login' : rel.otherEntityField;
    %>
    {
      name: "<%= rel.relationshipName %>",
      displayName: "<%= rel.relationshipName.charAt(0).toUpperCase() + rel.relationshipName.slice(1) %>",
      options: <%= otherEntityName.toLowerCase() %>Options || [],
      displayField: "<%= displayField %>",
      isEditable: false, // Disabled by default
    },
    <% } %>
  ];

  // Check if any filters are active
  const hasActiveFilters = Object.keys(filters).length > 0 || Boolean(searchTerm) || Boolean(dateRange.from) || Boolean(dateRange.to);
  const isAllSelected = data && data.length > 0 && selectedRows.size === data.length;
  const isIndeterminate = selectedRows.size > 0 && selectedRows.size < (data?.length || 0);

  return (
    <div className="space-y-4">
      {/* Bulk Actions */}
      {selectedRows.size > 0 && (
        <div className="flex items-center gap-3 p-3 bg-muted rounded-lg">
          <span className="text-sm text-muted-foreground">
            {selectedRows.size} item{selectedRows.size > 1 ? 's' : ''} selected
          </span>
          <div className="ml-auto flex gap-2">
            {relationshipConfigs.some(config => config.isEditable) && (
              <Button
                variant="outline"
                size="sm"
                onClick={() => setShowBulkRelationshipDialog(true)}
                className="gap-2"
              >
                Assign Associations
              </Button>
            )}
            <Button
              variant="destructive"
              size="sm"
              onClick={handleBulkDelete}
            >
              Delete Selected
            </Button>
          </div>
        </div>
      )}

      {/* Clear Filters Button */}
      {hasActiveFilters && (
        <div className="flex justify-end">
          <Button
            variant="ghost"
            size="sm"
            onClick={clearAllFilters}
            className="gap-2 text-muted-foreground hover:text-foreground"
          >
            <X className="h-4 w-4" />
            Clear All Filters
          </Button>
        </div>
      )}

      {/* Data Table */}
      <div className="overflow-x-auto rounded-md border">
        <Table className="min-w-full">
          <<%= entityClass %>TableHeader 
            onSort={handleSort}
            getSortIcon={getSortIcon}
            filters={filters}
            onFilterChange={handleFilterChange}
            isAllSelected={isAllSelected}
            isIndeterminate={isIndeterminate}
            onSelectAll={handleSelectAll}
          />
          <TableBody>
            {isLoading ? (
              <TableRow>
                <TableCell
                  colSpan={<%= fields.length + displayableRelationships.length + 1 %>}
                  className="h-24 text-center"
                >
                  Loading...
                </TableCell>
              </TableRow>
            ) : data?.length ? (
              data.map((<%= entityInstance %>) => (
                <<%= entityClass %>TableRow
                  key={<%= entityInstance %>.<%= primaryKey.name %>}
                  <%= entityInstance %>={<%= entityInstance %>}
                  onDelete={handleDelete}
                  isDeleting={isDeleting}
                  isSelected={selectedRows.has(<%= entityInstance %>.<%= primaryKey.name %> || 0)}
                  onSelect={handleSelectRow}
                  relationshipConfigs={relationshipConfigs}
                  onRelationshipUpdate={handleRelationshipUpdate}
                  isUpdating={isUpdating}
                />
              ))
            ) : (
              <TableRow>
                <TableCell
                  colSpan={<%= fields.length + displayableRelationships.length + 1 %>}
                  className="h-24 text-center"
                >
                  No <%= entityClassPluralHumanized.toLowerCase() %> found
                  {hasActiveFilters && (
                    <div className="text-sm text-muted-foreground mt-1">
                      Try adjusting your filters
                    </div>
                  )}
                </TableCell>
              </TableRow>
            )}
          </TableBody>
        </Table>
      </div>

      {/* Pagination */}
      {totalPages > 1 && (
        <Pagination>
          <PaginationContent>
            <PaginationItem>
              <PaginationPrevious
                href="#"
                onClick={(e) => {
                  e.preventDefault();
                  if (page > 1) setPage(page - 1);
                }}
                className={page <= 1 ? "pointer-events-none opacity-50" : ""}
              />
            </PaginationItem>
            {Array.from({ length: Math.min(5, totalPages) }, (_, i) => {
              const pageNumbers = [];
              const startPage = Math.max(1, page - 2);
              const endPage = Math.min(totalPages, startPage + 4);
              
              for (let j = startPage; j <= endPage; j++) {
                pageNumbers.push(j);
              }
              
              return pageNumbers[i];
            }).filter(Boolean).map((p) => (
              <PaginationItem key={p}>
                <PaginationLink
                  href="#"
                  onClick={(e) => {
                    e.preventDefault();
                    setPage(p);
                  }}
                  isActive={page === p}
                >
                  {p}
                </PaginationLink>
              </PaginationItem>
            ))}
            <PaginationItem>
              <PaginationNext
                href="#"
                onClick={(e) => {
                  e.preventDefault();
                  if (page < totalPages) setPage(page + 1);
                }}
                className={page >= totalPages ? "pointer-events-none opacity-50" : ""}
              />
            </PaginationItem>
          </PaginationContent>
        </Pagination>
      )}

      {/* Bulk Delete Dialog */}
      <AlertDialog open={showBulkDeleteDialog} onOpenChange={setShowBulkDeleteDialog}>
        <AlertDialogContent>
          <AlertDialogHeader>
            <AlertDialogTitle>Delete {selectedRows.size} item{selectedRows.size > 1 ? 's' : ''}?</AlertDialogTitle>
            <AlertDialogDescription>
              This action cannot be undone. This will permanently delete the
              selected <%= entityClassPluralHumanized.toLowerCase() %> and remove their data from the server.
            </AlertDialogDescription>
          </AlertDialogHeader>
          <AlertDialogFooter>
            <AlertDialogCancel>Cancel</AlertDialogCancel>
            <AlertDialogAction 
              onClick={confirmBulkDelete}
              className="bg-destructive text-destructive-foreground hover:bg-destructive/90"
            >
              Delete All
            </AlertDialogAction>
          </AlertDialogFooter>
        </AlertDialogContent>
      </AlertDialog>

      {/* Delete Dialog */}
      <AlertDialog open={showDeleteDialog} onOpenChange={setShowDeleteDialog}>
        <AlertDialogContent>
          <AlertDialogHeader>
            <AlertDialogTitle>Are you sure?</AlertDialogTitle>
            <AlertDialogDescription>
              This action cannot be undone. This will permanently delete the
              <%= entityClass.toLowerCase() %> and remove its data from the server.
            </AlertDialogDescription>
          </AlertDialogHeader>
          <AlertDialogFooter>
            <AlertDialogCancel>Cancel</AlertDialogCancel>
            <AlertDialogAction 
              onClick={confirmDelete}
              className="bg-destructive text-destructive-foreground hover:bg-destructive/90"
            >
              Delete
            </AlertDialogAction>
          </AlertDialogFooter>
        </AlertDialogContent>
      </AlertDialog>

      {/* Bulk Relationship Assignment Dialog */}
      <BulkRelationshipAssignment
        open={showBulkRelationshipDialog}
        onOpenChange={setShowBulkRelationshipDialog}
        selectedEntityIds={Array.from(selectedRows)}
        relationshipConfigs={relationshipConfigs}
        onBulkUpdate={handleBulkRelationshipUpdate}
      />
    </div>
  );
}
</file>

<file path="templates/entity/components/entity-toast.ts.ejs">
<%#
 Copyright 2013-2025 the original author or authors from the JHipster project.
-%>
import { toast } from "sonner";

// Toast notification utilities for <%= entityClass %>
export const <%= entityInstance %>Toast = {
  // Success messages
  created: (entityName?: string) => 
    toast.success("‚úÖ Success!", {
      description: `${entityName || '<%= entityClassHumanized %>'} created successfully`,
      action: {
        label: "View",
        onClick: () => window.location.href = "/<%= routePath %>"
      }
    }),
    
  updated: (entityName?: string) => 
    toast.success("‚úÖ Updated!", {
      description: `${entityName || '<%= entityClassHumanized %>'} updated successfully`,
      action: {
        label: "View All",
        onClick: () => window.location.href = "/<%= routePath %>"
      }
    }),
    
  deleted: (entityName?: string) => 
    toast.success("üóëÔ∏è Deleted!", {
      description: `${entityName || '<%= entityClassHumanized %>'} deleted successfully`
    }),
    
  bulkDeleted: (count: number) => 
    toast.success("üóëÔ∏è Bulk Delete!", {
      description: `${count} <%= entityClassPluralHumanized.toLowerCase() %> deleted successfully`
    }),
    
  relationshipUpdated: (relationshipName: string) => 
    toast.success("üîó Updated!", {
      description: `${relationshipName} updated successfully`
    }),
    
  exported: (format: string) => 
    toast.success("üì§ Exported!", {
      description: `<%= entityClassPluralHumanized %> exported to ${format} successfully`
    }),
    
  imported: (count: number) => 
    toast.success("üì• Imported!", {
      description: `${count} <%= entityClassPluralHumanized.toLowerCase() %> imported successfully`
    }),

  // Error messages
  createError: (error?: string) => 
    toast.error("‚ùå Creation Failed", {
      description: error || `Failed to create <%= entityClass.toLowerCase() %>. Please try again.`,
      action: {
        label: "Retry",
        onClick: () => window.location.reload()
      }
    }),
    
  updateError: (error?: string) => 
    toast.error("‚ùå Update Failed", {
      description: error || `Failed to update <%= entityClass.toLowerCase() %>. Please try again.`,
      action: {
        label: "Retry",
        onClick: () => window.location.reload()
      }
    }),
    
  deleteError: (error?: string) => 
    toast.error("‚ùå Delete Failed", {
      description: error || `Failed to delete <%= entityClass.toLowerCase() %>. Please try again.`
    }),
    
  bulkDeleteError: (error?: string) => 
    toast.error("‚ùå Bulk Delete Failed", {
      description: error || `Failed to delete selected <%= entityClassPluralHumanized.toLowerCase() %>. Please try again.`
    }),
    
  validationError: (fields?: string[]) => 
    toast.error("‚ö†Ô∏è Validation Error", {
      description: fields?.length ? 
        `Please check: ${fields.join(', ')}` : 
        "Please check your input and try again."
    }),
    
  permissionError: () => 
    toast.error("üö´ Permission Denied", {
      description: "You don't have permission to perform this action."
    }),
    
  networkError: () => 
    toast.error("üåê Network Error", {
      description: "Please check your internet connection and try again.",
      action: {
        label: "Retry",
        onClick: () => window.location.reload()
      }
    }),

  // Warning messages  
  unsavedChanges: () => 
    toast.warning("‚ö†Ô∏è Unsaved Changes", {
      description: "You have unsaved changes. Save or they will be lost.",
      duration: 6000
    }),
    
  formRestored: () => 
    toast.success("üîÑ Form Restored", {
      description: "Your previous form data has been restored."
    }),
    
  duplicateWarning: (field: string) => 
    toast.warning("‚ö†Ô∏è Duplicate Found", {
      description: `${field} already exists. Please use a different value.`
    }),

  // Info messages
  loading: (action: string) => 
    toast.loading(`${action}...`, {
      description: "Please wait while we process your request."
    }),
    
  processingBulk: (count: number, action: string) => 
    toast.loading(`${action} ${count} items...`, {
      description: "This may take a few moments."
    }),
    
  refreshing: () => 
    toast.loading("üîÑ Refreshing...", {
      description: "Updating data from server."
    }),

  // Custom actions
  custom: {
    success: (title: string, description: string, action?: { label: string; onClick: () => void }) => 
      toast.success(title, { description, action }),
      
    error: (title: string, description: string, action?: { label: string; onClick: () => void }) => 
      toast.error(title, { description, action }),
      
    warning: (title: string, description: string) => 
      toast.warning(title, { description }),
      
    info: (title: string, description: string) => 
      toast.info(title, { description })
  }
};

// Helper function to handle API errors with toast
export const handle<%= entityClass %>Error = (error: any) => {
  const errorMessage = error?.response?.data?.message || 
                      error?.message || 
                      'An unexpected error occurred';
  
  if (error?.response?.status === 403) {
    <%= entityInstance %>Toast.permissionError();
  } else if (error?.response?.status === 422) {
    const validationErrors = error?.response?.data?.fieldErrors;
    const fields = validationErrors ? Object.keys(validationErrors) : [];
    <%= entityInstance %>Toast.validationError(fields);
  } else if (error?.code === 'NETWORK_ERROR') {
    <%= entityInstance %>Toast.networkError();
  } else {
    toast.error("‚ùå Error", {
      description: errorMessage,
      action: {
        label: "Report",
        onClick: () => console.error('Error details:', error)
      }
    });
  }
};
</file>

<file path="templates/entity/components/paginated-relationship-combobox.tsx.ejs">
"use client";

import * as React from "react";
import { Check, ChevronsUpDown, X, Loader2, Plus } from "lucide-react";
import { cn } from "@/lib/utils";
import { Button } from "@/components/ui/button";
import {
  Command,
  CommandEmpty,
  CommandGroup,
  CommandInput,
  CommandItem,
  CommandList,
} from "@/components/ui/command";
import {
  Popover,
  PopoverContent,
  PopoverTrigger,
} from "@/components/ui/popover";
import { Badge } from "@/components/ui/badge";
import { InlinePermissionGuard } from "@/components/auth/permission-guard";

interface PaginatedRelationshipComboboxProps {
  value?: number | number[];
  onValueChange: (value: number | number[] | undefined) => void;
  displayField: string;
  placeholder?: string;
  multiple?: boolean;
  disabled?: boolean;
  className?: string;
  useGetAllHook: (params: any, options?: any) => any;
  useSearchHook?: (params: any, options?: any) => any;
  useCountHook?: (params: any, options?: any) => any;
  entityName: string;
  searchField?: string;
  canCreate?: boolean;
  createEntityPath?: string;
  createPermission?: string;
  onEntityCreated?: (entityId: number) => void;
  parentFilter?: number;
  parentField?: string;
}

export function PaginatedRelationshipCombobox({
  value,
  onValueChange,
  displayField = "name",
  placeholder = "Select option...",
  multiple = false,
  disabled = false,
  className,
  useGetAllHook,
  useSearchHook,
  useCountHook,
  entityName,
  searchField = "name",
  canCreate = false,
  createEntityPath,
  createPermission,
  onEntityCreated,
  parentFilter,
  parentField,
}: PaginatedRelationshipComboboxProps) {
  const [open, setOpen] = React.useState(false);
  const [searchQuery, setSearchQuery] = React.useState("");
  const [deferredSearchQuery, setDeferredSearchQuery] = React.useState("");
  const [currentPage, setCurrentPage] = React.useState(0);
  const [allLoadedData, setAllLoadedData] = React.useState<any[]>([]);
  const [hasMorePages, setHasMorePages] = React.useState(true);
  const pageSize = 20;

  // Debounced search query (300ms delay)
  React.useEffect(() => {
    const timer = setTimeout(() => {
      setDeferredSearchQuery(searchQuery);
    }, 300);
    return () => clearTimeout(timer);
  }, [searchQuery]);

  // Determine if query should be enabled
  const isQueryEnabled = React.useMemo(() => {
    if (disabled) return false;
    if (parentField && !parentFilter) return false;
    return true;
  }, [disabled, parentField, parentFilter]);

  // Build filter parameters for queries
  const buildFilterParams = React.useCallback((pageParam: number, searchTerm: string) => {
    const params = { 
      page: pageParam, 
      size: pageSize, 
      sort: `${displayField},asc`
    };
    
    // Apply parent filter if both parentField and parentFilter are provided
    if (parentFilter && parentField) {
      params[`${parentField}Id.equals`] = parentFilter;
    }
    
    // Add search filter using field contains
    if (searchTerm && searchTerm.trim() !== '') {
      params[`${searchField}.contains`] = searchTerm;
    }
    
    return params;
  }, [displayField, parentFilter, parentField, searchField, pageSize]);

  // Get current query parameters
  const currentParams = buildFilterParams(currentPage, deferredSearchQuery);

  // Always use getAll hook with field filters
  const { data: currentData, isLoading, isError } = useGetAllHook(
    currentParams,
    {
      query: {
        enabled: isQueryEnabled,
        keepPreviousData: false,
      }
    }
  );

  // Reset data when search or parent filter changes
  React.useEffect(() => {
    setCurrentPage(0);
    setAllLoadedData([]);
    setHasMorePages(true);
  }, [deferredSearchQuery, parentFilter]);

  // Handle data loading and pagination
  React.useEffect(() => {
    if (currentData && !isLoading && isQueryEnabled) {
      // Extract data array from response (handle both direct array and paginated response)
      const dataArray = Array.isArray(currentData) ? currentData : 
                       currentData.content ? currentData.content : 
                       currentData.data ? currentData.data : [];

      if (currentPage === 0) {
        // First page - replace all data
        setAllLoadedData(dataArray);
      } else {
        // Additional page - append unique items
        setAllLoadedData(prev => {
          const existingIds = new Set(prev.map(item => item.id));
          const newItems = dataArray.filter((item: any) => !existingIds.has(item.id));
          return [...prev, ...newItems];
        });
      }
      
      // Check if there are more pages
      setHasMorePages(dataArray.length === pageSize);
    }
  }, [currentData, isLoading, currentPage, isQueryEnabled]);

  // Load next page
  const loadNextPage = React.useCallback(() => {
    if (hasMorePages && !isLoading && isQueryEnabled) {
      setCurrentPage(prev => prev + 1);
    }
  }, [hasMorePages, isLoading, isQueryEnabled]);

  // Scroll handler for infinite loading
  const handleScroll = React.useCallback((e: React.UIEvent) => {
    const { scrollTop, scrollHeight, clientHeight } = e.currentTarget;
    const scrollPercentage = (scrollTop + clientHeight) / scrollHeight;
    
    // Load more when 80% scrolled and has more data
    if (scrollPercentage > 0.8 && hasMorePages && !isLoading) {
      loadNextPage();
    }
  }, [hasMorePages, isLoading, loadNextPage]);

  const handleSingleSelect = (optionId: number) => {
    const newValue = value === optionId ? undefined : optionId;
    onValueChange(newValue);
    setOpen(false);
  };

  const handleMultipleSelect = (optionId: number) => {
    const currentValues = Array.isArray(value) ? value : [];
    const newValues = currentValues.includes(optionId)
      ? currentValues.filter((id) => id !== optionId)
      : [...currentValues, optionId];
    
    onValueChange(newValues.length > 0 ? newValues : undefined);
  };

  const removeItem = (optionId: number) => {
    if (Array.isArray(value)) {
      const newValues = value.filter((id) => id !== optionId);
      onValueChange(newValues.length > 0 ? newValues : undefined);
    }
  };

  const getDisplayText = () => {
    if (multiple) {
      if (!Array.isArray(value) || value.length === 0) {
        return placeholder;
      }
      return `${value.length} item${value.length === 1 ? '' : 's'} selected`;
    } else {
      if (typeof value !== 'number') {
        return placeholder;
      }
      const selectedOption = allLoadedData.find((option: any) => option.id === value);
      return selectedOption ? selectedOption[displayField] : placeholder;
    }
  };

  const getSelectedOptions = () => {
    if (!multiple || !Array.isArray(value)) return [];
    return allLoadedData.filter((option: any) => value.includes(option.id));
  };

  const handleCreateNew = () => {
    if (createEntityPath) {
      const currentUrl = window.location.href;
      const currentPath = window.location.pathname;
      
      // Extract origin context dynamically
      const pathParts = currentPath.split('/').filter(Boolean);
      let originEntityName = 'Previous Page';
      let sourceEntityType = '';
      
      if (pathParts.length > 0) {
        const lastPart = pathParts[pathParts.length - 1];
        if (lastPart === 'new') {
          const originPart = pathParts[pathParts.length - 3];
          if (originPart) {
            sourceEntityType = originPart.replace(/-/g, '');
            originEntityName = originPart.replace(/-/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
          }
        } else {
          const originPart = pathParts[pathParts.length - 2];
          if (originPart) {
            sourceEntityType = originPart.replace(/-/g, '');
            originEntityName = originPart.replace(/-/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
          }
        }
      }
      
      // Convert sourceEntityType to proper entity class name (e.g., 'calls' -> 'Call')
      const sourceEntityClass = sourceEntityType.replace(/s$/, '').replace(/\b\w/g, l => l.toUpperCase());
      
      localStorage.setItem('returnUrl', currentUrl);
      localStorage.setItem('relationshipFieldInfo', JSON.stringify({
        entityName,
        displayField,
        multiple,
        timestamp: Date.now()
      }));
      
      localStorage.setItem('entityCreationContext', JSON.stringify({
        originRoute: currentPath,
        originEntityName,
        targetEntityName: entityName.replace(/s$/, ''),
        sourceEntity: sourceEntityClass,
        createdFrom: 'relationship'
      }));
      
      if (onEntityCreated) {
        const saveFormEvent = new CustomEvent('saveFormState');
        window.dispatchEvent(saveFormEvent);
      }
      
      setTimeout(() => {
        window.location.href = createEntityPath;
      }, 200);
    }
  };

  React.useEffect(() => {
    // Only run in browser environment
    if (typeof window === 'undefined') return;
    
    const newEntityId = sessionStorage.getItem('newlyCreatedEntityId');
    const relationshipInfo = sessionStorage.getItem('relationshipFieldInfo');
    
    if (newEntityId && relationshipInfo && onEntityCreated) {
      try {
        const info = JSON.parse(relationshipInfo);
        if (info.entityName === entityName) {
          onEntityCreated(parseInt(newEntityId));
          sessionStorage.removeItem('newlyCreatedEntityId');
          sessionStorage.removeItem('relationshipFieldInfo');
          sessionStorage.removeItem('returnUrl');
        }
      } catch (error) {
        console.error('Error processing newly created entity:', error);
      }
    }
  }, [entityName, onEntityCreated]);

  // Show disabled state message when parent filter is required but missing
  const getDisabledMessage = () => {
    if (parentField && !parentFilter) {
      return `Select ${parentField} first`;
    }
    return placeholder;
  };

  return (
    <div className={cn("w-full", className)}>
      <div className="flex gap-2">
        <div className="flex-1">
          <Popover open={open} onOpenChange={setOpen}>
            <PopoverTrigger asChild>
              <Button
                variant="outline"
                role="combobox"
                aria-expanded={open}
                className="w-full justify-between"
                disabled={disabled || !isQueryEnabled}
              >
                <span className="truncate">
                  {disabled || !isQueryEnabled ? getDisabledMessage() : getDisplayText()}
                </span>
                <ChevronsUpDown className="ml-2 h-4 w-4 shrink-0 opacity-50" />
              </Button>
            </PopoverTrigger>
            <PopoverContent className="w-full p-0" align="start">
              <Command shouldFilter={false}>
                <CommandInput 
                  placeholder={`Search ${entityName.toLowerCase()}...`}
                  value={searchQuery}
                  onValueChange={setSearchQuery}
                  disabled={!isQueryEnabled}
                />
                <CommandList 
                  className="max-h-60 overflow-y-auto"
                  onScroll={handleScroll}
                >
                  {!isQueryEnabled && (
                    <div className="flex items-center justify-center p-4 text-muted-foreground">
                      <span className="text-sm">
                        {parentField && !parentFilter ? `Please select ${parentField} first` : 'Search disabled'}
                      </span>
                    </div>
                  )}
                  
                  {isQueryEnabled && isLoading && allLoadedData.length === 0 && (
                    <div className="flex items-center justify-center p-4">
                      <Loader2 className="h-4 w-4 animate-spin" />
                      <span className="ml-2">Loading...</span>
                    </div>
                  )}
                  
                  {isQueryEnabled && !isLoading && allLoadedData.length === 0 && !isError && (
                    <CommandEmpty>
                      {deferredSearchQuery ? `No ${entityName.toLowerCase()} found for "${deferredSearchQuery}".` : `No ${entityName.toLowerCase()} found.`}
                    </CommandEmpty>
                  )}

                  {isError && (
                    <div className="flex items-center justify-center p-4 text-destructive">
                      <span className="text-sm">Error loading data. Please try again.</span>
                    </div>
                  )}
                  
                  {isQueryEnabled && allLoadedData.length > 0 && (
                    <CommandGroup>
                      {allLoadedData.map((option: any, index: number) => {
                        if (!option || !option.id || !option[displayField]) {
                          return null;
                        }
                        
                        const isSelected = multiple
                          ? Array.isArray(value) && value.includes(option.id)
                          : value === option.id;

                        const uniqueKey = `${entityName.toLowerCase()}-item-${option.id}-${index}`;
                        const uniqueValue = `item-${option.id}`;

                        return (
                          <CommandItem
                            key={uniqueKey}
                            value={uniqueValue}
                            onSelect={() => {
                              if (multiple) {
                                handleMultipleSelect(option.id);
                              } else {
                                handleSingleSelect(option.id);
                              }
                            }}
                          >
                            <Check
                              className={cn(
                                "mr-2 h-4 w-4",
                                isSelected ? "opacity-100" : "opacity-0"
                              )}
                            />
                            {option[displayField]}
                          </CommandItem>
                        );
                      })}
                      
                      {/* Loading indicator for infinite scroll */}
                      {isLoading && allLoadedData.length > 0 && (
                        <div className="flex items-center justify-center p-2">
                          <Loader2 className="h-3 w-3 animate-spin" />
                          <span className="ml-2 text-xs text-muted-foreground">Loading more...</span>
                        </div>
                      )}
                      
                      {/* End of results indicator */}
                      {!hasMorePages && allLoadedData.length > pageSize && (
                        <div className="flex items-center justify-center p-2">
                          <span className="text-xs text-muted-foreground">
                            All {allLoadedData.length} results loaded
                          </span>
                        </div>
                      )}
                    </CommandGroup>
                  )}
                </CommandList>
              </Command>
            </PopoverContent>
          </Popover>
        </div>
        
        {canCreate && createEntityPath && createPermission && (
          <InlinePermissionGuard requiredPermission={createPermission}>
            <Button
              type="button"
              variant="outline"
              size="icon"
              onClick={handleCreateNew}
              className="shrink-0"
              disabled={disabled}
              title={`Create new ${entityName.toLowerCase().slice(0, -1)}`}
            >
              <Plus className="h-4 w-4" />
            </Button>
          </InlinePermissionGuard>
        )}
      </div>

      {multiple && Array.isArray(value) && value.length > 0 && (
        <div className="mt-2 flex flex-wrap gap-1">
          {getSelectedOptions().map((option: any) => (
            <Badge key={option.id} variant="secondary" className="gap-1">
              {option[displayField]}
              <Button
                variant="ghost"
                size="sm"
                className="h-auto p-0 text-muted-foreground hover:text-foreground"
                onClick={() => removeItem(option.id)}
                type="button"
              >
                <X className="h-3 w-3" />
                <span className="sr-only">Remove</span>
              </Button>
            </Badge>
          ))}
        </div>
      )}
    </div>
  );
}
</file>

<file path="templates/entity/components/relationship-cell.tsx.ejs">
"use client";

import * as React from "react";
import Link from "next/link";
import { Check, ChevronDown, Loader2, ExternalLink } from "lucide-react";
import { cn } from "@/lib/utils";
import { Button } from "@/components/ui/button";
import {
  Command,
  CommandEmpty,
  CommandGroup,
  CommandInput,
  CommandItem,
  CommandList,
} from "@/components/ui/command";
import {
  Popover,
  PopoverContent,
  PopoverTrigger,
} from "@/components/ui/popover";
import {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from "@/components/ui/tooltip";
import { toast } from "sonner";
import { <%= entityInstance %>Toast } from "./<%= entityFileName %>-toast";

<%
// Get all the relationships that could be edited
const displayableRelationships = relationships.filter(rel => 
  rel.relationshipType !== 'one-to-many' && 
  !rel.collection && 
  rel.otherEntityField
);
%>

interface RelationshipCellProps {
  entityId: number;
  relationshipName: string;
  currentValue?: any;
  options: Array<{ id: number; [key: string]: any }>;
  displayField: string;
  onUpdate: (entityId: number, relationshipName: string, newValue: number | null) => Promise<void>;
  isEditable?: boolean;
  isLoading?: boolean;
  className?: string;
  // Add props for navigation
  relatedEntityRoute?: string; // The route to the related entity (e.g., 'call-types', 'sources')
  showNavigationIcon?: boolean;
}

export function RelationshipCell({
  entityId,
  relationshipName,
  currentValue,
  options = [],
  displayField = "name",
  onUpdate,
  isEditable = false,
  isLoading = false,
  className,
  relatedEntityRoute,
  showNavigationIcon = true,
}: RelationshipCellProps) {
  const [open, setOpen] = React.useState(false);
  const [updating, setUpdating] = React.useState(false);

  // Get current display value
  const getCurrentDisplayValue = () => {
    if (!currentValue) return "";
    
    if (typeof currentValue === 'object' && currentValue[displayField]) {
      return currentValue[displayField];
    }
    
    if (typeof currentValue === 'object' && currentValue.id) {
      const option = options.find(opt => opt.id === currentValue.id);
      return option ? option[displayField] : `ID: ${currentValue.id}`;
    }
    
    return currentValue.toString();
  };

  const currentDisplayValue = getCurrentDisplayValue();
  const currentId = currentValue?.id || currentValue;

  // Handle selection
  const handleSelect = async (optionId: number | null) => {
    if (updating) return;
    
    setUpdating(true);
    setOpen(false);
    
    try {
      await onUpdate(entityId, relationshipName, optionId);
      <%= entityInstance %>Toast.relationshipUpdated(relationshipName);
    } catch (error) {
      <%= entityInstance %>Toast.custom.error("‚ùå Update Failed", `Failed to update ${relationshipName}`);
      console.error('Relationship update error:', error);
    } finally {
      setUpdating(false);
    }
  };

  // If not editable, display as clickable link or plain text
  if (!isEditable) {
    if (isLoading) {
      return (
        <div className={cn("px-2 py-1", className)}>
          <div className="flex items-center gap-2">
            <Loader2 className="h-3 w-3 animate-spin" />
            <span className="text-sm text-muted-foreground">Loading...</span>
          </div>
        </div>
      );
    }

    // If no current value, show empty state
    if (!currentDisplayValue) {
      return (
        <div className={cn("px-1 py-1", className)}>
          <div className="inline-flex items-center px-2.5 py-1.5 rounded-full bg-slate-50/50 border border-slate-100">
            <span className="text-xs text-slate-400">‚Äî</span>
          </div>
        </div>
      );
    }

    // If we have a route and current ID, make it clickable
    const currentId = currentValue?.id || currentValue;
    if (relatedEntityRoute && currentId) {
      return (
        <div className={cn("px-1 py-1", className)}>
          <TooltipProvider>
            <Tooltip>
              <TooltipTrigger asChild>
                <Button
                  variant="ghost"
                  size="sm"
                  asChild
                  className="h-auto p-0 text-left justify-start font-normal hover:bg-transparent group"
                >
                  <Link 
                    href={`/${relatedEntityRoute}/${currentId}`} 
                    className="inline-flex items-center gap-1.5 px-2.5 py-1.5 rounded-full bg-slate-100 hover:bg-blue-100 border border-slate-200 hover:border-blue-300 transition-all duration-200 hover:shadow-sm"
                    onClick={() => {
                      // Store the current page info for context-aware back navigation
                      if (typeof window !== 'undefined') {
                        localStorage.setItem('referrerInfo', JSON.stringify({
                          url: window.location.pathname,
                          title: document.title,
                          entityType: '<%= entityClass %>',
                          timestamp: Date.now()
                        }));
                      }
                    }}
                  >
                    <span className="text-sm font-medium text-slate-700 group-hover:text-blue-700 transition-colors">
                      {currentDisplayValue}
                    </span>
                    <ExternalLink className="h-3 w-3 text-slate-400 group-hover:text-blue-500 opacity-60 group-hover:opacity-100 transition-all" />
                  </Link>
                </Button>
              </TooltipTrigger>
              <TooltipContent>
                <p>Click to view {relationshipName} details</p>
              </TooltipContent>
            </Tooltip>
          </TooltipProvider>
        </div>
      );
    }

    // Fallback: display as styled badge (non-clickable)
    return (
      <div className={cn("px-1 py-1", className)}>
        <div className="inline-flex items-center px-2.5 py-1.5 rounded-full bg-slate-50 border border-slate-200">
          <span className="text-sm font-medium text-slate-600">{currentDisplayValue}</span>
        </div>
      </div>
    );
  }

  return (
    <div className={cn("relative", className)}>
      <Popover open={open} onOpenChange={setOpen}>
        <PopoverTrigger asChild>
          <Button
            variant="ghost"
            role="combobox"
            aria-expanded={open}
            className="w-full h-8 px-2 py-1 justify-between text-left font-normal hover:bg-muted"
            disabled={updating || isLoading}
          >
            <span className="truncate text-sm">
              {updating ? (
                <div className="flex items-center gap-1">
                  <Loader2 className="h-3 w-3 animate-spin" />
                  <span>Updating...</span>
                </div>
              ) : isLoading ? (
                <div className="flex items-center gap-1">
                  <Loader2 className="h-3 w-3 animate-spin" />
                  <span>Loading...</span>
                </div>
              ) : (
                currentDisplayValue || "Select..."
              )}
            </span>
            <ChevronDown className="ml-1 h-3 w-3 shrink-0 opacity-50" />
          </Button>
        </PopoverTrigger>
        <PopoverContent className="w-[200px] p-0" align="start">
          <Command>
            <CommandInput placeholder="Search..." className="h-8" />
            <CommandList>
              <CommandEmpty>No options found.</CommandEmpty>
              <CommandGroup>
                {/* None/Clear option */}
                <CommandItem
                  value="__none__"
                  onSelect={() => handleSelect(null)}
                  className="text-sm"
                >
                  <Check
                    className={cn(
                      "mr-2 h-3 w-3",
                      !currentId ? "opacity-100" : "opacity-0"
                    )}
                  />
                  <span className="text-muted-foreground">None</span>
                </CommandItem>
                
                {/* Available options */}
                {options.map((option) => {
                  const isSelected = currentId === option.id;
                  
                  return (
                    <CommandItem
                      key={option.id}
                      value={option[displayField]}
                      onSelect={() => handleSelect(option.id)}
                      className="text-sm"
                    >
                      <Check
                        className={cn(
                          "mr-2 h-3 w-3",
                          isSelected ? "opacity-100" : "opacity-0"
                        )}
                      />
                      {option[displayField]}
                    </CommandItem>
                  );
                })}
              </CommandGroup>
            </CommandList>
          </Command>
        </PopoverContent>
      </Popover>
    </div>
  );
}
</file>

<file path="templates/entity/components/relationship-combobox.tsx.ejs">
"use client";

import * as React from "react";
import { Check, ChevronsUpDown, X } from "lucide-react";
import { cn } from "@/lib/utils";
import { Button } from "@/components/ui/button";
import {
  Command,
  CommandEmpty,
  CommandGroup,
  CommandInput,
  CommandItem,
  CommandList,
} from "@/components/ui/command";
import {
  Popover,
  PopoverContent,
  PopoverTrigger,
} from "@/components/ui/popover";
import { Badge } from "@/components/ui/badge";

interface RelationshipComboboxProps {
  value?: number | number[];
  onValueChange: (value: number | number[] | undefined) => void;
  options: Array<{ id: number; [key: string]: any }>;
  displayField: string;
  placeholder?: string;
  multiple?: boolean;
  disabled?: boolean;
  className?: string;
}

export function RelationshipCombobox({
  value,
  onValueChange,
  options = [],
  displayField = "name",
  placeholder = "Select option...",
  multiple = false,
  disabled = false,
  className,
}: RelationshipComboboxProps) {
  const [open, setOpen] = React.useState(false);

  // Handle single selection
  const handleSingleSelect = (optionId: number) => {
    const newValue = value === optionId ? undefined : optionId;
    onValueChange(newValue);
    setOpen(false);
  };

  // Handle multiple selection
  const handleMultipleSelect = (optionId: number) => {
    const currentValues = Array.isArray(value) ? value : [];
    const newValues = currentValues.includes(optionId)
      ? currentValues.filter((id) => id !== optionId)
      : [...currentValues, optionId];
    
    onValueChange(newValues.length > 0 ? newValues : undefined);
  };

  // Remove item from multiple selection
  const removeItem = (optionId: number) => {
    if (Array.isArray(value)) {
      const newValues = value.filter((id) => id !== optionId);
      onValueChange(newValues.length > 0 ? newValues : undefined);
    }
  };

  // Get display text for selected values
  const getDisplayText = () => {
    if (multiple) {
      if (!Array.isArray(value) || value.length === 0) {
        return placeholder;
      }
      return `${value.length} item${value.length === 1 ? '' : 's'} selected`;
    } else {
      if (typeof value !== 'number') {
        return placeholder;
      }
      const selectedOption = options.find((option) => option.id === value);
      return selectedOption ? selectedOption[displayField] : placeholder;
    }
  };

  // Get selected options for multiple selection display
  const getSelectedOptions = () => {
    if (!multiple || !Array.isArray(value)) return [];
    return options.filter((option) => value.includes(option.id));
  };

  return (
    <div className={cn("w-full", className)}>
      <Popover open={open} onOpenChange={setOpen}>
        <PopoverTrigger asChild>
          <Button
            variant="outline"
            role="combobox"
            aria-expanded={open}
            className="w-full justify-between"
            disabled={disabled}
          >
            <span className="truncate">{getDisplayText()}</span>
            <ChevronsUpDown className="ml-2 h-4 w-4 shrink-0 opacity-50" />
          </Button>
        </PopoverTrigger>
        <PopoverContent className="w-full p-0" align="start">
          <Command>
            <CommandInput placeholder="Search..." />
            <CommandList>
              <CommandEmpty>No options found.</CommandEmpty>
              <CommandGroup>
                {options.map((option) => {
                  const isSelected = multiple
                    ? Array.isArray(value) && value.includes(option.id)
                    : value === option.id;

                  return (
                    <CommandItem
                      key={option.id}
                      value={option[displayField]}
                      onSelect={() => {
                        if (multiple) {
                          handleMultipleSelect(option.id);
                        } else {
                          handleSingleSelect(option.id);
                        }
                      }}
                    >
                      <Check
                        className={cn(
                          "mr-2 h-4 w-4",
                          isSelected ? "opacity-100" : "opacity-0"
                        )}
                      />
                      {option[displayField]}
                    </CommandItem>
                  );
                })}
              </CommandGroup>
            </CommandList>
          </Command>
        </PopoverContent>
      </Popover>

      {/* Display selected items for multiple selection */}
      {multiple && Array.isArray(value) && value.length > 0 && (
        <div className="mt-2 flex flex-wrap gap-1">
          {getSelectedOptions().map((option) => (
            <Badge key={option.id} variant="secondary" className="gap-1">
              {option[displayField]}
              <Button
                variant="ghost"
                size="sm"
                className="h-auto p-0 text-muted-foreground hover:text-foreground"
                onClick={() => removeItem(option.id)}
                type="button"
              >
                <X className="h-3 w-3" />
                <span className="sr-only">Remove</span>
              </Button>
            </Badge>
          ))}
        </div>
      )}
    </div>
  );
}
</file>

<file path="templates/entity/components/relationship-return-handler.tsx.ejs">
"use client";

import { useEffect } from "react";
import { useRouter } from "next/navigation";

interface RelationshipReturnHandlerProps {
  entityId?: number;
  entityName: string;
  onSuccess?: () => void;
}

/**
 * Handles return navigation after creating a new related entity
 * Sets the newly created entity ID in session storage for auto-selection
 */
export function RelationshipReturnHandler({ 
  entityId, 
  entityName,
  onSuccess
}: RelationshipReturnHandlerProps) {
  const router = useRouter();

  useEffect(() => {
    // Check if we just created an entity and need to return
    const returnUrl = sessionStorage.getItem('returnUrl');
    const relationshipInfo = sessionStorage.getItem('relationshipFieldInfo');
    
    if (entityId && returnUrl && relationshipInfo) {
      try {
        // Store the newly created entity ID for auto-selection
        sessionStorage.setItem('newlyCreatedEntityId', entityId.toString());
        
        // Call success callback if provided
        if (onSuccess) {
          onSuccess();
        }
        
        // Navigate back to the original form
        router.push(returnUrl);
        
        // Clean up session storage after navigation
        setTimeout(() => {
          sessionStorage.removeItem('returnUrl');
          sessionStorage.removeItem('relationshipFieldInfo');
        }, 100);
      } catch (error) {
        console.error('Error handling relationship return:', error);
        // Fallback: just clean up and stay on current page
        sessionStorage.removeItem('returnUrl');
        sessionStorage.removeItem('relationshipFieldInfo');
      }
    }
  }, [entityId, router, onSuccess]);

  return null; // This component doesn't render anything
}
</file>

<file path="templates/entity/components/table/entity-search-filters.tsx.ejs">
"use client";

import { useState } from "react";
import {
  Filter,
  X,
  Search,
  CalendarIcon,
  ChevronDown
} from "lucide-react";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import {
  Popover,
  PopoverContent,
  PopoverTrigger,
} from "@/components/ui/popover";
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuLabel,
  DropdownMenuSeparator,
  DropdownMenuTrigger,
} from "@/components/ui/dropdown-menu";
import { Calendar } from "@/components/ui/calendar";
import { format } from "date-fns";
import { Badge } from "@/components/ui/badge";

<%
// Organize fields by type for better filter organization
const enumFields = fields.filter(f => f.fieldIsEnum);
const booleanFields = fields.filter(f => f.fieldTypeBoolean);
const dateFields = fields.filter(f => f.fieldTypeLocalDate || f.fieldTypeTimed);
const textFields = fields.filter(f => !f.fieldIsEnum && !f.fieldTypeBoolean && !f.fieldTypeLocalDate && !f.fieldTypeTimed && !f.fieldTypeBinary);

const displayableRelationships = relationships.filter(rel => 
  rel.relationshipType !== 'one-to-many' && 
  !rel.collection && 
  rel.otherEntityField
);
%>

interface FilterState {
  [key: string]: string | string[] | Date | undefined;
}

interface DateRange {
  from: Date | undefined;
  to: Date | undefined;
}

interface <%= entityClass %>SearchAndFiltersProps {
  searchTerm: string;
  onSearchChange: (e: React.ChangeEvent<HTMLInputElement>) => void;
  filters: FilterState;
  onFilterChange: (column: string, value: any) => void;
  dateRange: DateRange;
  onDateRangeChange: (range: DateRange) => void;
  onClearAll: () => void;
  hasActiveFilters: boolean;
}

export function <%= entityClass %>SearchAndFilters({
  searchTerm,
  onSearchChange,
  filters,
  onFilterChange,
  dateRange,
  onDateRangeChange,
  onClearAll,
  hasActiveFilters
}: <%= entityClass %>SearchAndFiltersProps) {
  const [showFilterDropdown, setShowFilterDropdown] = useState(false);

  // Count active filters for badge
  const activeFiltersCount = Object.values(filters).filter(v => v !== undefined && v !== "").length + 
    (searchTerm ? 1 : 0) + 
    (dateRange.from || dateRange.to ? 1 : 0);

  // Remove specific filter
  const removeFilter = (filterKey: string) => {
    const newFilters = { ...filters };
    delete newFilters[filterKey];
    onFilterChange(filterKey, undefined);
  };

  // Get filter display value
  const getFilterDisplayValue = (key: string, value: any) => {
    if (typeof value === 'boolean') return value ? 'Yes' : 'No';
    if (value instanceof Date) return format(value, 'MMM dd, yyyy');
    return String(value);
  };

  // Get filter display name
  const getFilterDisplayName = (key: string) => {
    // Handle relationship filters
    if (key.includes('.')) {
      const [relationName] = key.split('.');
      <%_ for (const rel of displayableRelationships) { _%>
      if (relationName === '<%= rel.relationshipName %>') {
        return '<%= rel.relationshipNameHumanized %>';
      }
      <%_ } _%>
      return relationName;
    }
    
    // Handle regular field filters
    <%_ for (const field of [...enumFields, ...booleanFields, ...dateFields, ...textFields]) { _%>
    if (key === '<%= field.fieldName %>') {
      return '<%= field.fieldNameHumanized || field.fieldName %>';
    }
    <%_ } _%>
    return key;
  };

  return (
    <>
      {/* Search and Filter Bar */}
      <div className="flex items-center gap-3">
        {/* Global Search */}
        <div className="relative flex-1 max-w-md">
          <Search className="absolute left-3 top-1/2 transform -translate-y-1/2 h-4 w-4 text-muted-foreground" />
          <Input
            placeholder="Search <%= entityClassPluralHumanized.toLowerCase() %>..."
            value={searchTerm}
            onChange={onSearchChange}
            className="pl-10"
          />
        </div>

        {/* Filter Dropdown */}
        <DropdownMenu open={showFilterDropdown} onOpenChange={setShowFilterDropdown}>
          <DropdownMenuTrigger asChild>
            <Button variant="outline" className="gap-2">
              <Filter className="h-4 w-4" />
              Filters
              {activeFiltersCount > 0 && (
                <Badge variant="secondary" className="ml-1 h-5 min-w-[20px] text-xs">
                  {activeFiltersCount}
                </Badge>
              )}
              <ChevronDown className="h-4 w-4" />
            </Button>
          </DropdownMenuTrigger>
          <DropdownMenuContent className="w-80 p-4" align="end">
            <div className="space-y-4">
              
              <% if (enumFields.length > 0) { %>
              {/* Status & Priority Section */}
              <div>
                <DropdownMenuLabel className="px-0 text-sm font-medium">Status & Priority</DropdownMenuLabel>
                <div className="space-y-2 mt-2">
                  <% for (const field of enumFields) { %>
                  <div>
                    <label className="text-xs text-muted-foreground mb-1 block">
                      <%= field.fieldNameHumanized || field.fieldName %>
                    </label>
                    <Select
                      value={filters["<%= field.fieldName %>"] as string || "__all__"}
                      onValueChange={(value) => onFilterChange("<%= field.fieldName %>", value === "__all__" ? undefined : value)}
                    >
                      <SelectTrigger className="h-8">
                        <SelectValue placeholder="All" />
                      </SelectTrigger>
                      <SelectContent>
                        <SelectItem value="__all__">All</SelectItem>
                        <% for (const enumValue of field.enumValues || []) { %>
                        <SelectItem value="<%= enumValue.name || enumValue.value || 'EMPTY_VALUE' %>"><%= enumValue.name || enumValue.value || 'Empty' %></SelectItem>
                        <% } %>
                      </SelectContent>
                    </Select>
                  </div>
                  <% } %>
                </div>
              </div>
              <% } %>

              <% if (booleanFields.length > 0) { %>
              <DropdownMenuSeparator />
              
              {/* Boolean Fields Section */}
              <div>
                <DropdownMenuLabel className="px-0 text-sm font-medium">Options</DropdownMenuLabel>
                <div className="space-y-2 mt-2">
                  <% for (const field of booleanFields) { %>
                  <div>
                    <label className="text-xs text-muted-foreground mb-1 block">
                      <%= field.fieldNameHumanized || field.fieldName %>
                    </label>
                    <Select
                      value={filters["<%= field.fieldName %>"] as string || "__all__"}
                      onValueChange={(value) => onFilterChange("<%= field.fieldName %>", value === "__all__" ? undefined : value)}
                    >
                      <SelectTrigger className="h-8">
                        <SelectValue placeholder="All" />
                      </SelectTrigger>
                      <SelectContent>
                        <SelectItem value="__all__">All</SelectItem>
                        <SelectItem value="true">Yes</SelectItem>
                        <SelectItem value="false">No</SelectItem>
                      </SelectContent>
                    </Select>
                  </div>
                  <% } %>
                </div>
              </div>
              <% } %>

              <% if (displayableRelationships.length > 0) { %>
              <DropdownMenuSeparator />
              
              {/* People Section */}
              <div>
                <DropdownMenuLabel className="px-0 text-sm font-medium">People & Relationships</DropdownMenuLabel>
                <div className="space-y-2 mt-2">
                  <% for (const rel of displayableRelationships) { 
                    const displayField = rel.otherEntity.builtInUser ? 'login' : rel.otherEntityField;
                  %>
                  <div>
                    <label className="text-xs text-muted-foreground mb-1 block">
                      <%= rel.relationshipNameHumanized %>
                    </label>
                    <Input
                      placeholder="Filter by <%= rel.relationshipNameHumanized.toLowerCase() %>..."
                      value={filters["<%= rel.relationshipName %>.<%=displayField%>"] as string || ""}
                      onChange={(e) => onFilterChange("<%= rel.relationshipName %>.<%=displayField%>", e.target.value || undefined)}
                      className="h-8"
                    />
                  </div>
                  <% } %>
                </div>
              </div>
              <% } %>

              <% if (dateFields.length > 0) { %>
              <DropdownMenuSeparator />
              
              {/* Dates Section */}
              <div>
                <DropdownMenuLabel className="px-0 text-sm font-medium">Dates</DropdownMenuLabel>
                <div className="mt-2">
                  <label className="text-xs text-muted-foreground mb-1 block">
                    <%= dateFields[0].fieldNameHumanized || dateFields[0].fieldName %> Range
                  </label>
                  <Popover>
                    <PopoverTrigger asChild>
                      <Button
                        variant="outline"
                        className="w-full h-8 justify-start text-left font-normal"
                      >
                        <CalendarIcon className="mr-2 h-3 w-3" />
                        {dateRange.from ? (
                          dateRange.to ? (
                            <>
                              {format(dateRange.from, "MMM dd")} - {format(dateRange.to, "MMM dd")}
                            </>
                          ) : (
                            format(dateRange.from, "MMM dd, yyyy")
                          )
                        ) : (
                          "Pick date range"
                        )}
                      </Button>
                    </PopoverTrigger>
                    <PopoverContent className="w-auto p-0" align="start">
                      <Calendar
                        initialFocus
                        mode="range"
                        defaultMonth={dateRange.from}
                        selected={{ from: dateRange.from, to: dateRange.to }}
                        onSelect={(range) => onDateRangeChange({ from: range?.from, to: range?.to })}
                        numberOfMonths={2}
                      />
                      <div className="p-3 border-t">
                        <Button
                          variant="ghost"
                          size="sm"
                          className="w-full h-7"
                          onClick={() => onDateRangeChange({ from: undefined, to: undefined })}
                        >
                          Clear Date Range
                        </Button>
                      </div>
                    </PopoverContent>
                  </Popover>
                </div>
              </div>
              <% } %>

              <% if (textFields.length > 0) { %>
              <DropdownMenuSeparator />
              
              {/* Other Fields Section */}
              <div>
                <DropdownMenuLabel className="px-0 text-sm font-medium">Other Fields</DropdownMenuLabel>
                <div className="space-y-2 mt-2">
                  <% for (const field of textFields.slice(0, 3)) { %>
                  <div>
                    <label className="text-xs text-muted-foreground mb-1 block">
                      <%= field.fieldNameHumanized || field.fieldName %>
                    </label>
                    <Input
                      placeholder="Filter by <%= field.fieldName %>..."
                      value={filters["<%= field.fieldName %>"] as string || ""}
                      onChange={(e) => onFilterChange("<%= field.fieldName %>", e.target.value || undefined)}
                      className="h-8"
                    />
                  </div>
                  <% } %>
                </div>
              </div>
              <% } %>

            </div>
          </DropdownMenuContent>
        </DropdownMenu>

        {/* Clear Filters Button */}
        {hasActiveFilters && (
          <Button
            variant="ghost"
            size="sm"
            onClick={onClearAll}
            className="gap-2 text-muted-foreground hover:text-foreground"
          >
            <X className="h-4 w-4" />
            Clear
          </Button>
        )}
      </div>

      {/* Active Filters Display */}
      {hasActiveFilters && (
        <div className="flex items-center gap-2 flex-wrap">
          {searchTerm && (
            <Badge variant="secondary" className="gap-1">
              Search: {searchTerm}
              <button
                onClick={() => onSearchChange({ target: { value: "" } } as any)}
                className="ml-1 rounded-full hover:bg-secondary-foreground/20"
              >
                <X className="h-3 w-3" />
              </button>
            </Badge>
          )}
          
          {Object.entries(filters).map(([key, value]) => (
            value !== undefined && value !== "" && (
              <Badge key={key} variant="secondary" className="gap-1">
                {getFilterDisplayName(key)}: {getFilterDisplayValue(key, value)}
                <button
                  onClick={() => removeFilter(key)}
                  className="ml-1 rounded-full hover:bg-secondary-foreground/20"
                >
                  <X className="h-3 w-3" />
                </button>
              </Badge>
            )
          ))}
          
          {(dateRange.from || dateRange.to) && (
            <Badge variant="secondary" className="gap-1">
              Date: {dateRange.from && format(dateRange.from, "MMM dd")}
              {dateRange.from && dateRange.to && " - "}
              {dateRange.to && format(dateRange.to, "MMM dd")}
              <button
                onClick={() => onDateRangeChange({ from: undefined, to: undefined })}
                className="ml-1 rounded-full hover:bg-secondary-foreground/20"
              >
                <X className="h-3 w-3" />
              </button>
            </Badge>
          )}
        </div>
      )}
    </>
  );
}
</file>

<file path="templates/entity/components/table/entity-table-header.tsx.ejs">
"use client";

import { ChevronDown, ChevronUp, ChevronsUpDown, Filter } from "lucide-react";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Checkbox } from "@/components/ui/checkbox";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import {
  TableHead,
  TableHeader,
  TableRow,
} from "@/components/ui/table";

<%
const displayableRelationships = relationships.filter(rel => 
  rel.relationshipType !== 'one-to-many' && 
  !rel.collection && 
  rel.otherEntityField
);

// Organize fields by type for better filter organization
const enumFields = fields.filter(f => f.fieldIsEnum);
const booleanFields = fields.filter(f => f.fieldTypeBoolean);
const dateFields = fields.filter(f => f.fieldTypeLocalDate || f.fieldTypeTimed);
const textFields = fields.filter(f => !f.fieldIsEnum && !f.fieldTypeBoolean && !f.fieldTypeLocalDate && !f.fieldTypeTimed && !f.fieldTypeBinary);

// Function to convert camelCase to Title Case
function camelToTitleCase(str) {
  return str
    .replace(/([A-Z])/g, ' $1')
    .replace(/^./, str => str.toUpperCase())
    .trim();
}
%>

interface FilterState {
  [key: string]: string | string[] | Date | undefined;
}

interface <%= entityClass %>TableHeaderProps {
  onSort: (column: string) => void;
  getSortIcon: (column: string) => string;
  filters: FilterState;
  onFilterChange: (column: string, value: any) => void;
  isAllSelected: boolean;
  isIndeterminate: boolean;
  onSelectAll: () => void;
}

export function <%= entityClass %>TableHeader({ 
  onSort, 
  getSortIcon,
  filters,
  onFilterChange,
  isAllSelected,
  isIndeterminate,
  onSelectAll
}: <%= entityClass %>TableHeaderProps) {
  const renderSortIcon = (column: string) => {
    const iconType = getSortIcon(column);
    switch (iconType) {
      case "ChevronUp":
        return <ChevronUp className="h-4 w-4" />;
      case "ChevronDown":
        return <ChevronDown className="h-4 w-4" />;
      default:
        return <ChevronsUpDown className="h-4 w-4" />;
    }
  };

  return (
    <TableHeader>
      {/* Header Row with Sort Buttons */}
      <TableRow className="border-b border-gray-200 bg-gray-50">
        <TableHead className="w-12 px-3 py-2">
          <Checkbox
            checked={isAllSelected}
            onCheckedChange={onSelectAll}
            ref={(el) => {
              if (el) el.indeterminate = isIndeterminate;
            }}
          />
        </TableHead>
        <% for (field of fields) { %>
        <TableHead className="whitespace-nowrap px-3 py-2">
          <Button
            variant="ghost"
            onClick={() => onSort("<%= field.fieldName %>")}
            className="flex items-center gap-1.5 h-auto px-2 py-1 font-medium text-gray-700 hover:text-gray-900 hover:bg-white rounded text-sm transition-colors"
          >
            <%= camelToTitleCase(field.fieldName) %>
            <div className="text-gray-400">
              {renderSortIcon("<%= field.fieldName %>")}
            </div>
          </Button>
        </TableHead>
        <% } %>
        <% 
        for (const rel of displayableRelationships) { 
          const displayField = rel.otherEntity.builtInUser ? 'login' : rel.otherEntityField;
        %>
        <TableHead className="whitespace-nowrap px-3 py-2">
          <Button
            variant="ghost"
            onClick={() => onSort("<%= rel.relationshipName %>.<%=displayField%>")}
            className="flex items-center gap-1.5 h-auto px-2 py-1 font-medium text-gray-700 hover:text-gray-900 hover:bg-white rounded text-sm transition-colors"
          >
            <%= camelToTitleCase(rel.relationshipName) %>
            <div className="text-gray-400">
              {renderSortIcon("<%= rel.relationshipName %>.<%=displayField%>")}
            </div>
          </Button>
        </TableHead>
        <% } %>
        <TableHead className="w-[120px] sticky right-0 bg-gray-50 px-3 py-2 border-l border-gray-200">
          <div className="flex items-center gap-2 font-medium text-gray-700 text-sm">
            <Filter className="h-3.5 w-3.5 text-gray-500" />
            <span>Actions</span>
          </div>
        </TableHead>
      </TableRow>
      
      {/* Filter Row */}
      <TableRow className="border-b bg-white">
        <TableHead className="w-12 px-3 py-2">
          {/* Empty cell for checkbox column */}
        </TableHead>
        <% for (field of fields) { %>
        <TableHead className="px-3 py-2">
          <% if (field.fieldIsEnum) { %>
          <Select
            value={filters["<%= field.fieldName %>"] as string || "__all__"}
            onValueChange={(value) => onFilterChange("<%= field.fieldName %>", value === "__all__" ? undefined : value)}
          >
            <SelectTrigger className="h-8 text-xs border-gray-300 focus:border-blue-500 focus:ring-1 focus:ring-blue-500">
              <SelectValue placeholder="All" />
            </SelectTrigger>
            <SelectContent>
              <SelectItem value="__all__">All</SelectItem>
              <% for (const enumValue of field.enumValues || []) { %>
              <SelectItem value="<%= enumValue.name || enumValue.value || 'EMPTY_VALUE' %>">
                <%= enumValue.name || enumValue.value || 'Empty' %>
              </SelectItem>
              <% } %>
            </SelectContent>
          </Select>
          <% } else if (field.fieldTypeBoolean) { %>
          <Select
            value={filters["<%= field.fieldName %>"] as string || "__all__"}
            onValueChange={(value) => onFilterChange("<%= field.fieldName %>", value === "__all__" ? undefined : value)}
          >
            <SelectTrigger className="h-8 text-xs border-gray-300 focus:border-blue-500 focus:ring-1 focus:ring-blue-500">
              <SelectValue placeholder="All" />
            </SelectTrigger>
            <SelectContent>
              <SelectItem value="__all__">All</SelectItem>
              <SelectItem value="true">Yes</SelectItem>
              <SelectItem value="false">No</SelectItem>
            </SelectContent>
          </Select>
          <% } else if (field.fieldTypeLocalDate || field.fieldTypeTimed) { %>
          <Input
            type="date"
            className="h-8 text-xs border-gray-300 focus:border-blue-500 focus:ring-1 focus:ring-blue-500"
            value={filters["<%= field.fieldName %>"] as string || ""}
            onChange={(e) => onFilterChange("<%= field.fieldName %>", e.target.value || undefined)}
          />
          <% } else { %>
          <Input
            placeholder="Filter..."
            className="h-8 text-xs border-gray-300 focus:border-blue-500 focus:ring-1 focus:ring-blue-500 placeholder:text-gray-400"
            value={filters["<%= field.fieldName %>"] as string || ""}
            onChange={(e) => onFilterChange("<%= field.fieldName %>", e.target.value || undefined)}
          />
          <% } %>
        </TableHead>
        <% } %>
        
        <% for (const rel of displayableRelationships) { 
          const displayField = rel.otherEntity.builtInUser ? 'login' : rel.otherEntityField;
        %>
        <TableHead className="px-3 py-2">
          <Input
            placeholder="Filter..."
            className="h-8 text-xs border-gray-300 focus:border-blue-500 focus:ring-1 focus:ring-blue-500 placeholder:text-gray-400"
            value={filters["<%= rel.relationshipName %>.<%=displayField%>"] as string || ""}
            onChange={(e) => onFilterChange("<%= rel.relationshipName %>.<%=displayField%>", e.target.value || undefined)}
          />
        </TableHead>
        <% } %>
        
        <TableHead className="w-[120px] sticky right-0 bg-white px-3 py-2 border-l border-gray-200">
          <div className="flex items-center gap-1.5">
            <Filter className="h-3.5 w-3.5 text-gray-500" />
            <span className="text-xs font-medium text-gray-600">Filters</span>
          </div>
        </TableHead>
      </TableRow>
    </TableHeader>
  );
}
</file>

<file path="templates/entity/components/table/entity-table-main.tsx.ejs">
<%#
 Copyright 2013-2025 the original author or authors from the JHipster project.
-%>
"use client";

import { useState } from "react";
import Link from "next/link";
import { useRouter } from "next/navigation";
import {
  ChevronDown,
  ChevronUp,
  ChevronsUpDown,
  Eye,
  Pencil,
  Trash2,
  X
} from "lucide-react";
import { toast } from "sonner";
import { Button } from "@/components/ui/button";
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from "@/components/ui/table";
import { 
  Pagination, 
  PaginationContent, 
  PaginationItem, 
  PaginationLink, 
  PaginationNext, 
  PaginationPrevious 
} from "@/components/ui/pagination";
import { Badge } from "@/components/ui/badge";
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
} from "@/components/ui/alert-dialog";
import { format } from "date-fns";

import {
  useGetAll<%= entityClassPlural %>,
  useDelete<%= entityClass %>,
  useCount<%= entityClassPlural %>,
  <% if (searchEngineAny) { %>useSearch<%= entityClassPlural %>,<% } %>
} from "@/core/api/generated/spring/endpoints/<%= entityFileName %>-resource/<%= entityFileName %>-resource.gen";

import { <%= entityClass %>SearchAndFilters } from "./<%= entityFileName %>-search-filters";
import { <%= entityClass %>TableHeader } from "./<%= entityFileName %>-table-header";
import { <%= entityClass %>TableRow } from "./<%= entityFileName %>-table-row";

<%
// Define table relationships once at the top to avoid redeclaration
const displayableRelationships = relationships.filter(rel => 
  rel.relationshipType !== 'one-to-many' && 
  !rel.collection && 
  rel.otherEntityField
);
%>

// Define sort ordering constants
const ASC = "asc";
const DESC = "desc";

interface FilterState {
  [key: string]: string | string[] | Date | undefined;
}

interface DateRange {
  from: Date | undefined;
  to: Date | undefined;
}

export function <%= entityClass %>Table() {
  const router = useRouter();
  const [page, setPage] = useState(1);
  const [sort, setSort] = useState("<%= primaryKey.name %>");
  const [order, setOrder] = useState(ASC);
  const [searchTerm, setSearchTerm] = useState("");
  const [deleteId, setDeleteId] = useState<number | null>(null);
  const [showDeleteDialog, setShowDeleteDialog] = useState(false);
  const [filters, setFilters] = useState<FilterState>({});
  const [dateRange, setDateRange] = useState<DateRange>({ from: undefined, to: undefined });

  // Calculate API pagination parameters (0-indexed)
  const apiPage = page - 1;
  const pageSize = 10;

  // Build filter parameters for API
  const buildFilterParams = () => {
    const params: Record<string, any> = {};
    
    // Add regular filters
    Object.entries(filters).forEach(([key, value]) => {
      if (value !== undefined && value !== "" && value !== null) {
        if (Array.isArray(value) && value.length > 0) {
          params[key] = value;
        } else if (value instanceof Date) {
          params[key] = value.toISOString().split('T')[0];
        } else if (typeof value === 'string' && value.trim() !== '') {
          params[key] = value;
        }
      }
    });

    // Add date range filters
    if (dateRange.from && dateRange.to) {
      // Add your date range logic here based on your API
    }

    return params;
  };

  const filterParams = buildFilterParams();

  // Fetch data with React Query
  <% if (searchEngineAny) { %>
  const { data, isLoading, refetch } = searchTerm 
    ? useSearch<%= entityClassPlural %>(
        {
          query: searchTerm,
          page: apiPage,
          size: pageSize,
          sort: `${sort},${order}`,
          ...filterParams,
        },
        {
          query: {
            enabled: true,
          },
        }
      )
    : 
  <% } %>
  const { data, isLoading, refetch } = useGetAll<%= entityClassPlural %>(
    {
      page: apiPage,
      size: pageSize,
      sort: `${sort},${order}`,
      ...filterParams,
    },
    {
      query: {
        enabled: true,
      },
    }
  );

  // Get total count for pagination
  const { data: countData } = useCount<%= entityClassPlural %>(
    filterParams,
    {
      query: {
        enabled: true,
      },
    }
  );

  // Delete mutation
  const { mutate: deleteEntity, isPending: isDeleting } = useDelete<%= entityClass %>({
    mutation: {
      onSuccess: () => {
        toast.success("<%= entityClass %> deleted successfully");
        refetch();
      },
      onError: (error) => {
        toast.error(`Failed to delete <%= entityClass %>: ${error}`);
      },
    },
  });

  // Handle sort column click
  const handleSort = (column: string) => {
    if (sort === column) {
      setOrder(order === ASC ? DESC : ASC);
    } else {
      setSort(column);
      setOrder(ASC);
    }
  };

  // Get sort direction icon
  const getSortIcon = (column: string) => {
    if (sort !== column) {
      return <ChevronsUpDown className="h-4 w-4" />;
    }
    return order === ASC ? <ChevronUp className="h-4 w-4" /> : <ChevronDown className="h-4 w-4" />;
  };

  // Handle delete
  const handleDelete = (id: number) => {
    setDeleteId(id);
    setShowDeleteDialog(true);
  };

  const confirmDelete = () => {
    if (deleteId) {
      deleteEntity({ id: deleteId });
    }
    setShowDeleteDialog(false);
  };

  // Handle filter change
  const handleFilterChange = (column: string, value: any) => {
    setFilters(prev => ({
      ...prev,
      [column]: value
    }));
    setPage(1);
  };

  // Clear all filters
  const clearAllFilters = () => {
    setFilters({});
    setSearchTerm("");
    setDateRange({ from: undefined, to: undefined });
    setPage(1);
  };

  <% if (searchEngineAny) { %>
  // Handle search
  const handleSearch = (e: React.ChangeEvent<HTMLInputElement>) => {
    setSearchTerm(e.target.value);
    setPage(1);
  };
  <% } %>

  // Calculate total pages
  const totalItems = countData || 0;
  const totalPages = Math.ceil(totalItems / pageSize);

  // Check if any filters are active
  const hasActiveFilters = Object.keys(filters).length > 0 || searchTerm || dateRange.from || dateRange.to;

  return (
    <div className="space-y-4">
      {/* Search and Filter Component */}
      <<%= entityClass %>SearchAndFilters 
        searchTerm={searchTerm}
        onSearchChange={<% if (searchEngineAny) { %>handleSearch<% } else { %>(e) => setSearchTerm(e.target.value)<% } %>}
        filters={filters}
        onFilterChange={handleFilterChange}
        dateRange={dateRange}
        onDateRangeChange={setDateRange}
        onClearAll={clearAllFilters}
        hasActiveFilters={hasActiveFilters}
      />

      {/* Data Table */}
      <div className="overflow-x-auto rounded-md border">
        <Table className="min-w-full">
          <<%= entityClass %>TableHeader 
            onSort={handleSort}
            getSortIcon={getSortIcon}
          />
          <TableBody>
            {isLoading ? (
              <TableRow>
                <TableCell
                  colSpan={<%= fields.length + displayableRelationships.length + 1 %>}
                  className="h-24 text-center"
                >
                  Loading...
                </TableCell>
              </TableRow>
            ) : data?.length ? (
              data.map((<%= entityInstance %>) => (
                <<%= entityClass %>TableRow
                  key={<%= entityInstance %>.<%= primaryKey.name %>}
                  <%= entityInstance %>={<%= entityInstance %>}
                  onDelete={handleDelete}
                  isDeleting={isDeleting}
                />
              ))
            ) : (
              <TableRow>
                <TableCell
                  colSpan={<%= fields.length + displayableRelationships.length + 1 %>}
                  className="h-24 text-center"
                >
                  No <%= entityClassPluralHumanized.toLowerCase() %> found
                  {hasActiveFilters && (
                    <div className="text-sm text-muted-foreground mt-1">
                      Try adjusting your filters
                    </div>
                  )}
                </TableCell>
              </TableRow>
            )}
          </TableBody>
        </Table>
      </div>

      {/* Pagination */}
      {totalPages > 1 && (
        <Pagination>
          <PaginationContent>
            <PaginationItem>
              <PaginationPrevious
                href="#"
                onClick={(e) => {
                  e.preventDefault();
                  if (page > 1) setPage(page - 1);
                }}
                className={page <= 1 ? "pointer-events-none opacity-50" : ""}
              />
            </PaginationItem>
            {Array.from({ length: Math.min(5, totalPages) }, (_, i) => {
              const pageNumbers = [];
              const startPage = Math.max(1, page - 2);
              const endPage = Math.min(totalPages, startPage + 4);
              
              for (let j = startPage; j <= endPage; j++) {
                pageNumbers.push(j);
              }
              
              return pageNumbers[i];
            }).filter(Boolean).map((p) => (
              <PaginationItem key={p}>
                <PaginationLink
                  href="#"
                  onClick={(e) => {
                    e.preventDefault();
                    setPage(p);
                  }}
                  isActive={page === p}
                >
                  {p}
                </PaginationLink>
              </PaginationItem>
            ))}
            <PaginationItem>
              <PaginationNext
                href="#"
                onClick={(e) => {
                  e.preventDefault();
                  if (page < totalPages) setPage(page + 1);
                }}
                className={page >= totalPages ? "pointer-events-none opacity-50" : ""}
              />
            </PaginationItem>
          </PaginationContent>
        </Pagination>
      )}

      {/* Delete Dialog */}
      <AlertDialog open={showDeleteDialog} onOpenChange={setShowDeleteDialog}>
        <AlertDialogContent>
          <AlertDialogHeader>
            <AlertDialogTitle>Are you sure?</AlertDialogTitle>
            <AlertDialogDescription>
              This action cannot be undone. This will permanently delete the
              <%= entityClass.toLowerCase() %> and remove its data from the server.
            </AlertDialogDescription>
          </AlertDialogHeader>
          <AlertDialogFooter>
            <AlertDialogCancel>Cancel</AlertDialogCancel>
            <AlertDialogAction 
              onClick={confirmDelete}
              className="bg-destructive text-destructive-foreground hover:bg-destructive/90"
            >
              Delete
            </AlertDialogAction>
          </AlertDialogFooter>
        </AlertDialogContent>
      </AlertDialog>
    </div>
  );
}
</file>

<file path="templates/entity/components/table/entity-table-row.tsx.ejs">
"use client";

import Link from "next/link";
import { Eye, Pencil, Trash2 } from "lucide-react";
import { Button } from "@/components/ui/button";
import { Checkbox } from "@/components/ui/checkbox";
import { TableCell, TableRow } from "@/components/ui/table";
import { Badge } from "@/components/ui/badge";
import { format } from "date-fns";
import { InlinePermissionGuard } from "@/components/auth/permission-guard";
import { RelationshipCell } from "./relationship-cell";
import type { <%= entityClass %>DTO } from "@/core/api/generated/spring/schemas/<%= entityClass %>DTO";

<%
const displayableRelationships = relationships.filter(rel => 
  rel.relationshipType !== 'one-to-many' && 
  !rel.collection && 
  rel.otherEntityField
);
%>

interface RelationshipConfig {
  name: string;
  displayName: string;
  options: Array<{ id: number; [key: string]: any }>;
  displayField: string;
  isEditable: boolean;
}

interface <%= entityClass %>TableRowProps {
  <%= entityInstance %>: <%= entityClass %>DTO;
  onDelete: (id: number) => void;
  isDeleting: boolean;
  isSelected: boolean;
  onSelect: (id: number) => void;
  relationshipConfigs?: RelationshipConfig[];
  onRelationshipUpdate?: (entityId: number, relationshipName: string, newValue: number | null) => Promise<void>;
  isUpdating?: boolean;
}

export function <%= entityClass %>TableRow({ 
  <%= entityInstance %>, 
  onDelete, 
  isDeleting, 
  isSelected, 
  onSelect,
  relationshipConfigs = [],
  onRelationshipUpdate,
  isUpdating = false,
}: <%= entityClass %>TableRowProps) {
  return (
    <TableRow>
      <TableCell className="w-12 px-3 py-2">
        <Checkbox
          checked={isSelected}
          onCheckedChange={() => <%= entityInstance %>.<%= primaryKey.name %> && onSelect(<%= entityInstance %>.<%= primaryKey.name %>)}
        />
      </TableCell>
      <% for (field of fields) { 
           const fieldName = field.fieldName;
           const fieldType = field.fieldType; %>
      <TableCell className="whitespace-nowrap px-3 py-2">
        <% if (field.fieldTypeBoolean) { %>
        {<%= entityInstance %>.<%= fieldName %> ? "Yes" : "No"}
        <% } else if (field.fieldTypeLocalDate || field.fieldTypeTimed) { %>
        {<%= entityInstance %>.<%= fieldName %> ? format(new Date(<%= entityInstance %>.<%= fieldName %>), "PPP") : ""}
        <% } else if (field.fieldTypeBinary && !field.blobContentTypeText) { %>
        {<%= entityInstance %>.<%= fieldName %> ? (
          <>
            <% if (field.blobContentTypeImage) { %>
            <img
              src={`data:${<%= entityInstance %>.<%= fieldName %>ContentType};base64,${<%= entityInstance %>.<%= fieldName %>}`}
              alt=""
              className="max-h-8 rounded"
            />
            <% } else { %>
            <span className="text-muted-foreground">Binary data</span>
            <% } %>
          </>
        ) : ""}
        <% } else if (field.fieldIsEnum) { %>
        <Badge variant="secondary">{<%= entityInstance %>.<%= fieldName %>}</Badge>
        <% } else { %>
        {<%= entityInstance %>.<%= fieldName %>}
        <% } %>
      </TableCell>
      <% } %>
<%
// Helper function to convert entity name to route
function entityToRoute(entityName) {
  if (!entityName) return '';
  const kebabCase = entityName.replace(/([a-z0-9])([A-Z])/g, '$1-$2').toLowerCase();
  // Simple pluralization logic
  if (kebabCase.endsWith('y') && kebabCase.length > 1 && !'aeiou'.includes(kebabCase[kebabCase.length - 2])) {
    return kebabCase.slice(0, -1) + 'ies';
  } else if (kebabCase.endsWith('s') || kebabCase.endsWith('sh') || kebabCase.endsWith('ch') || kebabCase.endsWith('x') || kebabCase.endsWith('z')) {
    return kebabCase + 'es';
  } else {
    return kebabCase + 's';
  }
}
%>
      <% for (const rel of displayableRelationships) { 
           const displayField = rel.otherEntity.builtInUser ? 'login' : rel.otherEntityField;
           const relationshipFieldName = rel.relationshipFieldName;
           // Generate the route for the related entity
           const otherEntityRoute = rel.otherEntity.builtInUser ? 'users' : entityToRoute(rel.otherEntityName);
      %>
      <TableCell className="whitespace-nowrap px-1 py-2">
        <RelationshipCell
          entityId={<%= entityInstance %>.<%= primaryKey.name %> || 0}
          relationshipName="<%= relationshipFieldName %>"
          currentValue={<%= entityInstance %>.<%= relationshipFieldName %>}
          options={relationshipConfigs.find(config => config.name === "<%= relationshipFieldName %>")?.options || []}
          displayField="<%= displayField %>"
          onUpdate={onRelationshipUpdate || (() => Promise.resolve())}
          isEditable={relationshipConfigs.find(config => config.name === "<%= relationshipFieldName %>")?.isEditable || false}
          isLoading={isUpdating}
          className="min-w-[150px]"
          relatedEntityRoute="<%= otherEntityRoute %>"
          showNavigationIcon={true}
        />
      </TableCell>
      <% } %>
      <TableCell className="sticky right-0 bg-gray-50 px-3 py-2 border-l border-gray-200">
        <div className="flex items-center gap-1">
          <InlinePermissionGuard requiredPermission="<%= entityInstance %>:read">
            <Button
              variant="ghost"
              size="sm"
              asChild
              className="h-7 w-7 p-0"
            >
              <Link href={`/<%= entityRoute %>/${<%= entityInstance %>.<%= primaryKey.name %>}`}>
                <Eye className="h-3.5 w-3.5" />
                <span className="sr-only">View</span>
              </Link>
            </Button>
          </InlinePermissionGuard>
          <InlinePermissionGuard requiredPermission="<%= entityInstance %>:update">
            <Button
              variant="ghost"
              size="sm"
              asChild
              className="h-7 w-7 p-0"
            >
              <Link href={`/<%= entityRoute %>/${<%= entityInstance %>.<%= primaryKey.name %>}/edit`}>
                <Pencil className="h-3.5 w-3.5" />
                <span className="sr-only">Edit</span>
              </Link>
            </Button>
          </InlinePermissionGuard>
          <InlinePermissionGuard requiredPermission="<%= entityInstance %>:delete">
            <Button
              variant="ghost"
              size="sm"
              className="h-7 w-7 p-0 text-destructive"
              onClick={() => <%= entityInstance %>.<%= primaryKey.name %> && onDelete(<%= entityInstance %>.<%= primaryKey.name %>)}
              disabled={isDeleting || !<%= entityInstance %>.<%= primaryKey.name %>}
            >
              <Trash2 className="h-3.5 w-3.5" />
              <span className="sr-only">Delete</span>
            </Button>
          </InlinePermissionGuard>
        </div>
      </TableCell>
    </TableRow>
  );
}
</file>

<file path="templates/entity/layout.tsx.ejs">
<%#
 Copyright 2013-2025 the original author or authors from the JHipster project.
-%>
import { ToasterProvider } from "@/components/toaster-provider";

export default function <%= entityClass %>Layout({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    <div className="flex min-h-screen flex-col">
      <main className="flex-1">
        {children}
      </main>
      <ToasterProvider />
    </div>
  );
}
</file>

<file path="templates/entity/new/page.tsx.ejs">
<%#
 Copyright 2013-2025 the original author or authors from the JHipster project.

 This file is part of the JHipster project, see https://www.jhipster.tech/
 for more information.

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

      https://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
-%>
import Link from "next/link";
import { ArrowLeft } from "lucide-react";
import { Button } from "@/components/ui/button";

import { <%= entityClass %>Form } from "../components/<%= entityFileName %>-form";
import { PageHeader } from "@/components/page-header";
import { PageTitle } from "@/components/page-title";
import { PermissionGuard } from "@/components/auth/permission-guard";
import { ContextAwareBackButton } from "@/components/context-aware-back-button";

export const metadata = {
  title: "Create <%= entityClass %>",
};

export default function Create<%= entityClass %>Page() {
  return (
    <PermissionGuard 
      requiredPermission="<%= entityInstance %>:create"
      unauthorizedTitle="Access Denied to Create <%= entityClassHumanized %>"
      unauthorizedDescription="You don't have permission to create new <%= entityClassHumanized.toLowerCase() %> records."
    >
      <div className="space-y-6">
        <div className="flex items-center justify-between">
          <PageHeader>
            <ContextAwareBackButton 
              defaultRoute="/<%= routePath %>"
              defaultLabel="Back to <%= entityClassPluralHumanized %>"
              entityName="<%= entityClass %>"
            />
          </PageHeader>
        </div>

        <div className="bg-white rounded-lg border border-gray-200 p-6 shadow-sm">
          <div className="flex items-center gap-3 mb-6">
            <div className="w-1 h-8 bg-blue-600 rounded-full"></div>
            <div>
              <h1 className="text-2xl font-semibold text-gray-900">Create <%= entityClassHumanized %></h1>
              <p className="text-sm text-gray-600 mt-1">Enter the details below to create a new <%= entityClassHumanized.toLowerCase() %></p>
            </div>
          </div>
          
          <<%= entityClass %>Form />
        </div>
      </div>
    </PermissionGuard>
  );
}
</file>

<file path="templates/entity/page.tsx.ejs">
<%#
 Copyright 2013-2025 the original author or authors from the JHipster project.

 This file is part of the JHipster project, see https://www.jhipster.tech/
 for more information.

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

      https://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
-%>
import { Suspense } from "react";
import { Button } from "@/components/ui/button";
import { Plus, RefreshCw } from "lucide-react";
import Link from "next/link";

import { <%= entityClass %>Table } from "./components/<%= entityFileName %>-table";
import { PageHeader } from "@/components/page-header";
import { PageTitle } from "@/components/page-title";
import { PermissionGuard, InlinePermissionGuard } from "@/components/auth/permission-guard";

export const metadata = {
  title: "<%= entityClassPlural %>",
};

export default function <%= entityClass %>Page() {
  return (
    <PermissionGuard 
      requiredPermission="<%= entityInstance %>:read"
      unauthorizedTitle="Access Denied to <%= entityClassPluralHumanized %>"
      unauthorizedDescription="You don't have permission to view <%= entityClassPluralHumanized.toLowerCase() %>."
    >
      <div className="space-y-4">
        <div className="bg-white rounded-lg border border-gray-200 p-3 shadow-sm">
          <div className="flex items-center justify-between">
            <div className="flex items-center gap-3">
              <div className="w-1 h-6 bg-blue-600 rounded-full"></div>
              <div>
                <h1 className="text-xl font-semibold text-gray-900"><%= entityClassPluralHumanized %></h1>
                <p className="text-xs text-gray-600 mt-0.5">Manage your <%= entityClassPluralHumanized.toLowerCase() %></p>
              </div>
            </div>
            <div className="flex items-center gap-2 shrink-0">
              <Button
                variant="outline"
                size="sm"
                className="h-8 gap-1.5 border-gray-300 hover:bg-gray-50 text-xs"
                aria-label="Refresh List"
              >
                <RefreshCw className="h-3.5 w-3.5" />
                <span className="hidden sm:inline">Refresh</span>
              </Button>
              <InlinePermissionGuard requiredPermission="<%= entityInstance %>:create">
                <Button asChild size="sm" className="h-8 gap-1.5 bg-blue-600 hover:bg-blue-700 text-xs">
                  <Link href="/<%= routePath %>/new">
                    <Plus className="h-3.5 w-3.5" />
                    <span className="hidden sm:inline">Create</span>
                  </Link>
                </Button>
              </InlinePermissionGuard>
            </div>
          </div>
        </div>

        <Suspense fallback={<div>Loading...</div>}>
          <<%= entityClass %>Table />
        </Suspense>
      </div>
    </PermissionGuard>
  );
}
</file>

<file path="tsconfig.json">
{
  "compilerOptions": {
    "target": "es2020",
    "module": "commonjs",
    "esModuleInterop": true,
    "forceConsistentCasingInFileNames": true,
    "strict": true,
    "skipLibCheck": true
  }
}
</file>

</files>
