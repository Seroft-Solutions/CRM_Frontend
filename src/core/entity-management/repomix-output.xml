This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
components/atoms/EntityNoAccess.tsx
components/atoms/index.ts
components/data-table/adapters/index.ts
components/data-table/adapters/storeAdapter.ts
components/data-table/components/index.ts
components/data-table/components/TableContent/index.ts
components/data-table/components/TableContent/TableColumnHeaders.tsx
components/data-table/components/TableContent/TableContent.tsx
components/data-table/components/TableContent/TableEmptyState.tsx
components/data-table/components/TableContent/TableRows.tsx
components/data-table/components/TableControls/index.ts
components/data-table/components/TableControls/TableActions.tsx
components/data-table/components/TableControls/TableControls.tsx
components/data-table/components/TableControls/TableFilters.tsx
components/data-table/components/TableControls/TableSearch.tsx
components/data-table/components/TableHeader/index.ts
components/data-table/components/TableHeader/TableHeader.tsx
components/data-table/components/TablePagination/index.ts
components/data-table/components/TablePagination/TablePagination.tsx
components/data-table/components/TableUtils/BulkActions.tsx
components/data-table/components/TableUtils/index.ts
components/data-table/components/TableUtils/RowActions.tsx
components/data-table/context/TableContext.tsx
components/data-table/EntityDataTable.tsx
components/data-table/hooks/useTableState.ts
components/data-table/index.ts
components/data-table/store.ts
components/entity-form/components/EntityFormActions.tsx
components/entity-form/components/EntityFormContent.tsx
components/entity-form/components/EntityFormDialog.tsx
components/entity-form/components/EntityFormFieldHelp.tsx
components/entity-form/components/EntityFormFooter.tsx
components/entity-form/components/EntityFormHeader.tsx
components/entity-form/components/EntityFormReadOnly.tsx
components/entity-form/components/EntityFormSection.tsx
components/entity-form/components/EntityFormSectionSummary.tsx
components/entity-form/components/EntityFormSheet.tsx
components/entity-form/components/EntityFormSticky.tsx
components/entity-form/components/EntityFormTabProgress.tsx
components/entity-form/components/EntityFormTabs.tsx
components/entity-form/components/EntityFormTabsContainer.tsx
components/entity-form/components/EntityFormTabsNavigation.tsx
components/entity-form/components/FormDebug.tsx
components/entity-form/components/FormUtils.tsx
components/entity-form/components/index.ts
components/entity-form/context/FormContext.tsx
components/entity-form/context/index.ts
components/entity-form/EntityForm.tsx
components/entity-form/hooks/index.ts
components/entity-form/hooks/useFormState.ts
components/entity-form/index.ts
components/EntityManager.tsx
components/ErrorBoundary.tsx
components/form-fields/index.ts
components/form-fields/renderers/CheckboxFieldRenderer.tsx
components/form-fields/renderers/DateFieldRenderer.tsx
components/form-fields/renderers/NumberFieldRenderer.tsx
components/form-fields/renderers/RadioFieldRenderer.tsx
components/form-fields/renderers/SelectFieldRenderer.tsx
components/form-fields/renderers/SwitchFieldRenderer.tsx
components/form-fields/renderers/TextareaFieldRenderer.tsx
components/form-fields/renderers/TextFieldRenderer.tsx
components/index.ts
components/molecules/EntityActionBar.tsx
components/molecules/EntityFormControls.tsx
components/molecules/index.ts
components/organisms/EntityFormDialog.tsx
components/organisms/EntityFormSheet.tsx
components/organisms/EntityTable.tsx
components/organisms/index.ts
components/templates/EntityManagerLayout.tsx
components/templates/index.ts
context/EntityManagerContext.tsx
context/index.ts
hooks/index.ts
hooks/useDependentOptions.ts
hooks/useEntityApi.ts
hooks/useEntityForm.ts
hooks/useEntityManager.ts
hooks/useEntityModal.ts
hooks/useEntityPermissions.ts
hooks/useEntitySync.ts
hooks/useFieldRelationships.ts
hooks/useFormDependencies.ts
hooks/useSafeForm.ts
hooks/useSelectOptions.ts
index.d.ts
index.ts
permissions/index.ts
permissions/PermissionGuard.tsx
permissions/RoleBasedActions.tsx
README.md
services/api/index.ts
services/index.ts
services/permissions/index.ts
services/workflow/index.ts
store/actions.ts
store/core/constants.ts
store/core/types.ts
store/core/validation.ts
store/createStore.ts
store/entityStore.ts
store/index.ts
store/selectors.ts
store/types.ts
test-utils/test-setup.tsx
types/data-table.ts
types/entity-form.ts
types/entity-form/field-relationships.ts
types/entity-manager.ts
types/index.ts
utils/dependent-fields/dependentSchemas.ts
utils/dependent-fields/index.ts
utils/dependent-fields/types.ts
utils/dependent-fields/useDependentFields.ts
utils/field-relationships.ts
utils/fieldValidation.ts
utils/formTransformations.ts
utils/index.ts
utils/logger.ts
utils/responsive.ts
validation/ErrorDisplay.tsx
validation/index.ts
validation/ValidationContext.tsx
validation/validationSchemas.ts
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="components/atoms/EntityNoAccess.tsx">
import React from 'react';

interface EntityNoAccessProps {
  entityNamePlural: string;
}

/**
 * Component displayed when user doesn't have permission to view the entity
 */
export function EntityNoAccess({ entityNamePlural }: EntityNoAccessProps) {
  return (
    <div className="p-8 text-center bg-white dark:bg-gray-950 rounded-lg shadow-sm border border-gray-200 dark:border-gray-800">
      <div className="w-16 h-16 bg-gray-100 dark:bg-gray-900 rounded-full flex items-center justify-center mx-auto mb-4">
        <svg 
          xmlns="http://www.w3.org/2000/svg" 
          width="24" 
          height="24" 
          viewBox="0 0 24 24" 
          fill="none" 
          stroke="currentColor" 
          strokeWidth="2" 
          strokeLinecap="round" 
          strokeLinejoin="round" 
          className="text-gray-500 dark:text-gray-400"
        >
          <path d="M2 11.5a7.5 7.5 0 0 0 15 0 7.5 7.5 0 0 0-15 0Z"/>
          <path d="M14.5 14.5 20 20"/>
          <path d="m15 11-6-6"/>
          <path d="M9 11H3"/>
        </svg>
      </div>
      <h2 className="text-xl font-semibold text-gray-800 dark:text-gray-100">Access Denied</h2>
      <p className="text-gray-500 dark:text-gray-400 mt-2">
        You don't have permission to view {entityNamePlural.toLowerCase()}.
      </p>
    </div>
  );
}
</file>

<file path="components/atoms/index.ts">
export { EntityNoAccess } from './EntityNoAccess';
</file>

<file path="components/data-table/adapters/index.ts">
export { createStoreAdapter } from './storeAdapter';
</file>

<file path="components/data-table/adapters/storeAdapter.ts">
import { EntityStore } from '../../../store';
import { EntityTableStore } from '../store';

/**
 * Creates an adapter that transforms an EntityStore instance into an EntityTableStore
 * This ensures compatibility between the generic entity store and the data table component
 * 
 * @param store The EntityStore instance to adapt
 * @returns An EntityTableStore compatible object
 */
export function createStoreAdapter<TData, TFilter>(store: EntityStore<TData, TFilter>): EntityTableStore<TData> {
  return {
    // Map state properties
    sorting: store.getState().sorting,
    columnFilters: store.getState().columnFilters,
    columnVisibility: store.getState().columnVisibility,
    selectedItems: store.getState().selectedItems,
    isLoading: store.getState().isLoading,
    
    // Map methods
    setSorting: (sorting) => store.setState({ sorting }),
    setColumnFilters: (filters) => store.setState({ columnFilters: filters }),
    setColumnVisibility: (visibility) => store.setState({ columnVisibility: visibility }),
    setSelectedItems: (items) => store.setState({ selectedItems: items }),
    setLoading: (isLoading) => store.setState({ isLoading })
  };
}
</file>

<file path="components/data-table/components/index.ts">
export * from './TableHeader';
export * from './TableControls';
export * from './TableContent';
export * from './TablePagination';
export * from './TableUtils';
</file>

<file path="components/data-table/components/TableContent/index.ts">
export * from './TableContent';
export * from './TableColumnHeaders';
export * from './TableRows';
export * from './TableEmptyState';
</file>

<file path="components/data-table/components/TableContent/TableColumnHeaders.tsx">
import React from 'react';
import { TableHeader, TableRow, TableHead } from "@/components/ui/table";
import { cn } from "@/lib/utils";
import { useTableContext } from '../../context/TableContext';

export interface TableColumnHeadersProps {
  className?: string;
}

export const TableColumnHeaders: React.FC<TableColumnHeadersProps> = ({ className }) => {
  const { table, renderHeaderCell } = useTableContext();

  return (
    <TableHeader>
      {table.getHeaderGroups().map((headerGroup) => (
        <TableRow key={headerGroup.id} className="bg-gray-100/80 dark:bg-gray-800/90 border-b border-gray-200 dark:border-gray-700">
          {headerGroup.headers.map((header) => (
            <TableHead
              key={header.id}
              className={cn(
                "h-11 px-4 text-xs font-bold text-gray-600 dark:text-gray-300 uppercase tracking-wider",
                header.column.id === "actions" && "text-right pr-6 w-[120px]",
                header.column.id === "select" && "w-[50px]"
              )}
            >
              {renderHeaderCell(header)}
            </TableHead>
          ))}
        </TableRow>
      ))}
    </TableHeader>
  );
};
</file>

<file path="components/data-table/components/TableContent/TableContent.tsx">
import React from 'react';
import { Table, TableBody } from "@/components/ui/table";
import { TableColumnHeaders } from './TableColumnHeaders';
import { TableRows } from './TableRows';
import { TableEmptyState } from './TableEmptyState';
import { useTableContext } from '../../context/TableContext';

export interface TableContentProps {
  className?: string;
}

export const TableContent: React.FC<TableContentProps> = ({ className }) => {
  const { table, isLoading, data } = useTableContext();

  const hasRows = table.getRowModel().rows?.length > 0;

  return (
    <div className="rounded-md border border-gray-200 dark:border-gray-800 overflow-auto">
      {/* Responsive table with horizontal scrolling on mobile */}
      <div className="w-full overflow-auto">
        <Table>
          <TableColumnHeaders />
          <TableBody>
            {hasRows ? (
              <TableRows />
            ) : (
              <TableEmptyState />
            )}
          </TableBody>
        </Table>
      </div>
      
      {/* Mobile-friendly indicator when table is scrollable */}
      <div className="md:hidden text-xs text-center text-gray-500 dark:text-gray-400 py-1 border-t border-gray-200 dark:border-gray-800">
        {hasRows && data && data.length > 0 && (
          <span>Swipe to see more columns →</span>
        )}
      </div>
    </div>
  );
};
</file>

<file path="components/data-table/components/TableContent/TableEmptyState.tsx">
import React from 'react';
import { TableRow, TableCell } from "@/components/ui/table";
import { Loader2, Search, UserRound, AlertCircle } from "lucide-react";
import { Button } from "@/components/ui/button";
import { useTableContext } from '../../context/TableContext';

export interface TableEmptyStateProps {
  className?: string;
}

export const TableEmptyState: React.FC<TableEmptyStateProps> = ({ className }) => {
  const { isLoading, table } = useTableContext();
  
  // Get the column count for colSpan
  const columnCount = table.getAllColumns().length;

  if (isLoading) {
    return (
      <TableRow>
        <TableCell
          colSpan={columnCount}
          className="h-72 text-center"
        >
          <div className="flex flex-col items-center justify-center h-full">
            <Loader2 className="h-8 w-8 animate-spin text-primary" />
            <span className="text-sm text-gray-500 mt-4 block">
              Loading data...
            </span>
          </div>
        </TableCell>
      </TableRow>
    );
  }

  // Get table props to check if this is the users table
  const { error, onAdd } = useTableContext();
  
  // If there's an error, show error state
  if (error) {
    return (
      <TableRow>
        <TableCell
          colSpan={columnCount}
          className="h-72 text-center"
        >
          <div className="flex flex-col items-center justify-center h-full">
            <div className="rounded-full bg-red-100 dark:bg-red-900 p-4">
              <AlertCircle className="h-6 w-6 text-red-500" />
            </div>
            <span className="text-base font-medium text-gray-700 dark:text-gray-300 mt-4 block">
              Error loading data
            </span>
            <span className="text-sm text-gray-500 dark:text-gray-400 mb-4">
              {error.message || 'Something went wrong. Please try again.'}
            </span>
            <Button 
              variant="outline"
              onClick={() => window.location.reload()}
            >
              Retry
            </Button>
          </div>
        </TableCell>
      </TableRow>
    );
  }
  
  // Empty state when no data is available
  return (
    <TableRow>
      <TableCell
        colSpan={columnCount}
        className="h-72 text-center"
      >
        <div className="flex flex-col items-center justify-center h-full">
          <div className="rounded-full bg-gray-100 dark:bg-gray-800 p-4">
            <UserRound className="h-6 w-6 text-gray-400" />
          </div>
          <span className="text-base font-medium text-gray-700 dark:text-gray-300 mt-4 block">
            No results found
          </span>
          <span className="text-sm text-gray-500 dark:text-gray-400 max-w-md mb-4">
            Try adjusting your search or filter to find what you're looking for, or add a new user using the button below.
          </span>
          {onAdd && (
            <Button onClick={() => onAdd()}>
              Add New
            </Button>
          )}
        </div>
      </TableCell>
    </TableRow>
  );
};
</file>

<file path="components/data-table/components/TableContent/TableRows.tsx">
import React from 'react';
import { TableRow, TableCell } from "@/components/ui/table";
import { cn } from "@/lib/utils";
import { flexRender } from "@tanstack/react-table";
import { useTableContext } from '../../context/TableContext';

export interface TableRowsProps {
  className?: string;
}

export const TableRows: React.FC<TableRowsProps> = ({ className }) => {
  const { 
    table, 
    enableRowClick, 
    handleRowClick
  } = useTableContext();

  return (
    <>
      {table.getRowModel().rows.map((row, index) => (
        <TableRow
          key={row.id}
          className={cn(
            "h-12 transition-colors",
            index % 2 === 0 ? "bg-white dark:bg-gray-950" : "bg-gray-50 dark:bg-gray-900",
            enableRowClick && "cursor-pointer hover:bg-gray-100 dark:hover:bg-gray-800",
            !enableRowClick && "hover:bg-gray-100 dark:hover:bg-gray-800"
          )}
          data-state={row.getIsSelected() && "selected"}
          onClick={(e) => handleRowClick(e, row)}
        >
          {row.getVisibleCells().map((cell) => (
            <TableCell
              key={cell.id}
              className="px-4 py-2 text-sm text-gray-700 dark:text-gray-300"
            >
              {flexRender(
                cell.column.columnDef.cell,
                cell.getContext()
              )}
            </TableCell>
          ))}
        </TableRow>
      ))}
    </>
  );
};
</file>

<file path="components/data-table/components/TableControls/index.ts">
export * from './TableControls';
export * from './TableSearch';
export * from './TableFilters';
export * from './TableActions';
</file>

<file path="components/data-table/components/TableControls/TableActions.tsx">
import React from 'react';
import { Button } from "@/components/ui/button";
import { Download, Plus, Settings2 } from "lucide-react";
import {
  DropdownMenu,
  DropdownMenuCheckboxItem,
  DropdownMenuContent,
  DropdownMenuLabel,
  DropdownMenuSeparator,
  DropdownMenuTrigger,
} from "@/components/ui/dropdown-menu";
import { useTableContext } from '../../context/TableContext';

export interface TableActionsProps {
  className?: string;
}

export const TableActions: React.FC<TableActionsProps> = ({ className }) => {
  const { 
    onAdd, 
    onExport, 
    addPermission, 
    hasRole, 
    table 
  } = useTableContext();

  // Wrap the onAdd function to prevent infinite loops
  const handleAddClick = React.useCallback((e: React.MouseEvent) => {
    // Prevent event bubbling
    e.preventDefault();
    e.stopPropagation();
    
    // Use requestAnimationFrame and setTimeout to break potential update cycles
    requestAnimationFrame(() => {
      setTimeout(() => {
        // Now it's safe to call onAdd
        if (onAdd) onAdd();
      }, 0);
    });
  }, [onAdd]);

  return (
    <div className="flex items-center gap-2">
      {onAdd && (!addPermission || hasRole(addPermission.feature, addPermission.action)) && (
        <Button
          variant="default"
          size="sm"
          onClick={handleAddClick}
          className="h-9 bg-primary hover:bg-primary/90 text-white transition-colors shadow-sm"
        >
          <Plus className="mr-2 h-4 w-4"/>
          Add New
        </Button>
      )}
      {onExport && (
        <Button
          variant="outline"
          size="sm"
          onClick={onExport}
          className="h-9 border border-gray-200 dark:border-gray-700"
        >
          <Download className="mr-2 h-4 w-4"/>
          Export
        </Button>
      )}
      <DropdownMenu>
        <DropdownMenuTrigger asChild>
          <Button variant="outline" size="sm" className="h-9 border border-gray-200 dark:border-gray-700">
            <Settings2 className="mr-2 h-4 w-4"/>
            View
          </Button>
        </DropdownMenuTrigger>
        <DropdownMenuContent align="end" className="w-[150px]">
          <DropdownMenuLabel>Toggle columns</DropdownMenuLabel>
          <DropdownMenuSeparator/>
          {table
            .getAllColumns()
            .filter(
              (column) =>
                typeof column.accessorFn !== "undefined" && column.getCanHide()
            )
            .map((column) => {
              return (
                <DropdownMenuCheckboxItem
                  key={column.id}
                  className="capitalize"
                  checked={column.getIsVisible()}
                  onCheckedChange={(value) =>
                    column.toggleVisibility(!!value)
                  }
                >
                  {column.id}
                </DropdownMenuCheckboxItem>
              );
            })}
        </DropdownMenuContent>
      </DropdownMenu>
    </div>
  );
};
</file>

<file path="components/data-table/components/TableControls/TableControls.tsx">
import React from 'react';
import { TableSearch } from './TableSearch';
import { TableFilters } from './TableFilters';
import { TableActions } from './TableActions';
import { useTableContext } from '../../context/TableContext';

export interface TableControlsProps {
  className?: string;
}

export const TableControls: React.FC<TableControlsProps> = ({ className }) => {
  const { searchableColumns, filterableColumns, onAdd, onExport } = useTableContext();
  
  // Determine if we need to show the search and filters section at all
  const showSearchFilters = (searchableColumns && searchableColumns.length > 0) || 
                            (filterableColumns && filterableColumns.length > 0);
  
  // Determine if we need to show the actions section
  const showActions = onAdd || onExport;
  
  // Apply more responsive styling
  return (
    <div className={`
      flex flex-col gap-4 
      sm:items-center 
      ${showSearchFilters && showActions ? 'lg:flex-row lg:justify-between' : ''}
      rounded-lg bg-gray-50/80 dark:bg-gray-900/50 p-4 
      border border-gray-100 dark:border-gray-800
    `}>
      {/* Search and Filters */}
      {showSearchFilters && (
        <div className="flex flex-col sm:flex-row w-full sm:flex-wrap sm:items-center gap-2">
          <TableSearch />
          <TableFilters />
        </div>
      )}

      {/* Table Actions */}
      {showActions && (
        <div className="flex self-start sm:self-auto">
          <TableActions />
        </div>
      )}
    </div>
  );
};
</file>

<file path="components/data-table/components/TableControls/TableFilters.tsx">
import React from 'react';
import { Button } from "@/components/ui/button";
import { ListFilter, X } from "lucide-react";
import { cn } from "@/lib/utils";
import {
  DropdownMenu,
  DropdownMenuCheckboxItem,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuLabel,
  DropdownMenuSeparator,
  DropdownMenuTrigger,
} from "@/components/ui/dropdown-menu";
import {
  Select,
  SelectContent,
  SelectGroup,
  SelectItem,
  SelectTrigger,
  SelectValue
} from "@/components/ui/select";
import { useTableContext } from '../../context/TableContext';

export interface TableFiltersProps {
  className?: string;
}

export const TableFilters: React.FC<TableFiltersProps> = ({ className }) => {
  const { 
    filterableColumns, 
    table, 
    handleFilterChange, 
    columnFilters,
    activeFiltersCount,
    activeSearch,
    searchColumn
  } = useTableContext();

  // If there are no filterable columns, don't render anything
  if (!filterableColumns || filterableColumns.length === 0) {
    return null;
  }

  // Function to check if a column has an active filter that isn't from search
  const hasActiveFilter = (columnId: string) => {
    const filter = table.getColumn(columnId)?.getFilterValue();
    // Exclude the filter if it's from the active search
    if (activeSearch && activeSearch.column === columnId && activeSearch.query === filter) {
      return false;
    }
    return !!filter;
  };

  return (
    <DropdownMenu>
      <DropdownMenuTrigger asChild>
        <Button variant="outline" size="sm" className={cn(
          "h-9 border border-gray-200 dark:border-gray-700 transition-all relative",
          activeFiltersCount > 0 && "border-primary/50 text-primary bg-primary/5 hover:bg-primary/10"
        )}>
          <ListFilter className="mr-2 h-4 w-4"/>
          Filters
          {activeFiltersCount > 0 && (
            <span className="ml-1 flex h-5 w-5 items-center justify-center rounded-full bg-primary text-[10px] font-medium text-white">
              {activeFiltersCount}
            </span>
          )}
        </Button>
      </DropdownMenuTrigger>
      <DropdownMenuContent align="start" className="w-[280px] p-2 shadow-md border border-gray-100 dark:border-gray-800 rounded-lg bg-white dark:bg-gray-950 animate-in fade-in-0 zoom-in-95">
        <div className="flex items-center justify-between px-2 py-1.5">
          <DropdownMenuLabel className="text-sm font-medium text-gray-700 dark:text-gray-300 py-0 m-0">Filter by</DropdownMenuLabel>
          {activeFiltersCount > 0 && (
            <Button 
              variant="ghost" 
              size="sm" 
              onClick={(e) => {
                e.stopPropagation();
                // Reset all filters except the active search filter
                if (activeSearch) {
                  const searchFilter = columnFilters.find(
                    filter => filter.id === activeSearch.column && filter.value === activeSearch.query
                  );
                  table.resetColumnFilters();
                  if (searchFilter) {
                    table.getColumn(searchFilter.id)?.setFilterValue(searchFilter.value);
                  }
                } else {
                  table.resetColumnFilters();
                }
                
                // Close the dropdown after clearing all filters
                const closeEvent = new MouseEvent('click', {
                  bubbles: true,
                  cancelable: true,
                  view: window
                });
                setTimeout(() => document.dispatchEvent(closeEvent), 100);
              }} 
              className="h-8 px-2 text-xs text-gray-500 hover:text-gray-700 dark:text-gray-400 dark:hover:text-gray-300 -mr-1"
            >
              Clear all
            </Button>
          )}
        </div>
        <DropdownMenuSeparator className="my-1 -mx-2"/>
        {filterableColumns.map((column) => (
          <DropdownMenuItem key={column.id} className="p-2 focus:bg-gray-50 dark:focus:bg-gray-900 focus:outline-none cursor-default hover:bg-transparent" onSelect={(e) => e.preventDefault()}>
            <div className="flex flex-col gap-2 w-full">
              <label className="text-sm font-medium text-gray-700 dark:text-gray-300 mb-1.5 block flex items-center justify-between">
                {column.title}
                {hasActiveFilter(column.id) && (
                  <Button 
                    variant="ghost" 
                    size="sm" 
                    onClick={(e) => {
                      e.stopPropagation();
                      handleFilterChange(column.id, "__all__");
                      // Close the dropdown after clearing
                      const closeEvent = new MouseEvent('click', {
                        bubbles: true,
                        cancelable: true,
                        view: window
                      });
                      setTimeout(() => document.dispatchEvent(closeEvent), 100);
                    }} 
                    className="h-6 w-6 p-0 rounded-full hover:bg-gray-100 dark:hover:bg-gray-800"
                  >
                    <X className="h-3 w-3 text-gray-500" />
                  </Button>
                )}
              </label>
              <Select
                value={(table.getColumn(column.id)?.getFilterValue() as string) ?? ""}
                onValueChange={(value) => {
                  handleFilterChange(column.id, value);
                  // Close the dropdown menu after selection
                  const closeEvent = new MouseEvent('click', {
                    bubbles: true,
                    cancelable: true,
                    view: window
                  });
                  setTimeout(() => document.dispatchEvent(closeEvent), 100);
                }}
              >
                <SelectTrigger className="h-9 border border-gray-200 dark:border-gray-700 bg-white dark:bg-gray-900 rounded-md">
                  <SelectValue placeholder={`All ${column.title.toLowerCase()}`}/>
                </SelectTrigger>
                <SelectContent className="max-h-[240px] overflow-y-auto p-1 rounded-md shadow-md">
                  <SelectItem value="__all__" className="text-sm text-gray-700 dark:text-gray-300">
                    All {column.title.toLowerCase()}
                  </SelectItem>
                  {column.options.map((option) => (
                    <SelectItem key={option.value} value={option.value} className="text-sm text-gray-700 dark:text-gray-300">
                      {option.label}
                    </SelectItem>
                  ))}
                </SelectContent>
              </Select>
            </div>
          </DropdownMenuItem>
        ))}
      </DropdownMenuContent>
    </DropdownMenu>
  );
};
</file>

<file path="components/data-table/components/TableControls/TableSearch.tsx">
import React, { useEffect } from 'react';
import { Input } from "@/components/ui/input";
import { Button } from "@/components/ui/button";
import { Search, X } from "lucide-react";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue
} from "@/components/ui/select";
import { useTableContext } from '../../context/TableContext';

export interface TableSearchProps {
  className?: string;
}

export const TableSearch: React.FC<TableSearchProps> = ({ className }) => {
  const { 
    searchableColumns, 
    searchQuery, 
    setSearchQuery, 
    searchColumn, 
    setSearchColumn, 
    handleSearch, 
    resetSearch 
  } = useTableContext();

  // If there are no searchable columns, don't render anything
  if (!searchableColumns || searchableColumns.length === 0) {
    return null;
  }

  return (
    <div className="flex gap-2">
      {searchableColumns.length > 1 && (
        <Select
          value={searchColumn}
          onValueChange={(value) => {
            setSearchColumn(value);
            // Clear the search when changing columns
            if (searchQuery) {
              setSearchQuery('');
              resetSearch();
            }
          }}
        >
          <SelectTrigger className="h-9 w-[140px] border border-gray-200 dark:border-gray-700 bg-white dark:bg-gray-900 rounded-l-md rounded-r-none">
            <SelectValue placeholder="Select column" />
          </SelectTrigger>
          <SelectContent className="max-h-[240px] overflow-y-auto p-1 rounded-md shadow-md">
            {searchableColumns.map((column) => (
              <SelectItem key={column.id} value={column.id} className="text-sm text-gray-700 dark:text-gray-300">
                {column.title}
              </SelectItem>
            ))}
          </SelectContent>
        </Select>
      )}
      
      <div className="flex">
        <Input
          placeholder="Search..."
          value={searchQuery}
          onChange={(e) => setSearchQuery(e.target.value)}
          className="h-9 w-[180px] lg:w-[280px] rounded-r-none border border-gray-200 dark:border-gray-700 bg-white dark:bg-gray-900"
          onKeyDown={(e) => {
            if (e.key === 'Enter') {
              handleSearch();
            }
          }}
        />
        <Button 
          variant="default" 
          size="sm" 
          onClick={handleSearch}
          className="h-9 rounded-l-none rounded-r-md bg-primary hover:bg-primary/90 text-white shadow-sm"
        >
          <Search className="h-4 w-4" />
        </Button>
      </div>
      
      {searchQuery && (
        <Button
          variant="ghost"
          size="sm"
          onClick={resetSearch}
          className="h-9 px-3 text-gray-500 hover:text-gray-700 dark:text-gray-400 hover:bg-gray-100 dark:hover:bg-gray-800 ml-1 rounded-md"
        >
          Clear
        </Button>
      )}
    </div>
  );
};
</file>

<file path="components/data-table/components/TableHeader/index.ts">
export * from './TableHeader';
</file>

<file path="components/data-table/components/TableHeader/TableHeader.tsx">
import React from 'react';
import {
  CardHeader,
  CardTitle,
  CardDescription
} from "@/components/ui/card";
import { useTableContext } from '../../context/TableContext';

export interface TableHeaderProps {
  className?: string;
}

export const TableHeader: React.FC<TableHeaderProps> = ({ className }) => {
  const { title, description } = useTableContext();
  
  // If there's no title or description, don't render anything
  if (!title && !description) {
    return null;
  }
  
  return (
    <CardHeader className="bg-gray-50 dark:bg-gray-900 border-b pb-4">
      {title && <CardTitle className="text-xl font-semibold text-gray-800 dark:text-gray-100">{title}</CardTitle>}
      {description && <CardDescription className="text-gray-500 dark:text-gray-400">{description}</CardDescription>}
    </CardHeader>
  );
};
</file>

<file path="components/data-table/components/TablePagination/index.ts">
export * from './TablePagination';
</file>

<file path="components/data-table/components/TablePagination/TablePagination.tsx">
import React from 'react';
import { Button } from "@/components/ui/button";
import { ChevronLeft, ChevronRight, ChevronsLeft, ChevronsRight } from "lucide-react";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue
} from "@/components/ui/select";
import { useTableContext } from '../../context/TableContext';

export interface TablePaginationProps {
  className?: string;
}

export const TablePagination: React.FC<TablePaginationProps> = ({ className }) => {
  const { 
    table, 
    isServerSide, 
    totalItems,
    defaultPageSize,
    enableMultiSelect,
    onPageSizeChange
  } = useTableContext();

  return (
    <div className="border-t border-gray-200 dark:border-gray-800 bg-white dark:bg-gray-950 sticky bottom-0 p-4 shadow-sm rounded-b-lg">
      <div className="flex items-center justify-between gap-2">
        <div className="flex items-center gap-2">
          <p className="text-sm text-gray-500 dark:text-gray-400">
            Showing <span className="font-medium text-gray-700 dark:text-gray-300">{table.getFilteredRowModel().rows.length}</span> of <span className="font-medium text-gray-700 dark:text-gray-300">{totalItems || table.getCoreRowModel().rows.length}</span> items
          </p>
          {enableMultiSelect && (
            <div className="ml-2 flex items-center text-sm">
              <span className="text-gray-500 dark:text-gray-400 mr-1">Selected:</span>
              <span className="font-medium text-gray-700 dark:text-gray-300">
                {table.getFilteredSelectedRowModel().rows.length}
              </span>
            </div>
          )}
        </div>
        
        <div className="flex items-center gap-2">
          <div className="flex w-auto items-center text-sm text-gray-500 dark:text-gray-400">
            <span className="hidden md:inline mr-1">Items per page:</span>
            <span className="md:hidden mr-1">Per page:</span>
            <Select
              value={String(table.getState().pagination.pageSize)}
              onValueChange={(value) => {
                const size = Number(value);
                table.setPageSize(size);
                if (isServerSide && onPageSizeChange) {
                  onPageSizeChange(size);
                }
              }}
            >
              <SelectTrigger className="h-8 w-[60px] border border-gray-200 dark:border-gray-700 text-gray-700 dark:text-gray-300 font-medium">
                <SelectValue placeholder={defaultPageSize}/>
              </SelectTrigger>
              <SelectContent side="top" className="max-h-[300px] overflow-y-auto p-1">
                {[10, 20, 30, 40, 50].map((pageSize) => (
                  <SelectItem key={pageSize} value={pageSize.toString()}>
                    {pageSize}
                  </SelectItem>
                ))}
              </SelectContent>
            </Select>
          </div>
          <div className="flex w-auto items-center justify-center text-sm text-gray-500 dark:text-gray-400 mx-2">
            Page <span className="font-medium text-gray-700 dark:text-gray-300 mx-1">{table.getState().pagination.pageIndex + 1}</span> of <span className="font-medium text-gray-700 dark:text-gray-300 mx-1">
              {isServerSide ? 
                Math.max(1, Math.ceil((totalItems || 0) / table.getState().pagination.pageSize)) : 
                Math.max(1, table.getPageCount())}
            </span>
          </div>
          <div className="flex items-center gap-1">
            <Button
              variant="outline"
              size="sm"
              className="h-8 w-8 p-0 border border-gray-200 dark:border-gray-700 hover:bg-gray-50 dark:hover:bg-gray-800"
              onClick={() => table.setPageIndex(0)}
              disabled={!table.getCanPreviousPage()}
            >
              <span className="sr-only">Go to first page</span>
              <ChevronsLeft className="h-4 w-4"/>
            </Button>
            <Button
              variant="outline"
              size="sm"
              className="h-8 w-8 p-0 border border-gray-200 dark:border-gray-700 hover:bg-gray-50 dark:hover:bg-gray-800"
              onClick={() => table.previousPage()}
              disabled={!table.getCanPreviousPage()}
            >
              <span className="sr-only">Go to previous page</span>
              <ChevronLeft className="h-4 w-4"/>
            </Button>
            <Button
              variant="outline"
              size="sm"
              className="h-8 w-8 p-0 border border-gray-200 dark:border-gray-700 hover:bg-gray-50 dark:hover:bg-gray-800"
              onClick={() => table.nextPage()}
              disabled={!table.getCanNextPage()}
            >
              <span className="sr-only">Go to next page</span>
              <ChevronRight className="h-4 w-4"/>
            </Button>
            <Button
              variant="outline"
              size="sm"
              className="h-8 w-8 p-0 border border-gray-200 dark:border-gray-700 hover:bg-gray-50 dark:hover:bg-gray-800"
              onClick={() => table.setPageIndex(table.getPageCount() - 1)}
              disabled={!table.getCanNextPage()}
            >
              <span className="sr-only">Go to last page</span>
              <ChevronsRight className="h-4 w-4"/>
            </Button>
          </div>
        </div>
      </div>
    </div>
  );
};
</file>

<file path="components/data-table/components/TableUtils/BulkActions.tsx">
import React from 'react';
import { Users } from "lucide-react";
import {
  Select,
  SelectContent,
  SelectGroup,
  SelectItem,
  SelectTrigger,
  SelectValue
} from "@/components/ui/select";
import { BulkAction } from '../../../../types/data-table';
import { useTableContext } from '../../context/TableContext';
import { UserCircle2 } from 'lucide-react';

export interface BulkActionsProps<TData> {
  bulkAction: BulkAction<TData>;
  column: string;
  selectedCount: number;
  className?: string;
}

export function BulkActions<TData>({ 
  bulkAction, 
  column, 
  selectedCount, 
  className 
}: BulkActionsProps<TData>) {
  const { table, setRowSelection } = useTableContext<TData>();

  return (
    <div className="min-w-[250px]">
      <Select
        onValueChange={async (value) => {
          if (value && bulkAction) {
            const selectedRows = table
              .getSelectedRowModel()
              .rows.map((row) => row.original);
            await bulkAction.onUpdate(selectedRows, value);
            setRowSelection({});
          }
        }}
      >
        <SelectTrigger className="h-9 w-full bg-blue-50 border-blue-200 hover:bg-blue-100 transition-colors">
          <div className="flex items-center gap-2 text-blue-700">
            <Users className="h-4 w-4"/>
            <span className="font-medium">
              Assign {selectedCount} selected
            </span>
          </div>
        </SelectTrigger>
        <SelectContent className="max-h-[300px]">
          <div className="px-2 py-1.5">
            <h4 className="text-sm font-medium text-gray-900 mb-0.5">
              Select Assignee
            </h4>
            <p className="text-xs text-gray-500">
              {selectedCount} items will be assigned
            </p>
          </div>
          <SelectGroup>
            {bulkAction?.options.map((option) => (
              <SelectItem
                key={option.value}
                value={option.value}
                className="flex items-center gap-2 py-2"
              >
                <div className="flex items-center gap-2 text-sm">
                  <div className="h-6 w-6 rounded-full bg-blue-100 flex items-center justify-center">
                    <UserCircle2 className="h-4 w-4 text-blue-600"/>
                  </div>
                  {option.label}
                </div>
              </SelectItem>
            ))}
          </SelectGroup>
        </SelectContent>
      </Select>
    </div>
  );
}
</file>

<file path="components/data-table/components/TableUtils/index.ts">
export * from './RowActions';
export * from './BulkActions';
</file>

<file path="components/data-table/components/TableUtils/RowActions.tsx">
import React from 'react';
import { Button } from "@/components/ui/button";
import { cn } from "@/lib/utils";
import { useTableContext } from '../../context/TableContext';
import { Row } from '@tanstack/react-table';
import { Lock } from "lucide-react";
import {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger
} from "@/components/ui/tooltip";
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
  AlertDialogTrigger
} from "@/components/ui/alert-dialog";

export interface RowActionsProps<TData> {
  row: Row<TData>;
  className?: string;
}

export function RowActions<TData>({ row, className }: RowActionsProps<TData>) {
  const { actions, hasRole } = useTableContext<TData>();

  // If no actions, return null
  if (!actions || actions.length === 0) {
    return null;
  }

  return (
    <div className="flex justify-end gap-1" data-action-cell="true">
      {actions.map((action, index) => {
        // Check permissions
        const hasPermission = !action.permission || hasRole(action.permission.feature, action.permission.action);
        
        // Check if action should be shown based on row data
        const isVisible = !action.showWhen || action.showWhen(row.original);
        
        // If action shouldn't be visible at all, skip it
        if (!isVisible) {
          return null;
        }
        
        // Check if action is disabled
        const isDisabled = typeof action.disabled === 'function'
          ? action.disabled(row.original)
          : action.disabled;

        // If no permission, show locked button
        if (!hasPermission) {
          return (
            <TooltipProvider key={index}>
              <Tooltip>
                <TooltipTrigger asChild>
                  <Button
                    variant="ghost"
                    size="sm"
                    disabled
                    className="h-8 w-8 p-0 rounded-full hover:bg-gray-100 dark:hover:bg-gray-800 transition-colors opacity-50"
                  >
                    <Lock className="h-4 w-4 text-gray-400" />
                    <span className="sr-only">{action.label} (No Permission)</span>
                  </Button>
                </TooltipTrigger>
                <TooltipContent>
                  <p>You don't have permission for this action</p>
                </TooltipContent>
              </Tooltip>
            </TooltipProvider>
          );
        }

        const ActionButton = ({onClick}: { onClick: (e: React.MouseEvent<HTMLButtonElement>) => void }) => (
          <TooltipProvider>
            <Tooltip>
              <TooltipTrigger asChild>
                <Button
                  variant={action.variant || "ghost"}
                  size="sm"
                  onClick={onClick}
                  disabled={isDisabled}
                  className={cn(
                    "h-8 w-8 p-0 rounded-full hover:bg-gray-100 dark:hover:bg-gray-800 hover:text-primary transition-colors",
                    action.variant === 'destructive' && "hover:bg-red-100 dark:hover:bg-red-900/20 hover:text-red-600 dark:hover:text-red-400",
                    action.className
                  )}
                >
                  {action.icon}
                  <span className="sr-only">{action.label}</span>
                </Button>
              </TooltipTrigger>
              <TooltipContent>
                <p>{action.tooltip || action.label}</p>
              </TooltipContent>
            </Tooltip>
          </TooltipProvider>
        );

        if (action.showConfirm) {
          return (
            <AlertDialog key={index}>
              <AlertDialogTrigger asChild>
                <ActionButton onClick={(e) => {
                  // Stop the click event from propagating to the row
                  e.stopPropagation();
                }}/>
              </AlertDialogTrigger>
              <AlertDialogContent>
                <AlertDialogHeader>
                  <AlertDialogTitle>{action.confirmTitle}</AlertDialogTitle>
                  <AlertDialogDescription>
                    {action.confirmDescription}
                  </AlertDialogDescription>
                </AlertDialogHeader>
                <AlertDialogFooter>
                  <AlertDialogCancel onClick={(e) => e.stopPropagation()}>Cancel</AlertDialogCancel>
                  <AlertDialogAction
                    onClick={(e) => {
                      // Prevent event propagation to avoid triggering row click
                      e.stopPropagation();
                      // Call the action's onClick handler
                      action.onClick(row.original);
                    }}
                  >
                    {action.confirmActionLabel || 'Continue'}
                  </AlertDialogAction>
                </AlertDialogFooter>
              </AlertDialogContent>
            </AlertDialog>
          );
        }

        return (
          <ActionButton
            key={index}
            onClick={(e) => {
              // Prevent event propagation to avoid triggering row click
              e.stopPropagation();
              // Call the action's onClick handler
              action.onClick(row.original);
            }}
          />
        );
      })}
    </div>
  );
}
</file>

<file path="components/data-table/context/TableContext.tsx">
import React, { createContext, useContext, useMemo, ReactNode } from 'react';
import { 
  ColumnFiltersState, 
  SortingState, 
  VisibilityState, 
  Table,
  Row,
  Header
} from '@tanstack/react-table';
import { 
  FilterableColumn, 
  SearchableColumn, 
  Action, 
  BulkAction,
  FilterInfo,
  SortInfo
} from '../../../types/data-table';
import { useAuth } from '@/features/core/auth';

/**
 * TableContext provides shared state and handlers for the EntityDataTable components
 */
export interface TableContextValue<TData = any, TValue = any> {
  // Table instance and core properties
  table: Table<TData>;
  data: TData[];
  
  // Table state
  sorting: SortingState;
  setSorting: React.Dispatch<React.SetStateAction<SortingState>>;
  columnFilters: ColumnFiltersState;
  setColumnFilters: React.Dispatch<React.SetStateAction<ColumnFiltersState>>;
  columnVisibility: VisibilityState;
  setColumnVisibility: React.Dispatch<React.SetStateAction<VisibilityState>>;
  rowSelection: Record<string, boolean>;
  setRowSelection: React.Dispatch<React.SetStateAction<Record<string, boolean>>>;
  
  // Search state
  searchQuery: string;
  setSearchQuery: React.Dispatch<React.SetStateAction<string>>;
  searchColumn: string;
  setSearchColumn: React.Dispatch<React.SetStateAction<string>>;
  activeSearch: {column: string, query: string} | null;
  
  // Config
  columns: SearchableColumn[];
  filterableColumns: FilterableColumn[];
  searchableColumns: SearchableColumn[];
  actions: Action<TData>[];
  bulkActions: BulkAction<TData>[];
  
  // Flags
  isLoading: boolean;
  isServerSide: boolean;
  enableMultiSelect: boolean;
  enableRowClick: boolean | ((event: React.MouseEvent<HTMLTableRowElement>) => boolean);
  
  // Handlers
  handleSearch: () => void;
  resetSearch: () => void;
  handleFilterChange: (columnId: string, value: any) => void;
  handleSortingChange: (updatedSorting: SortingState) => void;
  handleRowClick: (e: React.MouseEvent<HTMLTableRowElement>, row: Row<TData>) => void;
  renderHeaderCell: (header: Header<TData, unknown>) => React.ReactNode;
  hasRole: (feature: string, action: string) => boolean;
  
  // UI indicators
  activeFiltersCount: number;
  
  // Callback functions
  onRowClick?: (row: TData) => void;
  onSelectionChange?: (selectedRows: TData[]) => void;
  onAdd?: () => void;
  onExport?: () => void;
  
  // Pagination
  defaultPageSize: number;
  totalItems?: number;
  pageCount?: number;
  currentPage: number;
  
  // Server-side callbacks
  onPageChange?: (page: number) => void;
  onPageSizeChange?: (pageSize: number) => void;
  onSortingChange?: (columnId: string, direction: 'asc' | 'desc' | undefined) => void;
  onFilterChange?: (columnId: string, value: string) => void;
  onSearchChange?: (columnId: string, value: string) => void;
  
  // UI Properties
  title?: string;
  description?: string;
  addPermission?: { feature: string; action: string };
}

// Create the context with a default empty value
export const TableContext = createContext<TableContextValue | undefined>(undefined);

// Provider component
export interface TableContextProviderProps<TData = any, TValue = any> {
  children: ReactNode;
  value: Omit<TableContextValue<TData, TValue>, 'hasRole'>;
}

export function TableContextProvider<TData, TValue>({ 
  children, 
  value 
}: TableContextProviderProps<TData, TValue>) {
  const { hasRole } = useAuth();
  
  const contextValue = useMemo(() => ({
    ...value,
    hasRole
  }), [value, hasRole]);
  
  return (
    <TableContext.Provider value={contextValue as TableContextValue}>
      {children}
    </TableContext.Provider>
  );
}

// Custom hook to consume the context
export function useTableContext<TData = any, TValue = any>() {
  const context = useContext(TableContext);
  
  if (context === undefined) {
    throw new Error('useTableContext must be used within a TableContextProvider');
  }
  
  return context as TableContextValue<TData, TValue>;
}
</file>

<file path="components/data-table/EntityDataTable.tsx">
import React, { useState, useEffect, useMemo } from 'react';
import {
  ColumnDef,
  ColumnFiltersState,
  flexRender,
  SortingState,
  VisibilityState,
  Row,
  Header
} from "@tanstack/react-table";
import { Card } from "@/components/ui/card";
import { Checkbox } from "@/components/ui/checkbox";
import { cn } from "@/lib/utils";
import { Users } from "lucide-react";
import { TooltipProvider } from "@/components/ui/tooltip";
import { TableContextProvider } from './context/TableContext';
import { useTableState } from './hooks/useTableState';
import {
  TableHeader,
  TableControls,
  TableContent,
  TablePagination,
} from './components';
import { BulkActions, RowActions } from './components/TableUtils';
import { EntityTableStore } from './store';
import { createStoreAdapter } from './adapters';
import { 
  FilterableColumn, 
  SearchableColumn, 
  Action, 
  BulkAction 
} from '../../types/data-table';

/**
 * Props for the EntityDataTable component - extends the TanStack Table functionality
 */
export interface EntityDataTableProps<TData, TValue> {
  columns: ColumnDef<TData, TValue>[];
  data: TData[];
  actions?: Action<TData>[];
  onExport?: () => void;
  onAdd?: () => void;
  addPermission?: { feature: string; action: string };
  filterableColumns?: string[] | FilterableColumn[];
  searchableColumns?: string[] | SearchableColumn[];
  enableMultiSelect?: boolean;
  onSelectionChange?: (selectedRows: TData[]) => void;
  defaultPageSize?: number;
  bulkActions?: BulkAction<TData>[];
  enableRowClick?: boolean | ((event: React.MouseEvent<HTMLTableRowElement>) => boolean);
  onRowClick?: (row: TData) => void;
  title?: string;
  description?: string;
  isLoading?: boolean;
  
  // Server-side features
  totalItems?: number;
  pageCount?: number;
  currentPage?: number;
  onPageChange?: (page: number) => void;
  onPageSizeChange?: (pageSize: number) => void;
  onSortingChange?: (columnId: string, direction: 'asc' | 'desc' | undefined) => void;
  onFilterChange?: (filters: ColumnFiltersState) => void;
  onSearchChange?: (columnId: string, value: string) => void;
  
  // Zustand state management (optional)
  store?: EntityTableStore<TData>;
}

export function EntityDataTable<TData, TValue>({
  columns,
  data,
  actions = [],
  onExport,
  onAdd,
  addPermission,
  filterableColumns = [],
  searchableColumns = [],
  enableMultiSelect = false,
  onSelectionChange,
  defaultPageSize = 10,
  bulkActions = [],
  enableRowClick = false,
  onRowClick,
  title,
  description,
  isLoading = false,
  // Server-side props
  totalItems,
  pageCount,
  currentPage = 0,
  onPageChange,
  onPageSizeChange,
  onSortingChange,
  onFilterChange,
  onSearchChange,
  // Zustand store (optional)
  store
}: EntityDataTableProps<TData, TValue>) {
  // Determine if we're using server-side or client-side pagination
  const isServerSide = !!onPageChange;
  
  // Determine if we're using the store or internal state
  const isUsingStore = !!store;
  
  // Use the custom hook for table state management 
  const tableState = useTableState({
    data,
    columns: getColumnsWithExtensions(),
    defaultPageSize,
    currentPage,
    isServerSide,
    pageCount,
    enableMultiSelect,
    searchableColumns,
    filterableColumns,
    onSelectionChange,
    onPageChange,
    onPageSizeChange,
    onSortingChange,
    onFilterChange,
    onSearchChange
  });

  // Use the store adapter if it's an EntityStore but doesn't fully implement EntityTableStore
  const adaptedStore = useMemo(() => {
    if (isUsingStore && store) {
      // Check if store has all required methods for EntityTableStore
      if (!store.setSelectedItems || 
          !store.setSorting || 
          !store.setColumnFilters || 
          !store.setColumnVisibility) {
        console.log('Creating store adapter for EntityDataTable');
        // Use adapter if missing methods
        return createStoreAdapter(store as any);
      }
    }
    return store;
  }, [isUsingStore, store]);

  // When using the Zustand store, sync changes between store and local state
  useEffect(() => {
    if (isUsingStore && adaptedStore) {
      // Set initial table state from store but only if values are different
      // to prevent infinite re-render loops
      const isSortingDifferent = JSON.stringify(tableState.sorting) !== JSON.stringify(adaptedStore.sorting);
      const isColumnFiltersDifferent = JSON.stringify(tableState.columnFilters) !== JSON.stringify(adaptedStore.columnFilters);
      const isVisibilityDifferent = JSON.stringify(tableState.columnVisibility) !== JSON.stringify(adaptedStore.columnVisibility);
      
      if (isSortingDifferent && adaptedStore.sorting) {
        tableState.setSorting(adaptedStore.sorting);
      }
      
      if (isColumnFiltersDifferent && adaptedStore.columnFilters) {
        tableState.setColumnFilters(adaptedStore.columnFilters);
      }
      
      if (isVisibilityDifferent && adaptedStore.columnVisibility) {
        tableState.setColumnVisibility(adaptedStore.columnVisibility);
      }
      
      // When row selection changes, update the store
      const selectedRows = Object.keys(tableState.rowSelection).map(
        index => data[parseInt(index)]
      );
      
      // Only update selected items if they've changed
      const currentSelectedIds = adaptedStore.selectedIds || [];
      const newSelectedIds = Object.keys(tableState.rowSelection);
      
      if (JSON.stringify(currentSelectedIds) !== JSON.stringify(newSelectedIds)) {
        adaptedStore.setSelectedItems(selectedRows);
      }
    }
  }, [isUsingStore, adaptedStore, data, tableState]);
  
  // Handle row click
  const handleRowClick = (e: React.MouseEvent<HTMLTableRowElement>, row: Row<TData>) => {
    // Don't trigger row click when clicking on actions or selection
    const target = e.target as HTMLElement;
    const isActionClick = target.closest('[data-action-cell="true"]');
    const isSelectionClick = target.closest('[data-selection-cell="true"]');
    
    if (onRowClick && !isActionClick && !isSelectionClick) {
      if (typeof enableRowClick === 'function') {
        if (enableRowClick(e)) {
          onRowClick(row.original);
        }
      } else if (enableRowClick) {
        onRowClick(row.original);
      }
    }
  };

  // Filter out bulk actions for non-existent columns
  const validatedBulkActions = useMemo(() => {
    if (!bulkActions || !bulkActions.length) return [];
    
    return bulkActions.filter(action => {
      if (!action.column) return true; // Keep actions without column specification
      
      // Check if column exists in the actual columns
      const columnExists = columns.some(c => 
        (typeof c.accessorKey === 'string' && c.accessorKey === action.column) || 
        (c.id === action.column)
      );
      
      if (!columnExists) {
        console.warn(`BulkAction for column "${action.column}" does not exist in columns and will be ignored.`);
      }
      
      return columnExists;
    });
  }, [bulkActions, columns]);

  // Render custom header with bulk actions
  const renderHeaderCell = (header: Header<TData, unknown>) => {
    if (!validatedBulkActions || validatedBulkActions.length === 0) {
      return header.isPlaceholder ? null : 
        flexRender(header.column.columnDef.header, header.getContext());
    }
    
    const isBulkActionColumn = validatedBulkActions.some(action => action.column === header.column.id);
    const hasSelectedRows = Object.keys(tableState.rowSelection).length > 0;

    if (isBulkActionColumn && hasSelectedRows) {
      const bulkAction = validatedBulkActions.find(action => action.column === header.column.id);
      const selectedCount = Object.keys(tableState.rowSelection).length;

      return bulkAction ? (
        <BulkActions
          bulkAction={bulkAction}
          column={header.column.id}
          selectedCount={selectedCount}
        />
      ) : null;
    }

    return header.isPlaceholder ? null :
      flexRender(header.column.columnDef.header, header.getContext());
  };
  
  // Create selection column if multiSelect is enabled
  function getColumnsWithExtensions() {
    const selectionColumn = enableMultiSelect ? [{
      id: "select",
      header: ({table}) => (
        <Checkbox
          checked={
            table.getIsAllPageRowsSelected() ||
            (table.getIsSomePageRowsSelected() && "indeterminate")
          }
          onCheckedChange={(value) => table.toggleAllPageRowsSelected(!!value)}
          aria-label="Select all"
          className="translate-y-[2px]"
        />
      ),
      cell: ({row}) => (
        <div data-selection-cell="true">
          <Checkbox
            checked={row.getIsSelected()}
            onCheckedChange={(value) => row.toggleSelected(!!value)}
            aria-label="Select row"
            className="translate-y-[2px]"
          />
        </div>
      ),
      enableSorting: false,
      enableHiding: false,
    }] : [];

    // Create actions column if actions are provided
    const actionsColumn = actions.length > 0 ? [{
      id: "actions",
      header: "Actions",
      cell: ({row}) => <RowActions row={row} />,
      enableSorting: false,
      enableHiding: false,
    }] : [];

    // Combine all columns
    return [
      ...selectionColumn,
      ...columns,
      ...actionsColumn,
    ] as ColumnDef<TData, TValue>[];
  }

  // Use store values if available
  const currentLoading = isUsingStore && adaptedStore?.isLoading !== undefined ? adaptedStore.isLoading : isLoading;

  // Create context value from state and props
  const contextValue = {
    ...tableState,
    data,
    columns,
    // Use the validated columns from tableState
    filterableColumns: tableState.validatedFilterableColumns || [],
    searchableColumns: tableState.validatedSearchableColumns || [],
    actions,
    bulkActions: validatedBulkActions,
    isLoading: currentLoading,
    isServerSide,
    enableMultiSelect,
    enableRowClick,
    onRowClick,
    onSelectionChange,
    onAdd,
    onExport,
    defaultPageSize,
    totalItems,
    pageCount,
    currentPage,
    onPageChange,
    onPageSizeChange,
    onSortingChange,
    onFilterChange,
    onSearchChange,
    title,
    description,
    addPermission,
    handleRowClick,
    renderHeaderCell,
    store: adaptedStore // Make store available to context consumers
  };

  // Ensure TooltipProvider is at the top level
  return (
    <TooltipProvider>
      <TableContextProvider value={contextValue}>
        <div className="flex flex-col min-h-[600px] w-full">
          <Card className="flex-1 w-full overflow-hidden border border-gray-200 dark:border-gray-800 shadow-sm bg-white dark:bg-gray-950 transition-all">
            <TableHeader />
            
            <div className="p-5 space-y-5 overflow-hidden">
              <TableControls />
              <TableContent />
            </div>

            <TablePagination />
          </Card>
        </div>
      </TableContextProvider>
    </TooltipProvider>
  );
}
</file>

<file path="components/data-table/hooks/useTableState.ts">
import { useState, useEffect, useMemo } from 'react';
import {
  ColumnFiltersState,
  SortingState,
  VisibilityState,
  Row,
  Header,
  useReactTable,
  getCoreRowModel,
  getFilteredRowModel,
  getPaginationRowModel,
  getSortedRowModel,
  getFacetedRowModel,
  getFacetedUniqueValues,
  ColumnDef
} from '@tanstack/react-table';
import { FilterableColumn, SearchableColumn } from '../../../types/data-table';

interface UseTableStateProps<TData, TValue> {
  data: TData[];
  columns: ColumnDef<TData, TValue>[];
  defaultPageSize?: number;
  currentPage?: number;
  isServerSide?: boolean;
  pageCount?: number;
  enableMultiSelect?: boolean;
  searchableColumns?: SearchableColumn[];
  filterableColumns?: FilterableColumn[];
  onSelectionChange?: (selectedRows: TData[]) => void;
  onPageChange?: (page: number) => void;
  onPageSizeChange?: (pageSize: number) => void;
  onSortingChange?: (columnId: string, direction: 'asc' | 'desc' | undefined) => void;
  onFilterChange?: (columnId: string, value: string) => void;
  onSearchChange?: (columnId: string, value: string) => void;
}

export const useTableState = <TData, TValue>({
  data,
  columns,
  defaultPageSize = 10,
  currentPage = 0,
  isServerSide = false,
  pageCount,
  enableMultiSelect = false,
  searchableColumns = [],
  filterableColumns = [],
  onSelectionChange,
  onPageChange,
  onPageSizeChange,
  onSortingChange,
  onFilterChange,
  onSearchChange
}: UseTableStateProps<TData, TValue>) => {
  // Filter out invalid columns to prevent errors
  const validatedFilterableColumns = useMemo(() => {
    return filterableColumns.filter(col => {
      // Check if column exists in the actual columns
      const columnExists = columns.some(c => 
        (typeof c.accessorKey === 'string' && c.accessorKey === col.id) || 
        (c.id === col.id)
      );
      
      if (!columnExists) {
        console.warn(`FilterableColumn with id "${col.id}" does not exist in columns and will be ignored.`);
      }
      
      return columnExists;
    });
  }, [columns, filterableColumns]);
  
  const validatedSearchableColumns = useMemo(() => {
    return searchableColumns.filter(col => {
      // Check if column exists in the actual columns
      const columnExists = columns.some(c => 
        (typeof c.accessorKey === 'string' && c.accessorKey === col.id) || 
        (c.id === col.id)
      );
      
      if (!columnExists) {
        console.warn(`SearchableColumn with id "${col.id}" does not exist in columns and will be ignored.`);
      }
      
      return columnExists;
    });
  }, [columns, searchableColumns]);

  // Local state (used for client-side operations)
  const [sorting, setSorting] = useState<SortingState>([]);
  const [columnFilters, setColumnFilters] = useState<ColumnFiltersState>([]);
  const [columnVisibility, setColumnVisibility] = useState<VisibilityState>({});
  const [rowSelection, setRowSelection] = useState({});
  const [searchQuery, setSearchQuery] = useState<string>('');
  const [searchColumn, setSearchColumn] = useState<string>(
    validatedSearchableColumns.length > 0 ? validatedSearchableColumns[0].id : ''
  );
  // Track active search to avoid double-counting in filter indicators
  const [activeSearch, setActiveSearch] = useState<{column: string, query: string} | null>(null);

  // Active filter indicator
  const activeFiltersCount = useMemo(() => {
    // Exclude the current search filter from the count if it exists
    if (activeSearch && activeSearch.query) {
      const nonSearchFilters = columnFilters.filter(filter => 
        !(filter.id === activeSearch.column && filter.value === activeSearch.query)
      );
      return nonSearchFilters.length;
    }
    return columnFilters.length;
  }, [columnFilters, activeSearch]);

  // Handle sorting changes
  const handleSortingChange = (updatedSorting: SortingState) => {
    if (isServerSide && onSortingChange && updatedSorting.length > 0) {
      const { id, desc } = updatedSorting[0];
      onSortingChange(id, desc ? 'desc' : 'asc');
    }
    setSorting(updatedSorting);
  };

  // Handle filter changes
  const handleFilterChange = (columnId: string, value: any) => {
    // First, verify the column exists
    const columnExists = columns.some(c => 
      (typeof c.accessorKey === 'string' && c.accessorKey === columnId) || 
      (c.id === columnId)
    );
    
    if (!columnExists) {
      console.warn(`Attempted to filter on non-existent column "${columnId}"`);
      return;
    }
    
    if (isServerSide && onFilterChange) {
      onFilterChange(columnId, value === "__all__" ? "" : value);
    } else {
      setColumnFilters(prev => {
        const existing = prev.findIndex(filter => filter.id === columnId);
        if (existing !== -1) {
          return value && value !== "__all__"
            ? prev.map(filter => filter.id === columnId ? { id: columnId, value } : filter)
            : prev.filter(filter => filter.id !== columnId);
        } else if (value && value !== "__all__") {
          return [...prev, { id: columnId, value }];
        }
        return prev;
      });
    }
  };

  // Handle search
  const handleSearch = () => {
    if (searchQuery && searchColumn) {
      // First, verify the column exists
      const columnExists = columns.some(c => 
        (typeof c.accessorKey === 'string' && c.accessorKey === searchColumn) || 
        (c.id === searchColumn)
      );
      
      if (!columnExists) {
        console.warn(`Attempted to search on non-existent column "${searchColumn}"`);
        return;
      }
      
      // Track the active search to avoid counting it in filters
      setActiveSearch({ column: searchColumn, query: searchQuery });
      
      if (isServerSide && onSearchChange) {
        onSearchChange(searchColumn, searchQuery);
      } else {
        // First remove any existing filter for this column from search
        setColumnFilters(prev => prev.filter(filter => filter.id !== searchColumn));
        // Then add the new search filter
        if (searchQuery.trim() !== '') {
          setColumnFilters(prev => [...prev, { id: searchColumn, value: searchQuery }]);
        }
      }
    }
  };

  // Reset search
  const resetSearch = () => {
    setSearchQuery('');
    if (searchColumn && activeSearch) {
      setActiveSearch(null);
      
      if (isServerSide && onSearchChange) {
        onSearchChange(searchColumn, '');
      } else {
        // Remove the search filter
        setColumnFilters(prev => prev.filter(filter => filter.id !== searchColumn));
      }
    }
  };

  // Reset search column when searchableColumns change
  useEffect(() => {
    if (validatedSearchableColumns.length > 0) {
      const initialSearchColumn = validatedSearchableColumns[0].id;
      if (searchColumn !== initialSearchColumn && !validatedSearchableColumns.some(col => col.id === searchColumn)) {
        setSearchColumn(initialSearchColumn);
      }
    } else {
      setSearchColumn('');
    }
  }, [validatedSearchableColumns, searchColumn]);

  // Create table instance
  const table = useReactTable({
    data,
    columns,
    state: {
      sorting,
      columnFilters,
      columnVisibility,
      rowSelection,
      pagination: {
        pageIndex: currentPage,
        pageSize: defaultPageSize,
      },
    },
    pageCount: isServerSide ? pageCount : undefined,
    enableRowSelection: enableMultiSelect,
    onRowSelectionChange: setRowSelection,
    onSortingChange: handleSortingChange,
    onColumnFiltersChange: setColumnFilters,
    onColumnVisibilityChange: setColumnVisibility,
    onPaginationChange: (updater) => {
      if (typeof updater === 'function') {
        const newPagination = updater({
          pageIndex: currentPage,
          pageSize: defaultPageSize,
        });
        
        if (isServerSide) {
          if (onPageChange && newPagination.pageIndex !== currentPage) {
            onPageChange(newPagination.pageIndex);
          }
          if (onPageSizeChange && newPagination.pageSize !== defaultPageSize) {
            onPageSizeChange(newPagination.pageSize);
          }
        }
      }
    },
    getCoreRowModel: getCoreRowModel(),
    getFilteredRowModel: getFilteredRowModel(),
    getPaginationRowModel: isServerSide ? undefined : getPaginationRowModel(),
    getSortedRowModel: getSortedRowModel(),
    getFacetedRowModel: getFacetedRowModel(),
    getFacetedUniqueValues: getFacetedUniqueValues(),
    manualPagination: isServerSide,
    manualSorting: isServerSide,
    manualFiltering: isServerSide,
  });

  // Notify parent of selection changes
  useEffect(() => {
    if (onSelectionChange) {
      const selectedRows = table
        .getSelectedRowModel()
        .rows.map((row) => row.original);
      onSelectionChange(selectedRows);
    }
  }, [rowSelection, table, onSelectionChange]);

  return {
    // Table instance
    table,
    
    // State
    sorting,
    setSorting,
    columnFilters,
    setColumnFilters,
    columnVisibility,
    setColumnVisibility,
    rowSelection,
    setRowSelection,
    searchQuery,
    setSearchQuery,
    searchColumn, 
    setSearchColumn,
    activeSearch,
    
    // UI indicators
    activeFiltersCount,
    
    // Handlers
    handleSortingChange,
    handleFilterChange,
    handleSearch,
    resetSearch,
    
    // Validated columns
    validatedFilterableColumns,
    validatedSearchableColumns,
  };
};
</file>

<file path="components/data-table/index.ts">
// Main component
export { EntityDataTable } from './EntityDataTable';
export type { EntityDataTableProps } from './EntityDataTable';

// Context 
export { TableContext, TableProvider, useTableContext } from './context/TableContext';

// Hooks
export { useTableState } from './hooks/useTableState';

// Components (explicit exports)
export { TableControls } from './components/TableControls';
export { TableContent } from './components/TableContent';
export { TableHeader } from './components/TableHeader';
export { TablePagination } from './components/TablePagination';
export { BulkActions, RowActions } from './components/TableUtils';

// Store adapter
export { createStoreAdapter } from './adapters/storeAdapter';
export type { TableStoreAdapter } from './adapters/storeAdapter';
</file>

<file path="components/data-table/store.ts">
import { SortingState, ColumnFiltersState, VisibilityState } from '@tanstack/react-table';

/**
 * Interface for the Zustand store used by EntityDataTable
 * Defines the state and methods that can be used to interact with the table
 */
export interface EntityTableStore<TData> {
  // Table state
  sorting: SortingState;
  columnFilters: ColumnFiltersState;
  columnVisibility: VisibilityState;
  selectedItems: TData[];
  isLoading?: boolean;
  
  // Methods to update table state
  setSorting: (sorting: SortingState) => void;
  setColumnFilters: (filters: ColumnFiltersState) => void;
  setColumnVisibility: (visibility: VisibilityState) => void;
  setSelectedItems: (items: TData[]) => void;
  setLoading?: (isLoading: boolean) => void;
}
</file>

<file path="components/entity-form/components/EntityFormActions.tsx">
import React, { useMemo } from 'react';
import { UseFormReturn } from 'react-hook-form';
import { FormMode } from '@/features/core/tanstack-query-api';
import { Button } from '@/components/ui/button';
import { SectionConfig } from '../../../types/entity-form';
import { AlertCircle, Save, X } from 'lucide-react';

interface EntityFormActionsProps {
  formMode: FormMode;
  isSubmitting: boolean;
  onCancel: () => void;
  onSubmit: () => void;
  form: UseFormReturn<any>;
  sections: SectionConfig[];
}

export function EntityFormActions({
  formMode,
  isSubmitting,
  onCancel,
  onSubmit,
  form,
  sections
}: EntityFormActionsProps) {
  // Count form errors
  const errorCount = useMemo(() => {
    if (formMode === 'view') return 0;
    return Object.keys(form.formState.errors).length;
  }, [form.formState.errors, formMode]);
  
  // Count required fields
  const { requiredFieldCount, filledRequiredFieldCount } = useMemo(() => {
    let totalRequired = 0;
    let totalFilled = 0;
    
    // Don't count in view mode
    if (formMode === 'view') {
      return { requiredFieldCount: 0, filledRequiredFieldCount: 0 };
    }
    
    // Count all required fields and how many are filled
    sections.forEach(section => {
      section.fields.forEach(field => {
        if (field.required) {
          totalRequired++;
          const value = form.getValues(field.name);
          if (value) {
            totalFilled++;
          }
        }
      });
    });
    
    return { 
      requiredFieldCount: totalRequired,
      filledRequiredFieldCount: totalFilled
    };
  }, [sections, form, formMode]);
  
  // Determine if the form is valid
  const { formState } = form;
  const isFormValid = formMode === 'view' || (formState.isValid && errorCount === 0);
  
  // Check if all required fields are filled
  const allRequiredFieldsFilled = formMode === 'view' ? true : (requiredFieldCount === 0 || filledRequiredFieldCount === requiredFieldCount);
  
  // In create mode, we should only check if the form is valid and all required fields are filled
  // Temporarily removing the isDirty check that's causing issues
  const isFormValidAndReady = formMode === 'view' ? true : 
    (isFormValid && allRequiredFieldsFilled);
  
  // Log form state information for debugging
  console.log('Form state:', {
    formMode,
    isFormValid,
    isDirty: formState.isDirty,
    allRequiredFieldsFilled,
    requiredFieldCount,
    filledRequiredFieldCount,
    isFormValidAndReady,
  });
  
  // Handle closing - wrapped in useCallback to maintain consistent hooks
  const handleCancel = React.useCallback(() => {
    console.log('ACTIONS BUTTON - Cancel button clicked');
    
    // Call the onCancel callback immediately
    onCancel();
    
    // Avoid additional processing that might cause hook inconsistencies
  }, [onCancel]);

  // Handle submission - wrapped in useCallback for consistent hooks
  const handleSubmit = React.useCallback(async () => {
    console.log('ACTIONS BUTTON - Submit button clicked');
    
    // Only proceed if not already submitting
    if (isSubmitting) {
      console.log('ACTIONS BUTTON - Already submitting, ignoring click');
      return;
    }
    
    try {
      // Call onSubmit and wait for it to complete
      await onSubmit();
      console.log('ACTIONS BUTTON - onSubmit completed successfully');
    } catch (error) {
      console.error('ACTIONS BUTTON - Error during form submission:', error);
    }
  }, [isSubmitting, onSubmit]);
  
  return (
    <div className="border-t border-gray-200 dark:border-gray-800 p-4 flex justify-between items-center">
      {/* Restore Cancel button */}
      <Button
        type="button"
        variant="ghost"
        size="sm"
        onClick={handleCancel}
      >
        <X size={16} className="mr-1" />
        Cancel
      </Button>
      
      {formMode !== 'view' && (
        <div className="flex items-center gap-3">
          {/* Field completion status */}
          {requiredFieldCount > 0 && (
            <span className={`text-xs ${isFormValidAndReady 
              ? 'text-green-500' 
              : errorCount > 0 ? 'text-red-500' : 'text-amber-500'}`}>
              {filledRequiredFieldCount}/{requiredFieldCount} required fields
              {errorCount > 0 && ' have errors'}
            </span>
          )}
          
          {/* Save button */}
          <Button
            type="button"
            onClick={handleSubmit}
            disabled={isSubmitting || !isFormValidAndReady}
            size="sm"
            className="relative"
            title={!isFormValidAndReady && !isSubmitting ? 'Please fill all required fields correctly before saving' : ''}
          >
            {isSubmitting ? (
              <>
                <span className="mr-1 h-4 w-4 animate-spin rounded-full border-2 border-white border-r-transparent"></span>
                Saving...
              </>
            ) : (
              <>
                <Save size={16} className="mr-1" />
                Save
              </>
            )}
            
            {/* Error Count Badge */}
            {errorCount > 0 && (
              <span className="absolute -top-2 -right-2 w-5 h-5 flex items-center justify-center bg-red-500 text-white text-xs rounded-full">
                {errorCount}
              </span>
            )}
          </Button>
        </div>
      )}
    </div>
  );
}
</file>

<file path="components/entity-form/components/EntityFormContent.tsx">
"use client";

import React from 'react';
import { UseFormReturn, FormProvider } from 'react-hook-form';
import { EntityFormSection } from './EntityFormSection';
import { EntityFormReadOnly } from './EntityFormReadOnly';
import { EntityFormTabsContainer } from './EntityFormTabsContainer';
import { EntityFormActions } from './EntityFormActions';
import { getVisibleSections } from './FormUtils';
import { SectionConfig, FieldConfig, FieldLayout, DisplayMode } from '../../../types/entity-form';
import { FormMode } from '@/features/core/tanstack-query-api';

export interface EntityFormContentProps {
  formMode: FormMode;
  displayMode?: DisplayMode;
  sections?: SectionConfig[];
  fields?: FieldConfig[];
  layout?: FieldLayout;
  data?: any;
  form: UseFormReturn<any>;
  submitError?: string;
  onSubmit: () => void;
}

export function EntityFormContent({
  formMode,
  displayMode = 'dialog',
  sections = [],
  fields = [],
  layout = 'default',
  data,
  form,
  submitError,
  onSubmit
}: EntityFormContentProps) {
  // Determine if we're in read-only mode
  const isReadOnly = formMode === 'view';
  
  // Use React.useMemo to ensure hooks are called consistently
  const sectionsToRender = React.useMemo(() => 
    getVisibleSections(sections, fields, formMode, data, layout),
    [sections, fields, formMode, data, layout]
  );
  
  // Handle direct submit using React.useCallback to maintain consistent hooks
  const handleSubmit = React.useCallback(() => {
    form.handleSubmit(onSubmit)();
  }, [form, onSubmit]);
  
  // Pre-compute component conditions to avoid hook order issues
  const showTabsContainer = React.useMemo(() => sectionsToRender.length > 1, [sectionsToRender.length]);
  
  // Render with conditional display, not conditional hook calls
  return (
    <FormProvider {...form}>
      <React.Fragment>
        {showTabsContainer ? (
          // Multi-section form with tabs
          <form id="entityForm" onSubmit={(e) => { e.preventDefault(); onSubmit(); }} className="flex flex-col h-full">
            <EntityFormTabsContainer
              sections={sectionsToRender}
              layout={layout}
              formMode={formMode}
              data={data}
              form={form}
              isReadOnly={isReadOnly}
              submitError={submitError}
            />
          </form>
        ) : (
          // Single section form - can be either readOnly or editable
          // Use the same container structure but render different content inside
          <div className="form-container">
            {isReadOnly ? (
              // Read-only view for single section
              <EntityFormReadOnly sections={sectionsToRender} data={data} layout={layout} />
            ) : (
              // Editable view for single section
              <form id="entityForm" onSubmit={(e) => { e.preventDefault(); onSubmit(); }} className="space-y-4">
                {sectionsToRender.map((section, index) => (
                  <EntityFormSection
                    key={index}
                    section={section}
                    index={index}
                    layout={layout}
                    formMode={formMode}
                    data={data}
                    form={form}
                    isReadOnly={isReadOnly}
                  />
                ))}
                
                {submitError && (
                  <div className="bg-red-50 dark:bg-red-900/20 text-red-800 dark:text-red-300 p-4 rounded-md text-sm border border-red-200 dark:border-red-900">
                    {submitError}
                  </div>
                )}
              </form>
            )}
          </div>
        )}
      </React.Fragment>
    </FormProvider>
  );
}
</file>

<file path="components/entity-form/components/EntityFormDialog.tsx">
import React, { useRef, useEffect } from 'react';
import {
  Dialog,
  DialogContent
} from '@/components/ui/dialog';

export interface EntityFormDialogProps {
  open: boolean;
  onClose: () => void;
  children: React.ReactNode;
}

export function EntityFormDialog({
  open,
  onClose,
  children
}: EntityFormDialogProps) {
  // Create stable refs to avoid hook ordering issues
  const openRef = useRef(open);
  const onCloseRef = useRef(onClose);
  const isClosingRef = useRef(false);
  
  // Update refs when props change
  useEffect(() => {
    openRef.current = open;
    onCloseRef.current = onClose;
    
    // Reset closing state when form is opened
    if (open) {
      isClosingRef.current = false;
    }
  }, [open, onClose]);
  
  // Safely handle dialog closing with useCallback and guard against multiple executions
  const handleOpenChange = React.useCallback((newOpen: boolean) => {
    // Guard against infinite update loops during close
    if (newOpen === false && !isClosingRef.current) {
      // Set closing state to prevent multiple calls
      isClosingRef.current = true;
      
      // Use requestAnimationFrame instead of setTimeout for better reliability
      requestAnimationFrame(() => {
        if (typeof onCloseRef.current === 'function') {
          onCloseRef.current();
        }
      });
    }
  }, []);

  return (
    <Dialog 
      open={open} 
      onOpenChange={handleOpenChange} 
      modal={true}
    >
      <DialogContent className="entity-management-dialog w-[95vw] sm:w-[90vw] md:max-w-2xl lg:max-w-3xl shadow-lg border-0 dark:bg-gray-950 overflow-hidden rounded-lg p-0 sm:p-6 h-[90vh] sm:max-h-[85vh] flex flex-col">
        {children}
      </DialogContent>
    </Dialog>
  );
}
</file>

<file path="components/entity-form/components/EntityFormFieldHelp.tsx">
import React from 'react';
import { FieldConfig } from '../../../types/entity-form';
import { FieldError } from 'react-hook-form';
import { 
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger
} from '@/components/ui/tooltip';
import { HelpCircle, AlertCircle } from 'lucide-react';

interface EntityFormFieldHelpProps {
  field: FieldConfig;
  error?: FieldError;
}

export function EntityFormFieldHelp({
  field,
  error
}: EntityFormFieldHelpProps) {
  if (!field.description && !error) return null;
  
  return (
    <TooltipProvider>
      <Tooltip delayDuration={300}>
        <TooltipTrigger asChild>
          <div className="inline-flex ml-2 cursor-help">
            {error ? (
              <AlertCircle className="h-4 w-4 text-red-500" />
            ) : (
              <HelpCircle className="h-4 w-4 text-muted-foreground" />
            )}
          </div>
        </TooltipTrigger>
        <TooltipContent side="right" align="start" className="max-w-xs">
          {error ? (
            <div className="text-red-500 text-sm">
              {error.message || 'This field has an error'}
            </div>
          ) : (
            <div className="text-sm">
              {field.description}
            </div>
          )}
        </TooltipContent>
      </Tooltip>
    </TooltipProvider>
  );
}
</file>

<file path="components/entity-form/components/EntityFormFooter.tsx">
import React, { useState, useMemo } from 'react';
import { DialogFooter, DialogClose } from '@/components/ui/dialog';
import { Button } from '@/components/ui/button';
import { Loader2, X } from 'lucide-react';
import { FormMode } from '@/features/core/tanstack-query-api';
import { useFormContext } from 'react-hook-form';

export interface EntityFormFooterProps {
  formMode: FormMode;
  isSubmitting: boolean;
  onClose: () => void;
  onEdit?: () => void;
  onSubmit: () => void;
  onDelete?: (data: any) => void;
  data?: any;
  canEdit: boolean;
  canDelete: boolean;
  renderFooter?: (props: {
    formMode: FormMode;
    isSubmitting: boolean;
    onClose: () => void;
    onEdit?: () => void;
    onSubmit: () => void;
    canEdit: boolean;
    canDelete: boolean;
  }) => React.ReactNode;
  sections?: any[];
}

export function EntityFormFooter({
  formMode,
  isSubmitting,
  onClose,
  onEdit,
  onSubmit,
  onDelete,
  data,
  canEdit,
  canDelete,
  renderFooter,
  sections = []
}: EntityFormFooterProps) {
  const isReadOnly = formMode === 'view';
  const [localSubmitting, setLocalSubmitting] = useState(false);
  
  // Access form from context to check validation state
  // Add try/catch for safety in case FormProvider is missing
  let formState = {};
  try {
    const formContext = useFormContext();
    formState = formContext?.formState || {};
  } catch (error) {
    console.warn('useFormContext failed, fallback to empty state:', error);
  }
  const hasErrors = formState?.errors ? Object.keys(formState.errors).length > 0 : false;
  
  // Fetch the form context once for the entire component
  let formContext;
  try {
    formContext = useFormContext();
  } catch (error) {
    // Form context not available
  }
  
  // Count required fields and check if they're filled
  const { requiredFieldCount, filledRequiredFieldCount } = useMemo(() => {
    let totalRequired = 0;
    let totalFilled = 0;
    
    // Don't count in view mode
    if (formMode === 'view') {
      return { requiredFieldCount: 0, filledRequiredFieldCount: 0 };
    }
    
    // Flatten fields from all sections
    const fields = [];
    if (sections && sections.length > 0) {
      sections.forEach(section => {
        if (section.fields) {
          fields.push(...section.fields);
        }
      });
    }
    
    // Count all required fields and how many are filled
    fields.forEach(field => {
      if (field.required) {
        totalRequired++;
        if (formContext?.getValues) {
          const value = formContext.getValues(field.name);
          if (value !== undefined && value !== null && value !== '') {
            totalFilled++;
          }
        }
      }
    });
    
    return { 
      requiredFieldCount: totalRequired,
      filledRequiredFieldCount: totalFilled
    };
  }, [formMode, sections, formContext]);
  
  // Check if all required fields are filled
  const allRequiredFieldsFilled = formMode === 'view' ? true : (requiredFieldCount === 0 || filledRequiredFieldCount === requiredFieldCount);
  
  // Form is valid if we're in view mode or if the form is valid and has no errors
  const isFormValid = isReadOnly || (formState?.isValid && !hasErrors);
  
  // In create mode, require the form to be dirty (touched) as well
  const isFormValidAndReady = isReadOnly ? true : 
    (formMode === 'create' 
      ? isFormValid && (formState?.isDirty || true) && allRequiredFieldsFilled 
      : isFormValid && allRequiredFieldsFilled);
  
  // Handle closing dialog/sheet properly using useCallback for hook consistency
  const handleClose = React.useCallback(() => {
    console.log('FOOTER BUTTON - Close button clicked');
    onClose();
  }, [onClose]);
  
  // Handle form submission with useCallback
  const handleSubmit = React.useCallback(async () => {
    console.log('FOOTER BUTTON - Submit button clicked', { formMode });
    
    // Only proceed if not already submitting
    if (isSubmitting || localSubmitting) {
      console.log('FOOTER BUTTON - Already submitting, ignoring click');
      return;
    }
    
    // Set local submitting state
    setLocalSubmitting(true);
    
    try {
      // Call onSubmit and wait for it to complete
      await onSubmit();
      console.log('FOOTER BUTTON - onSubmit completed successfully');
    } catch (error) {
      console.error('FOOTER BUTTON - Error during form submission:', error);
    } finally {
      setLocalSubmitting(false);
    }
  }, [formMode, isSubmitting, localSubmitting, onSubmit]);
  
  // Handle delete with useCallback
  const handleDelete = React.useCallback(() => {
    if (onDelete && data) {
      onDelete(data);
    }
  }, [onDelete, data]);
  
  // Only render footer buttons based on the display mode
  const renderDefaultFooter = () => {
    // If using custom footer from props, use that
    if (renderFooter) {
      return renderFooter({
        formMode,
        isSubmitting,
        onClose: handleClose,
        onEdit,
        onSubmit: handleSubmit,
        canEdit,
        canDelete
      });
    }
    
    // For read-only mode
    if (isReadOnly) {
      return (
        <div className="w-full flex flex-col-reverse sm:flex-row sm:justify-end gap-2">
          {/* We only need a Close button here, X in header for Sheet/Dialog */}
          <Button 
            variant="outline" 
            onClick={handleClose} 
            className="border border-gray-200 dark:border-gray-700 text-gray-700 dark:text-gray-300 font-medium rounded-md"
            size="sm"
          >
            Close
          </Button>
          
          {/* Delete button is shown in view mode only if explicitly enabled through showDeleteInViewMode prop */}
          {canDelete && onDelete && data && (
            <Button 
              onClick={handleDelete}
              variant="destructive"
              className="font-medium rounded-md"
              size="sm"
            >
              Delete
            </Button>
          )}
          
          {canEdit && (
            <Button 
              onClick={onEdit} 
              className="bg-primary hover:bg-primary/90 transition-all font-medium rounded-md shadow-sm hover:shadow text-white"
              size="sm"
            >
              Edit
            </Button>
          )}
        </div>
      );
    }
    
    // For edit/create mode
    return (
      <div className="w-full flex flex-col-reverse sm:flex-row sm:justify-between gap-2">
        {/* Always add a hidden DialogClose component */}
        <DialogClose className="hidden" />
        
        {/* Cancel button on the left on larger screens */}
        <div className="sm:flex-1">
          <Button 
            variant="outline" 
            onClick={handleClose} 
            type="button" 
            className="w-full sm:w-auto border border-gray-200 dark:border-gray-700 text-gray-700 dark:text-gray-300"
            size="sm"
          >
            Cancel
          </Button>
        </div>
        
        {/* Submit info and button on the right */}
        <div className="flex flex-col-reverse sm:flex-row sm:items-center gap-2">
          {/* Save button status info */}
          {!isReadOnly && (
            <span className={`text-xs text-center sm:mr-2 ${hasErrors ? 'text-red-500' : requiredFieldCount > 0 ? (filledRequiredFieldCount === requiredFieldCount ? 'text-green-500' : 'text-amber-500') : ''}`}>
              {hasErrors 
                ? 'Please fix form errors' 
                : requiredFieldCount > 0 
                  ? `${filledRequiredFieldCount}/${requiredFieldCount} required fields${filledRequiredFieldCount < requiredFieldCount ? ' need to be filled' : ' completed'}` 
                  : ''}  
            </span>
          )}
          
          {/* Submit Button - full width on mobile */}
          <Button 
            type="submit"
            onClick={handleSubmit}
            disabled={isSubmitting || localSubmitting || !isFormValidAndReady} 
            className="w-full sm:w-auto bg-primary hover:bg-primary/90 transition-all font-medium rounded-md shadow-sm hover:shadow text-white"
            title={!isFormValidAndReady && !isSubmitting && !localSubmitting ? 'Please fill all required fields correctly before saving' : ''}
            size="sm"
          >
            {isSubmitting || localSubmitting ? (
              <>
                <Loader2 className="mr-2 h-4 w-4 animate-spin" />
                {formMode === 'create' ? 'Creating...' : 'Saving...'}
              </>
            ) : (
              formMode === 'create' ? 'Create' : 'Save Changes'
            )}
          </Button>
        </div>
      </div>
    );
  };
  
  return (
    <DialogFooter className="border-t border-gray-200 dark:border-gray-800 px-4 sm:px-6 py-4 bg-white dark:bg-gray-950 mt-auto">
      {renderDefaultFooter()}
    </DialogFooter>
  );
}
</file>

<file path="components/entity-form/components/EntityFormHeader.tsx">
import React from 'react';
import {
  DialogHeader,
  DialogTitle,
  DialogDescription
} from '@/components/ui/dialog';
import { FormMode } from '@/features/core/tanstack-query-api';
import { generateTitle, generateDescription } from './FormUtils';

export interface EntityFormHeaderProps {
  formMode: FormMode;
  title?: string | ((mode: FormMode) => string);
  description?: string | ((mode: FormMode) => string);
  data?: any;
  renderHeader?: (props: {
    formMode: FormMode;
    title?: string;
    description?: string;
  }) => React.ReactNode;
}

export function EntityFormHeader({
  formMode,
  title,
  description,
  data,
  renderHeader
}: EntityFormHeaderProps) {
  // Render custom or default header
  const renderDefaultHeader = () => {
    if (renderHeader) {
      return renderHeader({
        formMode,
        title: generateTitle(title, formMode),
        description: generateDescription(description, formMode)
      });
    }
    
    return (
      <>
        <DialogTitle className="text-xl font-semibold text-gray-800 dark:text-gray-100 tracking-tight">
          {generateTitle(title, formMode)}
        </DialogTitle>
        <DialogDescription className="text-gray-500 dark:text-gray-400 opacity-90">
          {generateDescription(description, formMode)}
        </DialogDescription>
        {formMode === 'view' && data?.isActive !== undefined && (
          <div className="mt-3 flex items-center">
            <span className="text-sm text-gray-500 dark:text-gray-400 mr-2">Status:</span>
            <span className={`px-3 py-1.5 rounded-full text-xs font-medium flex items-center shadow-sm transition-all ${data.isActive ? 'bg-green-100 text-green-800 dark:bg-green-900/30 dark:text-green-400 border border-green-200 dark:border-green-900/50' : 'bg-gray-100 text-gray-600 dark:bg-gray-800 dark:text-gray-400 border border-gray-200 dark:border-gray-700'}`}>
              <span className={`mr-1.5 w-2 h-2 rounded-full ${data.isActive ? 'bg-green-500 dark:bg-green-400 animate-pulse' : 'bg-gray-400 dark:bg-gray-500'}`}></span>
              {data.isActive ? 'Active' : 'Inactive'}
            </span>
          </div>
        )}
      </>
    );
  };
  
  return (
    <DialogHeader className="space-y-2 bg-gray-50 dark:bg-gray-900 border-b px-6 py-5">
      {renderDefaultHeader()}
    </DialogHeader>
  );
}
</file>

<file path="components/entity-form/components/EntityFormReadOnly.tsx">
import React from 'react';
import { SectionConfig, FieldLayout, FieldConfig } from '../../../types/entity-form';

export interface EntityFormReadOnlyProps {
  sections: SectionConfig[];
  data?: any;
  layout: FieldLayout;
}

export function EntityFormReadOnly({
  sections,
  data,
  layout
}: EntityFormReadOnlyProps) {
  return (
    <div className="space-y-8 my-2 bg-white dark:bg-gray-950 rounded-md p-5 shadow-sm border border-gray-100 dark:border-gray-800">
      {sections.map((section, index) => (
        <div key={index} className="space-y-5 pb-6 border-b border-gray-100 dark:border-gray-800 last:border-0 last:pb-0">
          {section.title && (
            <h3 className="text-lg font-semibold text-gray-800 dark:text-gray-200 mb-4 border-l-4 border-primary pl-3">
              {section.title}
            </h3>
          )}
          {section.description && (
            <p className="text-sm text-muted-foreground mb-2">
              {section.description}
            </p>
          )}
          <div className={section.layout === '2-column' ? 'grid grid-cols-1 md:grid-cols-2 gap-4' : 'space-y-4'}>
            {section.fields.map((field, fieldIndex) => (
              <ReadOnlyField
                key={fieldIndex}
                field={field}
                data={data}
              />
            ))}
          </div>
        </div>
      ))}
    </div>
  );
}

interface ReadOnlyFieldProps {
  field: FieldConfig;
  data?: any;
}

function ReadOnlyField({ field, data }: ReadOnlyFieldProps) {
  const value = data ? data[field.name] : undefined;
  
  // If the field has a custom formatter, use it
  if (field.readOnlyFormatter) {
    return (
      <div className="flex flex-col space-y-2 mb-5 last:mb-0">
        <h4 className="text-sm font-medium text-gray-500 dark:text-gray-400 flex items-center">
          {field.label}
        </h4>
        <div className="font-medium text-gray-900 dark:text-gray-100 text-base pt-0.5">
          {field.readOnlyFormatter(value, data) || '-'}
        </div>
      </div>
    );
  }

  // Special handling for select fields with relational data
  if (field.type === 'select' && typeof field.options === 'object' && 'endpoint' in field.options) {
    // For debugging
    console.log(`Field ${field.name} value:`, value);
    console.log(`Field ${field.name} full data:`, data);
    
    // Many API responses use "callType" for the relation object when the field is "callTypeId"
    const relationshipKey = field.name.replace('Id', '');
    const relationshipObject = data && data[relationshipKey] ? data[relationshipKey] : null;
    
    console.log(`Relationship object for ${field.name}:`, relationshipObject);
    
    // If the related entity object is available, display its name
    if (relationshipObject && typeof relationshipObject === 'object' && relationshipObject.name) {
      return (
        <div className="flex flex-col space-y-2 mb-5 last:mb-0">
          <h4 className="text-sm font-medium text-gray-500 dark:text-gray-400 flex items-center">
            {field.label}
          </h4>
          <div className="font-medium text-gray-900 dark:text-gray-100 text-base pt-0.5">
            {relationshipObject.name || '-'}
          </div>
        </div>
      );
    }
    
    // Try to find the relationship in a _data or data property (some APIs nest it)
    if (data && data._data && data._data[relationshipKey] && 
        typeof data._data[relationshipKey] === 'object' && 
        data._data[relationshipKey].name) {
      return (
        <div className="flex flex-col space-y-2 mb-5 last:mb-0">
          <h4 className="text-sm font-medium text-gray-500 dark:text-gray-400 flex items-center">
            {field.label}
          </h4>
          <div className="font-medium text-gray-900 dark:text-gray-100 text-base pt-0.5">
            {data._data[relationshipKey].name || '-'}
          </div>
        </div>
      );
    }
  }

  // Special handling for boolean/switch values
  if (field.type === 'switch' || field.type === 'checkbox') {
    return (
      <div className="flex flex-col space-y-2 mb-5 last:mb-0">
        <h4 className="text-sm font-medium text-gray-500 dark:text-gray-400 flex items-center">
          {field.label}
        </h4>
        <div className="font-medium text-gray-900 dark:text-gray-100 text-base pt-0.5">
          {value === true ? 'Yes' : value === false ? 'No' : '-'}
        </div>
      </div>
    );
  }
  
  // Default formatting for all other fields
  return (
    <div className="flex flex-col space-y-2 mb-5 last:mb-0">
      <h4 className="text-sm font-medium text-gray-500 dark:text-gray-400 flex items-center">
        {field.label}
      </h4>
      <div className="font-medium text-gray-900 dark:text-gray-100 text-base pt-0.5">
        {value || '-'}
      </div>
    </div>
  );
}
</file>

<file path="components/entity-form/components/EntityFormSection.tsx">
import React from 'react';
import { UseFormReturn } from 'react-hook-form';
import {
  Accordion,
  AccordionContent,
  AccordionItem,
  AccordionTrigger,
} from '@/components/ui/accordion';
import { SectionConfig, FieldLayout } from '../../../types/entity-form';
import { FormMode } from '@/features/core/tanstack-query-api';
import { renderField } from '../../form-fields';

export interface EntityFormSectionProps {
  section: SectionConfig;
  index: number;
  layout: FieldLayout;
  formMode: FormMode;
  data?: any;
  form: UseFormReturn<any>;
  isReadOnly: boolean;
}

export function EntityFormSection({
  section,
  index,
  layout,
  formMode,
  data,
  form,
  isReadOnly
}: EntityFormSectionProps) {
  // Determine section layout based on section config or parent layout
  const sectionLayout = section.layout || layout;
  
  // Enhanced responsive grid classes
  const gridClass = sectionLayout === '2-column' 
    ? 'grid grid-cols-1 sm:grid-cols-2 gap-x-6 gap-y-4' 
    : sectionLayout === 'compact'
      ? 'grid grid-cols-1 xs:grid-cols-2 sm:grid-cols-3 md:grid-cols-4 gap-3'
      : 'space-y-4';
  
  // Handle expandable sections
  if (section.expandable) {
    return (
      <Accordion 
        type="single" 
        defaultValue={section.defaultExpanded ? `section-${index}` : undefined}
        collapsible
        className="mb-4"
      >
        <AccordionItem value={`section-${index}`} className="border border-gray-200 dark:border-gray-800 rounded-md px-2 mb-4">
          <AccordionTrigger className="py-3 font-medium text-gray-800 dark:text-gray-200 hover:text-primary">
            {section.title || `Section ${index + 1}`}
          </AccordionTrigger>
          <AccordionContent>
            {section.description && (
              <p className="text-sm text-muted-foreground mb-4">
                {section.description}
              </p>
            )}
            <div className={gridClass}>
              {section.fields.map((field, fieldIndex) => renderField({
                field,
                form,
                formMode,
                data,
                isReadOnly,
                key: `${index}-${fieldIndex}`
              }))}
            </div>
          </AccordionContent>
        </AccordionItem>
      </Accordion>
    );
  }
  
  // Regular non-expandable section with enhanced mobile styling
  return (
    <div className="mb-4 sm:mb-8 bg-white dark:bg-gray-900 p-3 sm:p-5 rounded-lg border border-gray-200 dark:border-gray-800">
      {section.title && (
        <h3 className="text-base sm:text-lg font-semibold mb-2 sm:mb-3 text-gray-800 dark:text-gray-200 border-l-4 border-primary pl-2 sm:pl-3">
          {section.title}
        </h3>
      )}
      {section.description && (
        <p className="text-xs sm:text-sm text-muted-foreground mb-3 sm:mb-4">
          {section.description}
        </p>
      )}
      <div className={gridClass}>
        {section.fields.map((field, fieldIndex) => renderField({
          field,
          form,
          formMode,
          data,
          isReadOnly,
          key: `${index}-${fieldIndex}`
        }))}
      </div>
    </div>
  );
}
</file>

<file path="components/entity-form/components/EntityFormSectionSummary.tsx">
import React from 'react';
import { SectionConfig } from '../../../types/entity-form';
import { UseFormReturn } from 'react-hook-form';
import { Check, X } from 'lucide-react';

interface EntityFormSectionSummaryProps {
  sections: SectionConfig[];
  form: UseFormReturn<any>;
}

export function EntityFormSectionSummary({
  sections,
  form
}: EntityFormSectionSummaryProps) {
  // Extract form errors
  const { errors } = form.formState;
  
  return (
    <div className="bg-muted/30 rounded-lg border border-muted p-4 mb-6">
      <h3 className="font-medium text-base mb-3">Form Summary</h3>
      <div className="space-y-2">
        {sections.map((section, index) => {
          // Calculate completion status for this section
          const sectionFields = section.fields;
          const requiredFields = sectionFields.filter(field => field.required);
          
          let completedFields = 0;
          let hasErrors = false;
          
          sectionFields.forEach(field => {
            // Check for errors
            if (errors[field.name]) {
              hasErrors = true;
            }
            
            // Count completed required fields
            if (field.required) {
              const value = form.getValues(field.name);
              if (value && (!Array.isArray(value) || value.length > 0)) {
                completedFields++;
              }
            }
          });
          
          const isComplete = completedFields === requiredFields.length && !hasErrors;
          
          return (
            <div key={index} className="flex items-start">
              <div className={`w-5 h-5 rounded-full flex items-center justify-center mr-3 flex-shrink-0 ${
                isComplete 
                  ? 'bg-green-100 text-green-600 dark:bg-green-900/20 dark:text-green-400' 
                  : hasErrors
                    ? 'bg-red-100 text-red-600 dark:bg-red-900/20 dark:text-red-400'
                    : 'bg-amber-100 text-amber-600 dark:bg-amber-900/20 dark:text-amber-400'
              }`}>
                {isComplete ? (
                  <Check className="h-3 w-3" />
                ) : hasErrors ? (
                  <X className="h-3 w-3" />
                ) : (
                  <span className="text-xs">{completedFields}/{requiredFields.length}</span>
                )}
              </div>
              <div>
                <h4 className="text-sm font-medium">
                  {section.title || `Section ${index + 1}`}
                </h4>
                <p className="text-xs text-muted-foreground">
                  {isComplete 
                    ? 'All required fields completed' 
                    : hasErrors
                      ? 'This section has errors that need to be fixed'
                      : `${completedFields} of ${requiredFields.length} required fields completed`
                  }
                </p>
              </div>
            </div>
          );
        })}
      </div>
    </div>
  );
}
</file>

<file path="components/entity-form/components/EntityFormSheet.tsx">
"use client";

import React, { useEffect, useRef } from 'react';
import {
  Sheet,
  SheetContent
} from '@/components/ui/sheet';

export interface EntityFormSheetProps {
  open: boolean;
  onClose: () => void;
  children: React.ReactNode;
}

/**
 * EntityFormSheet component - UI shell for sheet-style forms
 * This is a pure presentational component that renders the UI only
 */
export function EntityFormSheet({
  open,
  onClose,
  children
}: EntityFormSheetProps) {
  // Create stable refs for props and state
  const openRef = useRef(open);
  const onCloseRef = useRef(onClose);
  const isClosingRef = useRef(false);
  
  // Update refs when props change
  useEffect(() => {
    openRef.current = open;
    onCloseRef.current = onClose;
    
    // Reset closing state when form is opened
    if (open) {
      isClosingRef.current = false;
    }
  }, [open, onClose]);
  
  // Enhanced sheet closing with better handling for React 18 concurrency
  const handleOpenChange = React.useCallback((newOpen: boolean) => {
    // Critical: Only handle actual closing events (not opening events)
    if (newOpen === false && !isClosingRef.current) {
      // Set global closing flag immediately
      isClosingRef.current = true;
      console.log('EntityFormSheet: Sheet closing initiated');
      
      // Use setTimeout (macro task) instead of requestAnimationFrame or Promise.resolve
      // This ensures we're completely outside React's concurrent rendering cycle
      setTimeout(() => {
        try {
          // Only call onClose if still mounted and open
          if (openRef.current && typeof onCloseRef.current === 'function') {
            console.log('EntityFormSheet: Executing onClose callback');
            // Execute onClose in another setTimeout to further isolate it
            setTimeout(() => {
              try {
                onCloseRef.current();
              } catch (error) {
                console.error('EntityFormSheet: Error in onClose callback:', error);
              } finally {
                // Reset closing flag after sufficient delay regardless of outcome
                setTimeout(() => {
                  isClosingRef.current = false;
                  console.log('EntityFormSheet: Reset closing flag');
                }, 500);
              }
            }, 10);
          } else {
            // Reset the flag after a delay if no callback was executed
            setTimeout(() => {
              isClosingRef.current = false;
              console.log('EntityFormSheet: No callback executed, reset closing flag');
            }, 300);
          }
        } catch (error) {
          console.error('EntityFormSheet: Error in sheet closing handler:', error);
          // Reset the flag even if an error occurred
          isClosingRef.current = false;
        }
      }, 10);
    }
  }, []);

  return (
    <Sheet 
      open={open} 
      onOpenChange={handleOpenChange} 
      modal={true}
    >
      <SheetContent 
        className="entity-management-sheet w-full sm:max-w-md md:max-w-xl lg:max-w-2xl p-0 overflow-hidden border-0 shadow-lg dark:bg-gray-950"
        side="right"
      >
        <div className="h-full flex flex-col">
          {children}
        </div>
      </SheetContent>
    </Sheet>
  );
}
</file>

<file path="components/entity-form/components/EntityFormSticky.tsx">
import React from 'react';
import { Button } from '@/components/ui/button';
import { FormMode } from '@/features/core/tanstack-query-api';
import { SectionConfig } from '../../../types/entity-form';
import { UseFormReturn } from 'react-hook-form';
import { EntityFormSectionSummary } from './EntityFormSectionSummary';

interface EntityFormStickyProps {
  formMode: FormMode;
  isSubmitting: boolean;
  onClose: () => void;
  onSubmit: () => void;
  onEdit?: () => void;
  sections: SectionConfig[];
  form: UseFormReturn<any>;
  showSummary?: boolean;
}

export function EntityFormSticky({
  formMode,
  isSubmitting,
  onClose,
  onSubmit,
  onEdit,
  sections,
  form,
  showSummary = true
}: EntityFormStickyProps) {
  // Get the error count to show on the submit button
  const { errors } = form.formState;
  const errorCount = Object.keys(errors).length;
  
  return (
    <div className="sticky bottom-0 left-0 right-0 pt-2 pb-4 px-4 bg-background border-t border-gray-200 dark:border-gray-800 shadow-md z-10">
      <div className="flex flex-col gap-4">
        {showSummary && formMode !== 'view' && (
          <div className="w-full">
            <EntityFormSectionSummary 
              sections={sections} 
              form={form} 
            />
          </div>
        )}
        
        <div className="flex justify-between items-center">
          <Button 
            type="button" 
            variant="ghost" 
            onClick={onClose}
          >
            Cancel
          </Button>
          
          <div className="flex gap-2">
            {formMode === 'view' && onEdit && (
              <Button 
                type="button" 
                onClick={onEdit}
              >
                Edit
              </Button>
            )}
            
            {formMode !== 'view' && (
              <Button 
                type="button" 
                onClick={onSubmit}
                disabled={isSubmitting}
                className="relative"
              >
                {isSubmitting ? 'Saving...' : 'Save'}
                
                {errorCount > 0 && (
                  <span className="absolute -top-2 -right-2 w-5 h-5 flex items-center justify-center bg-red-500 text-white text-xs rounded-full">
                    {errorCount}
                  </span>
                )}
              </Button>
            )}
          </div>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="components/entity-form/components/EntityFormTabProgress.tsx">
import React, { useEffect, useState } from 'react';
import { UseFormReturn, useFormState } from 'react-hook-form';
import { cn } from '@/lib/utils';
import { Check, AlertCircle } from 'lucide-react';
import { Tooltip, TooltipContent, TooltipProvider, TooltipTrigger } from '@/components/ui/tooltip';
import { Badge } from '@/components/ui/badge';
import { SectionConfig } from '../../../types/entity-form';

interface TabProgressProps {
  sections: SectionConfig[];
  form: UseFormReturn<any>;
  currentTab: string;
  onTabChange: (tabId: string) => void;
}

export function EntityFormTabProgress({
  sections,
  form,
  currentTab,
  onTabChange
}: TabProgressProps) {
  const { errors, dirtyFields, isSubmitted } = useFormState({ control: form.control });
  const [tabStatus, setTabStatus] = useState<Record<string, { 
    complete: boolean, 
    hasErrors: boolean, 
    touched: boolean,
    requiredFields: number,
    completedFields: number 
  }>>({});
  
  // Analyze the form state to determine tab status
  useEffect(() => {
    const newTabStatus: Record<string, any> = {};
    
    sections.forEach((section, index) => {
      const tabId = `tab-${section.title || index}`;
      const sectionFields = section.fields;
      const requiredFields = sectionFields.filter(field => field.required).length;
      
      let completedFields = 0;
      let hasErrors = false;
      let touched = false;
      
      sectionFields.forEach(field => {
        // Check for errors
        if (errors[field.name]) {
          hasErrors = true;
        }
        
        // Check if fields are touched/dirty
        if (dirtyFields[field.name]) {
          touched = true;
        }
        
        // Count completed required fields
        if (field.required) {
          const value = form.getValues(field.name);
          if (value && (!Array.isArray(value) || value.length > 0)) {
            completedFields++;
          }
        }
      });
      
      const complete = completedFields === requiredFields && !hasErrors;
      
      newTabStatus[tabId] = {
        complete,
        hasErrors,
        touched,
        requiredFields,
        completedFields
      };
    });
    
    setTabStatus(newTabStatus);
  }, [sections, form, errors, dirtyFields, isSubmitted]);
  
  return (
    <div className="flex w-full border-b border-gray-200 dark:border-gray-800 mb-5 overflow-x-auto">
      {sections.map((section, index) => {
        const tabId = `tab-${section.title || index}`;
        const status = tabStatus[tabId] || { 
          complete: false, 
          hasErrors: false, 
          touched: false,
          requiredFields: 0,
          completedFields: 0 
        };
        
        return (
          <TooltipProvider key={tabId}>
            <Tooltip delayDuration={300}>
              <TooltipTrigger asChild>
                <button
                  type="button"
                  onClick={() => onTabChange(tabId)}
                  className={cn(
                    "px-5 py-3 flex items-center gap-2 text-sm font-medium border-b-2 transition-colors relative",
                    currentTab === tabId 
                      ? "border-primary text-primary dark:text-primary-foreground" 
                      : "border-transparent text-muted-foreground hover:text-foreground",
                    status.hasErrors && "text-red-500 dark:text-red-400"
                  )}
                >
                  {section.title || `Section ${index + 1}`}
                  
                  {status.complete && (
                    <Badge variant="outline" className="bg-green-500/10 text-green-600 border-green-200">
                      <Check className="h-3 w-3 mr-1" />
                      <span className="text-xs">Complete</span>
                    </Badge>
                  )}
                  
                  {status.hasErrors && (
                    <Badge variant="outline" className="bg-red-500/10 text-red-600 border-red-200">
                      <AlertCircle className="h-3 w-3 mr-1" />
                      <span className="text-xs">Error</span>
                    </Badge>
                  )}
                  
                  {!status.complete && !status.hasErrors && status.requiredFields > 0 && (
                    <Badge variant="outline" className="bg-blue-500/10 text-blue-600 border-blue-200">
                      <span className="text-xs">{status.completedFields}/{status.requiredFields}</span>
                    </Badge>
                  )}
                </button>
              </TooltipTrigger>
              <TooltipContent side="bottom" className="text-xs max-w-xs">
                {status.complete ? (
                  <p className="text-green-600">All required fields completed in this section</p>
                ) : status.hasErrors ? (
                  <p className="text-red-600">This section has fields with errors</p>
                ) : status.requiredFields > 0 ? (
                  <p>
                    {status.touched ? 
                      `Progress: ${status.completedFields}/${status.requiredFields} required fields completed` :
                      `This section has ${status.requiredFields} required fields`
                    }
                  </p>
                ) : (
                  <p>Optional section</p>
                )}
              </TooltipContent>
            </Tooltip>
          </TooltipProvider>
        );
      })}
    </div>
  );
}
</file>

<file path="components/entity-form/components/EntityFormTabs.tsx">
import React, { useState, useEffect } from 'react';
import { UseFormReturn } from 'react-hook-form';
import {
  Tabs,
  TabsContent
} from '@/components/ui/tabs';
import { SectionConfig, FieldLayout } from '../../../types/entity-form';
import { FormMode } from '@/features/core/tanstack-query-api';
import { renderField } from '../../form-fields';
import { EntityFormReadOnly } from './EntityFormReadOnly';
import { EntityFormTabProgress } from './EntityFormTabProgress';
import { EntityFormSticky } from './EntityFormSticky';
import { EntityFormFieldHelp } from './EntityFormFieldHelp';

export interface EntityFormTabsProps {
  sections: SectionConfig[];
  layout: FieldLayout;
  formMode: FormMode;
  data?: any;
  form: UseFormReturn<any>;
  isReadOnly: boolean;
  submitError?: string;
  onSubmit: () => void;
  onClose: () => void;
  onEdit?: () => void;
  isSubmitting?: boolean;
}

export function EntityFormTabs({
  sections,
  layout,
  formMode,
  data,
  form,
  isReadOnly,
  submitError,
  onSubmit,
  onClose,
  onEdit,
  isSubmitting = false
}: EntityFormTabsProps) {
  // Use the first tab as the default value
  const defaultTab = `tab-${sections[0]?.title || '0'}`;
  const [currentTab, setCurrentTab] = useState(defaultTab);
  
  // Update the form field rendering to include help text and validation
  const renderFieldWithHelp = (field: any, fieldProps: any) => {
    const error = form.formState.errors[field.name];
    return (
      <div key={fieldProps.key} className="relative">
        {renderField(fieldProps)}
        <div className="absolute top-0 right-0">
          <EntityFormFieldHelp field={field} error={error} />
        </div>
      </div>
    );
  };
  
  // Check if all required fields are filled and form is valid
  const isFormValid = () => {
    const { errors } = form.formState;
    return Object.keys(errors).length === 0;
  };
  
  // If we're in read-only mode, use the read-only component
  if (isReadOnly) {
    return <EntityFormReadOnly sections={sections} data={data} layout={layout} />;
  }
  
  return (
    <div className="flex flex-col h-full">
      <Tabs value={currentTab} onValueChange={setCurrentTab} className="w-full flex-1 flex flex-col">
        {/* Tab Navigation with Progress Indicators */}
        <EntityFormTabProgress 
          sections={sections} 
          form={form} 
          currentTab={currentTab}
          onTabChange={setCurrentTab}
        />

        {/* Tab Content */}
        <div className="flex-1 overflow-auto">
          {sections.map((section, index) => {
            const tabId = `tab-${section.title || index}`;
            const sectionLayout = section.layout || layout;
            const gridClass = sectionLayout === '2-column' 
              ? 'grid grid-cols-1 md:grid-cols-2 gap-6' 
              : 'space-y-6';
              
            return (
              <TabsContent 
                key={`tab-content-${index}`} 
                value={tabId}
                className="bg-white dark:bg-gray-900 p-5 rounded-lg border border-gray-200 dark:border-gray-800 mt-0 mb-4 data-[state=inactive]:hidden min-h-[400px]"
              >
                {section.description && (
                  <p className="text-sm text-muted-foreground mb-5">
                    {section.description}
                  </p>
                )}
                
                <div className={gridClass}>
                  {section.fields.map((field, fieldIndex) => renderFieldWithHelp(field, {
                    field,
                    form,
                    formMode,
                    data,
                    isReadOnly,
                    key: `${index}-${fieldIndex}`
                  }))}
                </div>
              </TabsContent>
            );
          })}
          
          {submitError && (
            <div className="bg-red-50 dark:bg-red-900/20 text-red-800 dark:text-red-300 p-4 rounded-md text-sm border border-red-200 dark:border-red-900 mt-4 mb-4">
              {submitError}
            </div>
          )}
        </div>
        
        {/* Sticky Footer with Form Summary and Actions */}
        <EntityFormSticky
          formMode={formMode}
          isSubmitting={isSubmitting}
          onClose={onClose}
          onSubmit={onSubmit}
          onEdit={onEdit}
          sections={sections}
          form={form}
          showSummary={!isFormValid()}
        />
      </Tabs>
    </div>
  );
}
</file>

<file path="components/entity-form/components/EntityFormTabsContainer.tsx">
"use client";

import React, { useState, useMemo, useEffect, useRef } from 'react';
import { UseFormReturn } from 'react-hook-form';
import { SectionConfig, FieldLayout } from '../../../types/entity-form';
import { FormMode } from '@/features/core/tanstack-query-api';
import { EntityFormReadOnly } from './EntityFormReadOnly';
import { EntityFormTabsNavigation } from './EntityFormTabsNavigation';
import { renderField } from '../../form-fields';
import { 
  HelpCircle, 
  BadgeInfo 
} from 'lucide-react';
import { 
  Tooltip, 
  TooltipContent, 
  TooltipProvider, 
  TooltipTrigger 
} from '@/components/ui/tooltip';
import { 
  Progress 
} from '@/components/ui/progress';
import { FormDebug } from './FormDebug';
import { hasValidValue, isolateFormValues, isRequiredFieldFilled, getFieldValue } from '../../../utils/fieldValidation';

interface EntityFormTabsContainerProps {
  sections: SectionConfig[];
  layout: FieldLayout;
  formMode: FormMode;
  data?: any;
  form: UseFormReturn<any>;
  isReadOnly: boolean;
  submitError?: string;
}

export function EntityFormTabsContainer({
  sections,
  layout,
  formMode,
  data,
  form,
  isReadOnly,
  submitError
}: EntityFormTabsContainerProps) {
  // Store stable refs to props to prevent unwanted re-renders
  const sectionsRef = useRef(sections);
  const formRef = useRef(form);
  const isReadOnlyRef = useRef(isReadOnly);
  
  // Update refs when props change
  useEffect(() => {
    sectionsRef.current = sections;
    formRef.current = form;
    isReadOnlyRef.current = isReadOnly;
  }, [sections, form, isReadOnly]);
  
  // Default to first tab - always initialized even if in read-only mode
  const defaultTab = useMemo(() => `tab-${sections[0]?.title || '0'}`, [sections]);
  const [activeTab, setActiveTab] = useState(defaultTab);
  
  // Handle tab switching with proper field isolation - defined always
  const handleTabChange = React.useCallback((newTabId) => {
    if (isReadOnlyRef.current) return; // No-op in read-only mode, but function still exists
    
    // Preserve current values
    console.log(`[TabsContainer] Switching from tab ${activeTab} to ${newTabId}`);
    
    // Explicitly blur any active input to prevent value crossover
    if (document.activeElement instanceof HTMLElement) {
      document.activeElement.blur();
    }
    
    // Update state with a slight delay to ensure UI updates properly
    setTimeout(() => {
      setActiveTab(newTabId);
    }, 0);
  }, [activeTab]); // Only depends on activeTab
  
  // Helper to check if a field has a valid value - defined unconditionally
  const hasFieldValue = React.useCallback((value) => {
    if (value === undefined || value === null) return false;
    if (typeof value === 'string' && value.trim() === '') return false;
    if (typeof value === 'number' && isNaN(value)) return false;
    // Check for numbers (0 is a valid value)
    if (typeof value === 'number') return true;
    if (Array.isArray(value) && value.length === 0) return false;
    return true;
  }, []);
  
  // Watch all required fields for changes
  const requiredFieldNames = useMemo(() => {
    const names = [];
    sectionsRef.current.forEach(section => {
      section.fields.forEach(field => {
        if (field.required) {
          names.push(field.name);
        }
      });
    });
    return names;
  }, []);  // Empty dependency array - we use the ref for latest values
  
  // Watch form changes - always initialize this state
  const [formValues, setFormValues] = useState({});
  
  // Subscribe to form changes with consistent hooks usage
  useEffect(() => {
    // Create a safe wrapper to prevent state updates on unmounted components
    let isMounted = true;
    const safeSetFormValues = (values) => {
      if (!isMounted) return;
      
      try {
        // Always ensure we're dealing with a clean object to prevent reference issues
        setFormValues(isolateFormValues(values || {}));
      } catch (e) {
        console.error('[TabsContainer] Error setting form values:', e);
        // Set empty object as fallback to maintain hook consistency
        setFormValues({});
      }
    };
    
    // Skip intensive work in read-only mode but maintain hook
    if (isReadOnlyRef.current) {
      safeSetFormValues({});
      return () => { isMounted = false; };
    }
    
    // Get initial values - always with defensive fallback
    let initialValues = {};
    try {
      initialValues = formRef.current.getValues() || {};
      console.log('[TabsContainer] Initial form values:', initialValues);
    } catch (e) {
      console.error('[TabsContainer] Error getting initial values:', e);
    }
    safeSetFormValues(initialValues);
    
    // Subscribe to form changes with error handling
    let subscription;
    try {
      subscription = formRef.current.watch((value, { name, type } = { name: 'unknown', type: 'unknown' }) => {
        if (!isMounted) return;
        
        console.log(`[TabsContainer] Field '${name || 'unknown'}' changed to:`, value);
        // Always get fresh values directly to avoid stale state
        try {
          const latest = formRef.current.getValues() || {};
          safeSetFormValues(latest);
        } catch (e) {
          console.error('[TabsContainer] Error watching form:', e);
          safeSetFormValues({});
        }
      });
    } catch (e) {
      console.error('[TabsContainer] Error setting up form watch:', e);
    }
    
    // Proper cleanup with defensive approach
    return () => {
      isMounted = false;
      if (subscription && typeof subscription.unsubscribe === 'function') {
        try {
          subscription.unsubscribe();
        } catch (e) {
          console.error('[TabsContainer] Error unsubscribing from form:', e);
        }
      }
    };
  }, []);  // Empty dependency array - rely on refs for latest values
  
  // Calculate form completion progress - called unconditionally
  const { completion, requiredFieldCount, filledRequiredFieldCount, fieldStatus } = useMemo(() => {
    // Return default values for read-only to save unnecessary calculation while maintaining hook call order
    if (isReadOnlyRef.current) return { 
      completion: 100, 
      requiredFieldCount: 0, 
      filledRequiredFieldCount: 0,
      fieldStatus: {}
    };
    
    let totalRequired = 0;
    let totalFilled = 0;
    const fieldStatus = {};
    
    // Count all required fields and how many are filled
    sectionsRef.current.forEach(section => {
      section.fields.forEach(field => {
        if (field.required) {
          totalRequired++;
          // Get specific field value by exact name
          const value = getFieldValue(formValues, field.name);
          const isFilled = hasValidValue(value, field.name);
          
          // Track field status for debugging
          fieldStatus[field.name] = {
            name: field.name,
            section: section.title,
            value,
            isFilled,
            hasError: !!formRef.current.formState.errors[field.name]
          };
          
          if (isFilled) {
            totalFilled++;
          }
        }
      });
    });
    
    // Log field status for debugging
    console.debug('[TabsContainer] Field status:', fieldStatus);
    console.debug(`[TabsContainer] Required fields filled: ${totalFilled}/${totalRequired}`);
    
    const percent = totalRequired > 0 
      ? Math.round((totalFilled / totalRequired) * 100)
      : 100;
    
    return { 
      completion: percent,
      requiredFieldCount: totalRequired,
      filledRequiredFieldCount: totalFilled,
      fieldStatus
    };
  }, [formValues, hasFieldValue]);  // Only depend on formValues and hasFieldValue
  
  // Update progress display - called unconditionally
  useEffect(() => {
    // Skip logging in read-only mode but keep the effect
    if (isReadOnlyRef.current) return;
    
    // Log when current field status changes
    console.log(`[TabsContainer] Current form values:`, formValues);
    console.log(`[TabsContainer] Current completion: ${filledRequiredFieldCount}/${requiredFieldCount}`);
  }, [formValues, filledRequiredFieldCount, requiredFieldCount]);
  
  // Find the active section - calculated regardless of mode
  const activeSection = useMemo(() => {
    return sectionsRef.current.find((section, index) => 
      `tab-${section.title || index}` === activeTab
    ) || sectionsRef.current[0];
  }, [activeTab]);
  return (
    <div className="flex flex-col h-full">
      {isReadOnly ? (
        // Read-only view
        <EntityFormReadOnly sections={sections} data={data} layout={layout} />
      ) : (
        // Edit/Create view
        <>
          {/* Form Progress */}
          <div className="px-6 py-2 flex items-center gap-2">
            <Progress value={completion} className="h-2 flex-1" />
            <span className={`text-xs whitespace-nowrap ${(requiredFieldCount === 0 || filledRequiredFieldCount === requiredFieldCount) ? 'text-green-500 font-medium' : 'text-amber-500 font-medium'}`}>
              {requiredFieldCount > 0 ? `${filledRequiredFieldCount}/${requiredFieldCount} fields completed` : 'No required fields'}
            </span>
          </div>
          
          {/* Tab Navigation */}
          <EntityFormTabsNavigation 
            sections={sections}
            activeTab={activeTab}
            onChange={handleTabChange}
            formState={form.formState}
          />
      
          {/* Tab Content */}
          <div className="p-6 overflow-y-auto space-y-6">
            {/* Section title and description */}
            {activeSection && (
              <div className="mb-6">
                {activeSection.title && (
                  <h3 className="text-lg font-semibold flex items-center">
                    {activeSection.title}
                  </h3>
                )}
                
                {activeSection.description && (
                  <p className="text-sm text-muted-foreground mt-1">
                    {activeSection.description}
                  </p>
                )}
              </div>
            )}
        
            {/* Section Fields */}
            {activeSection && (
              <div className={activeSection.layout === '2-column' 
                ? 'grid grid-cols-1 md:grid-cols-2 gap-6' 
                : 'space-y-6'
              }>
                {activeSection.fields.map((field, fieldIndex) => {
                  const error = form.formState.errors[field.name];
                  return (
                    <div key={fieldIndex} className="relative group">
                      {renderField({
                        field: {
                          ...field,
                          // Add section identifier to make field truly unique across tabs
                          // This prevents field value contamination
                          key: `${activeSection.title || 'section'}-${field.name}`
                        },
                        form,
                        formMode,
                        data,
                        isReadOnly: false,
                        key: `${activeSection.title || 'section'}-field-${fieldIndex}`
                      })}
                      
                      {/* Help tooltip */}
                      {field.description && (
                        <TooltipProvider>
                          <Tooltip>
                            <TooltipTrigger asChild>
                              <div className="absolute top-0 right-0 opacity-50 group-hover:opacity-100 transition-opacity">
                                <BadgeInfo size={16} className="text-muted-foreground" />
                              </div>
                            </TooltipTrigger>
                            <TooltipContent side="right" align="start" className="max-w-xs bg-secondary p-2">
                              <p className="text-xs">{field.description}</p>
                            </TooltipContent>
                          </Tooltip>
                        </TooltipProvider>
                      )}
                      
                      {/* Error message */}
                      {error && (
                        <p className="text-xs text-red-500 mt-1">
                          {error.message as string}
                        </p>
                      )}
                    </div>
                  );
                })}
              </div>
            )}
        
            {/* Submit Error */}
            {submitError && (
              <div className="bg-red-50 dark:bg-red-900/20 text-red-800 dark:text-red-300 p-4 rounded-md text-sm border border-red-200 dark:border-red-900 mt-6">
                {submitError}
              </div>
            )}
          </div>
          
          {/* Debug component - only visible in development */}
          {process.env.NODE_ENV !== 'production' && (
            <FormDebug form={form} sections={sections} />
          )}
        </>
      )}
    </div>
  );
}
</file>

<file path="components/entity-form/components/EntityFormTabsNavigation.tsx">
import React from 'react';
import { UseFormReturn } from 'react-hook-form';
import { SectionConfig } from '../../../types/entity-form';
import { Tabs, TabsList, TabsTrigger } from '@/components/ui/tabs';
import { cn } from '@/lib/utils';

export interface EntityFormTabsNavigationProps {
  sections: SectionConfig[];
  form: UseFormReturn<any>;
  currentTab: string;
  onTabChange: (tab: string) => void;
}

export function EntityFormTabsNavigation({
  sections,
  form,
  currentTab,
  onTabChange
}: EntityFormTabsNavigationProps) {
  // Calculate tab indicator for each section
  const getTabIndicator = (section: SectionConfig): 'error' | 'complete' | 'pending' => {
    // Get all field names for this section
    const sectionFieldNames = section.fields.map(field => field.name);
    
    // Check if any fields in this section have errors
    const hasErrors = sectionFieldNames.some(fieldName => 
      form.formState.errors[fieldName] !== undefined
    );
    
    if (hasErrors) {
      return 'error';
    }
    
    // Check if any required fields are dirty (have been interacted with)
    const requiredFieldNames = section.fields
      .filter(field => field.required)
      .map(field => field.name);
    
    const touchedRequiredFields = requiredFieldNames.filter(fieldName => 
      form.formState.touchedFields[fieldName]
    );
    
    if (requiredFieldNames.length > 0 && touchedRequiredFields.length === requiredFieldNames.length) {
      return 'complete';
    }
    
    return 'pending';
  };

  return (
    <div className="sticky top-0 z-10 bg-white dark:bg-gray-950 pt-2 pb-2 border-b border-gray-200 dark:border-gray-800">
      <div className="overflow-auto px-2 pb-2">
        {/* Use scrolling container for smaller screens */}
        <div className="flex items-center space-x-1 overflow-x-auto pb-2 scrollbar-none">
          {sections.map((section, index) => {
            const tabId = `tab-${section.title || index}`;
            const indicator = getTabIndicator(section);
            
            return (
              <button
                key={tabId}
                onClick={() => onTabChange(tabId)}
                className={cn(
                  "flex items-center min-w-max whitespace-nowrap rounded-md px-3 py-1.5 text-sm font-medium",
                  "transition-colors focus-visible:outline-none disabled:pointer-events-none",
                  currentTab === tabId ? 
                    "bg-primary/10 text-primary" : 
                    "hover:bg-muted/80 text-muted-foreground",
                  indicator === 'error' && "text-red-600 dark:text-red-400",
                  "flex-shrink-0" // Prevent shrinking in small screens
                )}
              >
                {section.title || `Section ${index + 1}`}
                
                {/* Status indicator */}
                {indicator === 'error' && (
                  <span className="ml-2 h-2 w-2 rounded-full bg-red-500" />
                )}
                {indicator === 'complete' && (
                  <span className="ml-2 h-2 w-2 rounded-full bg-green-500" />
                )}
              </button>
            );
          })}
        </div>
      </div>
      
      {/* Mobile-friendly indicator when tabs are scrollable */}
      <div className="lg:hidden text-xs text-center text-gray-500 dark:text-gray-400 pb-1">
        {sections.length > 3 && (
          <span>Swipe to see more tabs →</span>
        )}
      </div>
    </div>
  );
}
</file>

<file path="components/entity-form/components/FormDebug.tsx">
import React, { useState, useEffect } from 'react';
import { UseFormReturn } from 'react-hook-form';
import { SectionConfig } from '../../../types/entity-form';
import { Button } from '@/components/ui/button';
import { Bug } from 'lucide-react';
import { hasValidValue, isolateFormValues, isRequiredFieldFilled, getFieldValue } from '../../../utils/fieldValidation';

interface FormDebugProps {
  form: UseFormReturn<any>;
  sections: SectionConfig[];
}

// Helper to check if a field has a valid value
// This is a duplicate for debugging only - the real function is in utils/fieldValidation.ts 
const hasFieldValue = (value: any): boolean => {
  if (value === undefined || value === null) return false;
  if (typeof value === 'string' && value.trim() === '') return false;
  if (typeof value === 'number' && isNaN(value)) return false;
  // Check for numbers (0 is a valid value)
  if (typeof value === 'number') return true;
  if (Array.isArray(value) && value.length === 0) return false;
  return true;
};

/**
 * Debug component for form development - only rendered in development mode
 * This component should never be included in production builds
 */
export function FormDebug({ form, sections }: FormDebugProps) {
  // Return null in production environment
  if (process.env.NODE_ENV === 'production') {
    return null;
  }

  const [isOpen, setIsOpen] = useState(false);
  const [allValues, setAllValues] = useState({});
  const [refresh, setRefresh] = useState(0);
  
  // Watch form values
  useEffect(() => {
    const subscription = form.watch((value) => {
      setAllValues(isolateFormValues(form.getValues()));
    });
    
    // Initial values
    setAllValues(isolateFormValues(form.getValues()));
    
    return () => subscription.unsubscribe();
  }, [form]);
  
  // Refresh every second to catch any changes
  useEffect(() => {
    const timer = setInterval(() => {
      setRefresh(prev => prev + 1);
      setAllValues(isolateFormValues(form.getValues()));
    }, 1000);
    
    return () => clearInterval(timer);
  }, [form]);
  
  if (!isOpen) {
    return (
        <Button
            type="button"
            variant="outline"
            size="sm"
            onClick={() => setIsOpen(true)}
            className="absolute bottom-4 left-1/2 transform -translate-x-1/2 z-50 opacity-70 hover:opacity-100"
        >
        <Bug size={16} className="mr-1" />
        Debug
      </Button>
    );
  }
  
  // Get all required fields
  const requiredFields = [];
  sections.forEach(section => {
    section.fields.forEach(field => {
      if (field.required) {
        // Get a precise reference to the value
        const value = getFieldValue(allValues, field.name);
        requiredFields.push({
          name: field.name,
          section: section.title,
          value: value,
          error: form.formState.errors[field.name],
          isFilled: hasValidValue(value, field.name),
          type: typeof value
        });
      }
    });
  });
  
  return (
    <div className="fixed bottom-0 left-0 w-96 max-h-96 overflow-auto bg-white dark:bg-gray-950 shadow-lg border rounded-tr-lg z-50 p-4">
      <div className="flex justify-between items-center mb-2">
        <h3 className="font-semibold">Form Debug</h3>
        <Button
          type="button"
          variant="ghost"
          size="sm"
          onClick={() => setIsOpen(false)}
        >
          Close
        </Button>
      </div>
      
      <div className="space-y-2 text-xs">
        <p><strong>Form State:</strong> {form.formState.isValid ? '✅ Valid' : '❌ Invalid'}</p>
        <p><strong>Dirty: </strong> {form.formState.isDirty ? '✅ Yes' : '❌ No'}</p>
        <p><strong>Required Fields:</strong> {requiredFields.length}</p>
        <p><strong>Last refresh:</strong> {new Date().toLocaleTimeString()}</p>
        
        <div className="mt-2 space-y-1">
          <p className="font-semibold">Required Fields Status:</p>
          {requiredFields.map((field, index) => (
            <div 
              key={index} 
              className={`p-2 rounded-sm ${field.isFilled ? 'bg-green-50 dark:bg-green-900/20' : field.error ? 'bg-red-50 dark:bg-red-900/20' : 'bg-amber-50 dark:bg-amber-900/20'}`}
            >
              <p className="font-medium">{field.name} ({field.section})</p>
              <p>Value: <code>{JSON.stringify(field.value)}</code></p>
              <p>Type: <code>{field.type}</code></p>
              <p>Status: {field.isFilled ? '✅ Filled' : '❌ Empty'}</p>
              {field.error && <p>Error: {field.error.message}</p>}
            </div>
          ))}
        </div>
      </div>
    </div>
  );
}
</file>

<file path="components/entity-form/components/FormUtils.tsx">
import React from 'react';
import { SectionConfig, FieldConfig, FieldLayout } from '../../../types/entity-form';
import { FormMode } from '@/features/core/tanstack-query-api';

/**
 * Helper function to filter sections based on visibility conditions
 */
export function getVisibleSections(
  sections: SectionConfig[],
  fields: FieldConfig[],
  formMode: FormMode,
  data?: any,
  layout: FieldLayout = 'default'
): SectionConfig[] {
  if (sections.length > 0) {
    return sections.filter(section => {
      if (typeof section.visible === 'function') {
        return section.visible(formMode, data);
      }
      return section.visible !== false;
    });
  }
  
  return [{
    fields: fields.filter(field => {
      const isHidden = typeof field.hidden === 'function' 
        ? field.hidden(formMode, data)
        : field.hidden;
      
      return !isHidden;
    }),
    layout
  }];
}

/**
 * Helper function to determine if a field should be disabled
 */
export function isFieldDisabled(
  field: FieldConfig,
  formMode: FormMode,
  data?: any
): boolean {
  return typeof field.disabled === 'function' 
    ? field.disabled(formMode, data)
    : !!field.disabled;
}

/**
 * Helper function to generate form title based on mode
 */
export function generateTitle(
  title: string | ((mode: FormMode) => string) | undefined,
  formMode: FormMode
): string {
  if (typeof title === 'function') {
    return title(formMode);
  }
  
  if (title) {
    return title;
  }
  
  switch (formMode) {
    case 'create':
      return 'Create New Item';
    case 'edit':
      return 'Edit Item';
    default:
      return 'Item Details';
  }
}

/**
 * Helper function to generate form description based on mode
 */
export function generateDescription(
  description: string | ((mode: FormMode) => string) | undefined,
  formMode: FormMode
): string {
  if (typeof description === 'function') {
    return description(formMode);
  }
  
  if (description) {
    return description;
  }
  
  switch (formMode) {
    case 'create':
      return 'Create a new item with the form below.';
    case 'edit':
      return 'Edit the item details with the form below.';
    default:
      return 'View the details of the item.';
  }
}
</file>

<file path="components/entity-form/components/index.ts">
export * from './EntityFormDialog';
export * from './EntityFormSheet';
export * from './EntityFormHeader';
export * from './EntityFormFooter';
export * from './EntityFormContent';
export * from './EntityFormSection';
export * from './EntityFormReadOnly';
export * from './EntityFormTabsContainer';
export * from './EntityFormTabsNavigation';
export * from './EntityFormActions';
export * from './FormUtils';
export * from './FormDebug';
</file>

<file path="components/entity-form/context/FormContext.tsx">
"use client";

import React, { createContext, useContext, ReactNode } from 'react';
import { UseFormReturn } from 'react-hook-form';
import { FormMode } from '@/features/core/tanstack-query-api';

export interface FormContextType {
  form: UseFormReturn<any> | any; // Allow for both proper form or fallback object
  formMode: FormMode;
  isReadOnly: boolean;
  data?: any;
  onSubmit: () => void;
  onEdit?: () => void;
  onClose: () => void;
  onDelete?: (data: any) => void;
  canEdit: boolean;
  canDelete: boolean;
  isSubmitting: boolean;
}

export const FormContext = createContext<FormContextType | null>(null);

export interface FormProviderProps {
  form: UseFormReturn<any> | any; // Allow for both proper form or fallback object
  formMode: FormMode;
  data?: any;
  onSubmit: () => void;
  onEdit?: () => void;
  onClose: () => void;
  onDelete?: (data: any) => void;
  canEdit: boolean;
  canDelete: boolean;
  isSubmitting: boolean;
  children: ReactNode;
}

export function FormProvider({
  form,
  formMode,
  data,
  onSubmit,
  onEdit,
  onClose,
  onDelete,
  canEdit,
  canDelete,
  isSubmitting,
  children
}: FormProviderProps) {
  // Derive isReadOnly from formMode
  const isReadOnly = formMode === 'view';
  
  // Create a safe form object if the provided one is null or undefined
  const safeForm = form || {
    register: () => ({}),
    handleSubmit: (cb) => () => {},
    formState: { errors: {} },
    watch: () => {},
    setValue: () => {},
    getValues: () => ({}),
    reset: () => {},
    control: {}
  };
  
  const value = {
    form: safeForm,
    formMode,
    isReadOnly,
    data,
    onSubmit,
    onEdit,
    onClose,
    onDelete,
    canEdit,
    canDelete,
    isSubmitting
  };
  
  return (
    <FormContext.Provider value={value}>
      {children}
    </FormContext.Provider>
  );
}

export function useForm() {
  const context = useContext(FormContext);
  
  if (!context) {
    throw new Error('useForm must be used within a FormProvider');
  }
  
  return context;
}
</file>

<file path="components/entity-form/context/index.ts">
export * from './FormContext';
</file>

<file path="components/entity-form/EntityForm.tsx">
"use client";

import React, {useCallback, useEffect, useRef} from 'react';
import {FormProvider as RHFFormProvider} from 'react-hook-form';
import {
  EntityFormActions,
  EntityFormContent,
  EntityFormDialog,
  EntityFormFooter,
  EntityFormHeader,
  EntityFormSheet
} from './components';
import {FormProvider} from './context';
import {useFormState} from './hooks';
import {EntityFormProps} from '../../types/entity-form';
import {EntityStore} from '../../store';
import {getVisibleSections} from './components/FormUtils';

export function EntityForm<TData = any>({
  // Modal state
  open,
  onClose,
  
  // Display configuration
  displayMode = 'dialog',
  
  // Form configuration
  formMode = 'view',
  onChangeFormMode,
  title,
  description,
  
  // Field configuration
  sections = [],
  fields = [],
  layout = 'default',
  
  // Data and callbacks
  data,
  onSubmit,
  onDelete,
  
  // Permissions
  canEdit = true,
  canDelete = true,
  
  // Form control
  form: externalForm,
  defaultValues = {},
  validationSchema,
  
  // UI states
  isSubmitting = false,
  submitError,
  
  // Custom rendering
  renderFooter,
  renderHeader,
  
  // Zustand store (optional)
  store
}: EntityFormProps<TData> & { store?: EntityStore<TData> }) {
  // Use form state hook
  const { form, setFormMode } = useFormState({
    defaultValues,
    validationSchema,
    externalForm
  });
  
  // Determine if we're using the store or props
  const isUsingStore = !!store;
  
  // Get state from either store or props
  const isOpen = isUsingStore ? store.getState().isModalOpen : open;
  const currentFormMode = isUsingStore ? store.getState().formMode : formMode;
  const currentData = isUsingStore ? store.getState().selectedItem : data;
  const currentSubmitting = isUsingStore ? store.getState().isSubmitting : isSubmitting;
  const currentSubmitError = isUsingStore ? store.getState().submitError : submitError;
  
  // Subscribe to store updates if using store
  const [storeState, setStoreState] = React.useState({
    isModalOpen: isUsingStore ? store.getState().isModalOpen : false,
    formMode: isUsingStore ? store.getState().formMode : 'view',
    selectedItem: isUsingStore ? store.getState().selectedItem : null,
    isSubmitting: isUsingStore ? store.getState().isSubmitting : false,
    submitError: isUsingStore ? store.getState().submitError : null
  });
  
  useEffect(() => {
    if (!isUsingStore) return;
    
    const unsubscribe = store.subscribe((state) => {
      setStoreState({
        isModalOpen: state.isModalOpen,
        formMode: state.formMode,
        selectedItem: state.selectedItem,
        isSubmitting: state.isSubmitting,
        submitError: state.submitError
      });
    });
    
    return () => unsubscribe();
  }, [isUsingStore, store]);
  
  // Get the sections to render
  const sectionsToRender = getVisibleSections(sections, fields, currentFormMode, currentData, layout);
  
  // Update form mode when changed externally
  useEffect(() => {
    if (!isUsingStore) {
      setFormMode(formMode);
    } else {
      setFormMode(storeState.formMode);
    }
  }, [formMode, storeState.formMode, setFormMode, isUsingStore]);
  
  // Reference to track whether the form has been initialized for the current session
  const formInitialized = useRef(false);
  
  // Manage form state with better cleanup handling
  useEffect(() => {
    // Skip if state is invalid
    console.log("Entity form effect - isOpen:", isOpen);
    if (typeof isOpen === 'undefined') return;
    
    // Create a mount tracker to prevent updates after unmount
    let isMounted = true;
    
    // Create safe reset function that checks mounting state
    const safeReset = (data, options = {}) => {
      if (isMounted) {
        try {
          console.log("Safe reset called with data:", Object.keys(data || {}));
          form.reset(data, options);
        } catch (e) {
          console.error('Form reset error:', e);
        }
      } else {
        console.log("Skipping reset - component unmounted");
      }
    };
    
    // Handle form closing - do cleanup AFTER all operations complete
    if (!isOpen) {
      console.log("Form closing - performing cleanup");
      
      // Mark form as uninitialized immediately
      formInitialized.current = false;
      
      // Reset form to empty state and return early
      const timeout = setTimeout(() => {
        if (isMounted) {
          safeReset({});
        }
      }, 100);
      
      return () => {
        clearTimeout(timeout);
        isMounted = false;
      };
    }
    
    // Handle form opening
    if (isOpen && !formInitialized.current) {
      console.log("Form opening - initializing");
      
      // Set initialization flag to prevent re-runs
      formInitialized.current = true;
      
      // Determine which data to load based on form mode
      const resetData = (() => {
        if (currentData && (currentFormMode === 'edit' || currentFormMode === 'view')) {
          console.log("Initializing form with currentData");
          // Format data properly for the form - ensure IDs are strings
          const formattedData = { ...currentData };
          
          Object.keys(formattedData).forEach(key => {
            if (key.endsWith('Id') && formattedData[key] !== null && formattedData[key] !== undefined) {
              formattedData[key] = String(formattedData[key]);
            }
          });
          
          return formattedData;
        } else if (currentFormMode === 'create') {
          console.log("Initializing form with defaultValues");
          return defaultValues || {};
        }
        
        return {};
      })();
      
      // Use setTimeout to ensure we're outside React's render cycle
      const timeout = setTimeout(() => {
        if (isMounted) {
          console.log("Resetting form with data", Object.keys(resetData));
          safeReset(resetData, { keepDefaultValues: false });
        }
      }, 100);
      
      return () => {
        clearTimeout(timeout);
        isMounted = false;
      };
    }
    
    // Clean up on unmount
    return () => {
      isMounted = false;
    };
  }, [isOpen, currentFormMode, currentData, defaultValues, form]);
  
  // Ensure the form is marked as dirty when the user has filled in values
  useEffect(() => {
    if (isOpen && currentFormMode !== 'view') {
      // Mark form as dirty after a short delay if the user has entered values
      const timer = setTimeout(() => {
        const formValues = form.getValues();
        const hasValues = Object.keys(formValues).some(key => {
          const value = formValues[key];
          if (Array.isArray(value) && value.length > 0) return true;
          if (typeof value === 'string' && value.trim() !== '') return true;
          if (value !== null && value !== undefined && value !== '') return true;
          return false;
        });
        
        if (hasValues) {
          // Force the form to be marked as dirty
          console.log('Form has values, marking as dirty');
          
          // Find the first field that has a value and update it to trigger dirty state
          Object.keys(formValues).forEach(key => {
            const value = formValues[key];
            if (value !== null && value !== undefined && value !== '') {
              try {
                // Set the same value back to trigger isDirty
                form.setValue(key, value, { shouldDirty: true, shouldTouch: true });
              } catch (e) {
                console.error('Error setting form value:', e);
              }
            }
          });
        }
      }, 300);
      
      return () => clearTimeout(timer);
    }
  }, [isOpen, currentFormMode, form]);

  // Handle form submit - improved to handle all form submission scenarios
  const handleSubmit = form.handleSubmit(async (formData) => {
    if (isUsingStore) {
      store.setSubmitting(true);
    }
    
    try {
      // Execute the onSubmit function and await its completion
      const result = await onSubmit(formData);
      
      // Close dialog after successful submission
      if (currentFormMode === 'create' || currentFormMode === 'edit') {
        // Close dialog after form processing is complete
        // Wait a short delay to ensure all state updates have completed
        setTimeout(() => {
          if (isUsingStore) {
            store.closeModal();
          } else {
            onClose();
          }
        }, 100);
      }
      
      return result;
    } catch (error) {
      if (isUsingStore) {
        store.setSubmitError(error.message || 'An error occurred');
      }
      throw error;
    } finally {
      if (isUsingStore) {
        store.setSubmitting(false);
      }
    }
  });
  
  // Handle edit mode
  const handleEdit = () => {
    if (isUsingStore) {
      store.setFormMode('edit');
    } else if (onChangeFormMode) {
      onChangeFormMode('edit');
    }
  };
  
  // Handle modal close with completely redesigned closing mechanism
  const isClosingRef = useRef(false);
  const handleClose = useCallback(() => {
    console.log('EntityForm - handleClose called');
    
    // Critical - prevent any execution if already closing
    if (isClosingRef.current) {
      console.log('EntityForm - already closing, ignoring call');
      return;
    }
    
    // Set flag immediately to prevent any further calls during this closing cycle
    isClosingRef.current = true;
    
    // Break out of current event loop completely
    setTimeout(() => {
      try {
        // 1. Mark form as uninitialized first to prevent re-renders with stale data
        formInitialized.current = false;
        
        // 2. Use direct DOM manipulation to blur any active element to prevent focus issues
        if (typeof window !== 'undefined' && document.activeElement instanceof HTMLElement) {
          document.activeElement.blur();
        }
        
        // 3. After a small delay, reset the form state
        setTimeout(() => {
          try {
            // Clear form data
            form.reset({}, { 
              keepValues: false, 
              keepDefaultValues: false, 
              keepErrors: false, 
              keepDirty: false, 
              keepIsSubmitted: false, 
              keepTouched: false, 
              keepIsValid: false, 
              keepSubmitCount: false 
            });
            
            // 4. After form is reset, trigger actual close
            setTimeout(() => {
              if (isUsingStore) {
                store.closeModal();
              } else if (typeof onClose === 'function') {
                onClose();
              }
              
              // 5. Finally reset flag after a sufficient delay
              setTimeout(() => {
                isClosingRef.current = false;
              }, 500);
            }, 50);
          } catch (err) {
            console.error('Error during form reset in handleClose:', err);
            // Even if form reset fails, still close the form
            if (isUsingStore) {
              store.closeModal();
            } else if (typeof onClose === 'function') {
              onClose();
            }
            isClosingRef.current = false;
          }
        }, 50);
      } catch (err) {
        console.error('Error in handleClose:', err);
        isClosingRef.current = false;
      }
    }, 0);
  }, [isUsingStore, store, onClose, form]);
  
  // Choose container based on display mode
  const FormContainer = displayMode === 'sheet' ? EntityFormSheet : EntityFormDialog;
  
  // Determine if we should use the tabbed layout
  const useTabbedLayout = sectionsToRender.length > 1;
  
  return (
    <FormContainer
      open={isOpen}
      onClose={handleClose}
    >
      <FormProvider
        form={form}
        formMode={currentFormMode}
        data={currentData}
        onSubmit={handleSubmit}
        onEdit={handleEdit}
        onClose={handleClose}
        onDelete={onDelete}
        canEdit={canEdit}
        canDelete={canDelete}
        isSubmitting={currentSubmitting}
      >
        <RHFFormProvider {...form}>
        <EntityFormHeader
          formMode={currentFormMode}
          title={title}
          description={description}
          data={currentData}
          renderHeader={renderHeader}
        />
        
        <div className={`
          ${useTabbedLayout ? 'p-0 flex-1 flex flex-col' : 'px-6 py-6'} 
          ${displayMode === 'sheet' ? 'flex-1 overflow-y-auto' : 'max-h-[calc(100vh-220px)] overflow-y-auto'} 
          ${!useTabbedLayout ? 'bg-gray-50/50 dark:bg-gray-900/20' : ''}
        `}>
          <EntityFormContent
            formMode={currentFormMode}
            displayMode={displayMode}
            sections={sectionsToRender}
            fields={fields}
            layout={layout}
            data={currentData}
            form={form}
            submitError={currentSubmitError}
            onSubmit={handleSubmit}
          />
        </div>
        
        {/* Show appropriate footer based on tabbed or regular layout */}
        {useTabbedLayout ? (
          <EntityFormActions
            formMode={currentFormMode}
            isSubmitting={currentSubmitting}
            onCancel={handleClose}
            onSubmit={handleSubmit}
            form={form}
            sections={sectionsToRender}
          />
        ) : (
          <EntityFormFooter
            formMode={currentFormMode}
            isSubmitting={currentSubmitting}
            onClose={handleClose}
            onEdit={handleEdit}
            onSubmit={handleSubmit}
            onDelete={onDelete}
            data={currentData}
            canEdit={canEdit}
            canDelete={canDelete}
            renderFooter={renderFooter}
            sections={sectionsToRender}
          />
        )}
        </RHFFormProvider>
      </FormProvider>
    </FormContainer>
  );
}
</file>

<file path="components/entity-form/hooks/index.ts">
export * from './useFormState';
</file>

<file path="components/entity-form/hooks/useFormState.ts">
"use client";

import { useState, useCallback } from 'react';
import { useForm as useReactHookForm } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';
import { FormMode } from '@/features/core/tanstack-query-api';

export interface UseFormStateOptions {
  defaultValues?: any;
  validationSchema?: any;
  externalForm?: any;
}

export function useFormState({
  defaultValues = {},
  validationSchema,
  externalForm
}: UseFormStateOptions = {}) {
  // Form mode state
  const [formMode, setFormMode] = useState<FormMode>('view');
  
  // Create a safer form initialization
  let internalForm;
  
  try {
    // Use a more defensive approach to form initialization
    internalForm = useReactHookForm({
      defaultValues: defaultValues || {},
      resolver: validationSchema ? zodResolver(validationSchema) : undefined,
      mode: 'onChange' // Enable real-time validation as user types
    });
  } catch (error) {
    console.error('Error initializing form in useFormState:', error);
    
    // Provide a fallback form implementation to prevent crashes
    internalForm = {
      register: () => ({}),
      handleSubmit: (cb) => () => {},
      formState: { errors: {} },
      watch: () => {},
      setValue: () => {},
      getValues: () => ({}),
      reset: () => {},
      control: {}
    };
  }
  
  // Use external form if provided, otherwise use internal form
  const form = externalForm || internalForm;
  
  // Handle changing form mode
  const changeFormMode = useCallback((mode: FormMode) => {
    setFormMode(mode);
  }, []);
  
  // Computed read-only state
  const isReadOnly = formMode === 'view';
  
  return {
    form,
    formMode,
    isReadOnly,
    changeFormMode,
    setFormMode
  };
}
</file>

<file path="components/entity-form/index.ts">
export * from './EntityForm';
export * from './components';
export * from './context';
export * from './hooks';
</file>

<file path="components/EntityManager.tsx">
import React, { useCallback, useMemo, useRef, useEffect } from 'react';
import { 
  useEntityApi, 
  EntityApiEndpoints, 
  FormMode,
  BaseEntity
} from '@/features/core/tanstack-query-api';
import { EntityManagerProps } from '../types';
import { useAuth } from '@/features/core/auth';
import { EntityStore, createEntityStore } from '../store';
import { logger } from '../utils/logger';
import { useToast } from '@/components/ui/use-toast';
import { ToastProps } from '@/components/ui/toast';

// Import context and hooks
import { EntityManagerProvider } from '../context';
import { useEntityModal, useEntitySync, useEntityPermissions } from '../hooks';

// Import components
import { EntityManagerLayout } from './templates';
import { EntityTable } from './organisms';
import { EntityFormSheet } from './organisms';
import { EntityFormDialog } from './organisms';

/**
 * EntityManager component for managing entity data
 * This component is the main entry point for the entity management system
 */
export function EntityManager<TData extends BaseEntity = any, TFilter = any>({
  // Zustand store
  store,
  // Core configuration
  endpoints,
  permissions,
  labels,
  
  // Table configuration
  columns,
  tableProps,
  filterableColumns,
  searchableColumns,
  
  // Form configuration
  formFields,
  formSections,
  defaultValues,
  transformFormData,
  validateFormData,
  formProps,
  validationSchema,
  
  // Customization
  renderFilters,
  
  // Events
  onCreated,
  onUpdated,
  onDeleted,
  onFilterChange,
  
  // Additional features
  enableExport,
  exportData,
  enableRowSelection = false,
  bulkActions,
  enableInlineEdit = false,
  
  // UI behavior
  showDeleteInViewMode = false,
  formDisplayMode = 'dialog',
  
  // Default pagination
  defaultPageSize = 10,
  defaultFilters,
}: EntityManagerProps<TData, TFilter> & { store?: EntityStore<TData, TFilter> }) {
  // Initialize logger
  const componentLogger = useMemo(() => logger.createContext('EntityManager'), []);
  
  // Hooks
  const { isTokenValidated, isLoading: isAuthLoading } = useAuth();
  const { toast } = useToast();
  
  // Create a new store if one wasn't provided
  const entityStore = useMemo(() => {
    if (store) {
      componentLogger.info('Using provided store');
      return store;
    }
    
    componentLogger.info('Creating new entity store');
    return createEntityStore<TData, TFilter>('entity-manager', {
      defaultPageSize,
      defaultFilters,
      enableLogging: true
    });
  }, [store, defaultPageSize, defaultFilters, componentLogger]);
  
  // Use Zustand store selectors for fine-grained subscriptions
  const isModalOpen = entityStore(useCallback((state) => state.isModalOpen, []));
  const currentFormMode = entityStore(useCallback((state) => state.formMode, []));
  const selectedItem = entityStore(useCallback((state) => state.selectedItem, []));
  
  // Use entity api hook (from tanstack-query-api)
  const entityApi = useEntityApi<TData, TFilter>({
    endpoints,
    options: {
      onCreated,
      onUpdated,
      onDeleted,
      transformData: transformFormData,
      validateData: validateFormData,
      defaultPageSize,
      defaultFilters,
    }
  });
  
  // Use the modal management hook
  const { openModal, closeModal } = useEntityModal({
    entityStore,
    onSelectItem: entityApi.selectItem,
    onSetFormMode: entityApi.setFormMode,
  });
  
  // Use the entity sync hook to keep the store in sync with API data
  useEntitySync({
    entityStore,
    items: entityApi.items,
    pagination: entityApi.pagination,
    isLoading: entityApi.isLoading,
    error: entityApi.error,
    isAuthLoading,
    isTokenValidated,
  });
  
  // Check permissions
  const { canView, canCreate, canUpdate, canDelete } = useEntityPermissions({
    permissions,
  });
  
  // Handle API errors
  useEffect(() => {
    if (entityApi.error?.status === 401) {
      componentLogger.error(`Authentication error (401 Unauthorized). The user may need to log in again.`);
      toast({
        title: "Authentication Error",
        description: "Your session has expired. Please log in again.",
        variant: "destructive",
      });
    } else if (entityApi.error) {
      componentLogger.error(`API error encountered:`, entityApi.error);
    }
  }, [entityApi.error, toast, componentLogger]);
  
  // Prepare export function for the table
  const handleExport = useCallback(() => {
    if (exportData && entityApi.items) {
      exportData(entityApi.items);
    } else {
      // Simple CSV export if no custom export function is provided
      const data = entityApi.items || [];
      
      if (data.length === 0) {
        console.warn('No data to export');
        return;
      }
      
      // Convert to CSV
      const header = Object.keys(data[0]).join(',');
      const rows = data.map(item => 
        Object.values(item).map(value => 
          typeof value === 'string' && value.includes(',') ? `"${value}"` : value
        ).join(',')
      );
      
      const csv = [header, ...rows].join('\n');
      
      // Download file
      const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
      const url = URL.createObjectURL(blob);
      const link = document.createElement('a');
      link.setAttribute('href', url);
      link.setAttribute('download', `${labels.entityNamePlural.toLowerCase().replace(/\s+/g, '_')}_export.csv`);
      link.style.visibility = 'hidden';
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
    }
  }, [exportData, entityApi.items, labels.entityNamePlural]);
  
  // Create contextValue for the provider
  const contextValue = useMemo(() => ({
    entityApi,
    entityStore,
    labels,
    permissions,
    openModal,
    closeModal,
    canView,
    canCreate,
    canUpdate,
    canDelete,
    showToast: (props: Pick<ToastProps, 'title' | 'description' | 'variant'>) => {
      toast({
        title: props.title,
        description: props.description,
        variant: props.variant || 'default',
      });
    },
  }), [
    entityApi, 
    entityStore, 
    labels, 
    permissions, 
    openModal, 
    closeModal, 
    canView, 
    canCreate, 
    canUpdate, 
    canDelete, 
    toast
  ]);
  
  return (
    <EntityManagerProvider {...contextValue}>
      <EntityManagerLayout>
        {/* Data Table */}
        <EntityTable
          columns={columns}
          filterableColumns={filterableColumns}
          searchableColumns={searchableColumns}
          enableRowSelection={enableRowSelection}
          enableRowClick={true}
          tableProps={{
            ...tableProps,
            enableExport,
            onExport: enableExport ? handleExport : undefined,
          }}
          onRowClick={(item) => openModal('view', item)}
          onFilterChange={onFilterChange}
        />
        
        {/* Modal Form - Choose between dialog and sheet variants */}
        {formDisplayMode === 'sheet' ? (
          <EntityFormSheet
            open={isModalOpen}
            formMode={currentFormMode}
            onClose={closeModal}
            onChangeFormMode={(mode) => {
              componentLogger.debug(`Changing form mode to ${mode}`);
              entityApi.setFormMode(mode);
              entityStore.setFormMode(mode);
            }}
            formFields={formFields}
            formSections={formSections}
            defaultValues={defaultValues}
            formProps={formProps}
            validationSchema={validationSchema}
            isSubmitting={entityApi.isCreating || entityApi.isUpdating}
            showDeleteInViewMode={showDeleteInViewMode}
          />
        ) : (
          <EntityFormDialog
            open={isModalOpen}
            formMode={currentFormMode}
            onClose={closeModal}
            onChangeFormMode={(mode) => {
              componentLogger.debug(`Changing form mode to ${mode}`);
              entityApi.setFormMode(mode);
              entityStore.setFormMode(mode);
            }}
            formFields={formFields}
            formSections={formSections}
            defaultValues={defaultValues}
            formProps={formProps}
            validationSchema={validationSchema}
            isSubmitting={entityApi.isCreating || entityApi.isUpdating}
            showDeleteInViewMode={showDeleteInViewMode}
          />
        )}
      </EntityManagerLayout>
    </EntityManagerProvider>
  );
}
</file>

<file path="components/ErrorBoundary.tsx">
import React, { Component, ReactNode, ErrorInfo } from 'react';
import { Button } from '@/components/ui/button';
import { Alert, AlertTitle, AlertDescription } from '@/components/ui/alert';
import { logger } from '../utils/logger';

interface ErrorBoundaryProps {
  children: ReactNode;
  fallback?: ReactNode;
  onError?: (error: Error, errorInfo: ErrorInfo) => void;
  resetOnPropsChange?: boolean;
  loggerContext?: string;
}

interface ErrorBoundaryState {
  hasError: boolean;
  error: Error | null;
}

/**
 * ErrorBoundary component to catch and handle errors in React components
 * Wraps children components and displays a fallback UI when an error occurs
 */
export class ErrorBoundary extends Component<ErrorBoundaryProps, ErrorBoundaryState> {
  private boundaryLogger: typeof logger;
  
  constructor(props: ErrorBoundaryProps) {
    super(props);
    this.state = {
      hasError: false,
      error: null
    };
    
    // Create a logger for this error boundary
    this.boundaryLogger = logger.createContext(props.loggerContext || 'ErrorBoundary');
  }

  static getDerivedStateFromError(error: Error): ErrorBoundaryState {
    return {
      hasError: true,
      error
    };
  }

  componentDidCatch(error: Error, errorInfo: ErrorInfo): void {
    // Log the error
    this.boundaryLogger.error('Error caught by ErrorBoundary:', error.message, {
      error,
      componentStack: errorInfo.componentStack
    });
    
    // Call the onError prop if provided
    if (this.props.onError) {
      this.props.onError(error, errorInfo);
    }
  }

  // Reset error state when props change if resetOnPropsChange is true
  componentDidUpdate(prevProps: ErrorBoundaryProps): void {
    if (
      this.state.hasError &&
      this.props.resetOnPropsChange &&
      prevProps.children !== this.props.children
    ) {
      this.boundaryLogger.info('Resetting error state due to props change');
      this.setState({
        hasError: false,
        error: null
      });
    }
  }

  // Handler to reset the error state
  resetErrorState = (): void => {
    this.boundaryLogger.info('Manually resetting error state');
    this.setState({
      hasError: false,
      error: null
    });
  };

  render(): ReactNode {
    if (this.state.hasError) {
      // Custom fallback UI or default error UI
      if (this.props.fallback) {
        return this.props.fallback;
      }

      return (
        <div className="p-4 bg-gray-50 dark:bg-gray-900 rounded-lg shadow">
          <Alert variant="destructive">
            <AlertTitle>Something went wrong</AlertTitle>
            <AlertDescription>
              {this.state.error?.message || 'An unknown error occurred'}
            </AlertDescription>
          </Alert>
          <div className="mt-4 flex items-center justify-end space-x-2">
            <Button
              variant="outline"
              onClick={() => window.location.reload()}
              type="button" // Explicitly set type to prevent form submission
            >
              Reload Page
            </Button>
            <Button 
              onClick={this.resetErrorState}
              type="button" // Explicitly set type to prevent form submission
            >
              Try Again
            </Button>
          </div>
        </div>
      );
    }

    return this.props.children;
  }
}

/**
 * Higher-order component to wrap a component with an ErrorBoundary
 */
export function withErrorBoundary<P extends object>(
  Component: React.ComponentType<P>,
  options: Omit<ErrorBoundaryProps, 'children'> = {}
): React.FC<P> {
  const WithErrorBoundary: React.FC<P> = (props) => (
    <ErrorBoundary {...options}>
      <Component {...props} />
    </ErrorBoundary>
  );

  // Set display name for debugging
  const displayName = Component.displayName || Component.name || 'Component';
  WithErrorBoundary.displayName = `withErrorBoundary(${displayName})`;

  return WithErrorBoundary;
}

export default ErrorBoundary;
</file>

<file path="components/form-fields/index.ts">
import React from 'react';
import { FieldConfig } from '../../types/entity-form';
import { FormMode } from '@/features/core/tanstack-query-api';
import { TextFieldRenderer } from './renderers/TextFieldRenderer';
import { NumberFieldRenderer } from './renderers/NumberFieldRenderer';
import { SelectFieldRenderer } from './renderers/SelectFieldRenderer';
import { CheckboxFieldRenderer } from './renderers/CheckboxFieldRenderer';
import { DateFieldRenderer } from './renderers/DateFieldRenderer';
import { TextareaFieldRenderer } from './renderers/TextareaFieldRenderer';
import { SwitchFieldRenderer } from './renderers/SwitchFieldRenderer';

export interface FieldRendererProps {
  field: FieldConfig;
  form: any;
  formMode: FormMode;
  data?: any;
  isReadOnly: boolean;
  key?: string;
}

export function renderField(props: FieldRendererProps) {
  const field = props.field;
  const formMode = props.formMode;
  
  if (field.type === 'text' || field.type === 'email' || field.type === 'password') {
    return React.createElement(TextFieldRenderer, props);
  }
  
  if (field.type === 'number') {
    return React.createElement(NumberFieldRenderer, props);
  }
  
  if (field.type === 'select' || field.type === 'dependent-select') {
    return React.createElement(SelectFieldRenderer, props);
  }
  
  if (field.type === 'checkbox') {
    return React.createElement(CheckboxFieldRenderer, props);
  }
  
  if (field.type === 'date') {
    return React.createElement(DateFieldRenderer, props);
  }
  
  if (field.type === 'textarea') {
    return React.createElement(TextareaFieldRenderer, props);
  }
  
  if (field.type === 'switch') {
    return React.createElement(SwitchFieldRenderer, props);
  }
  
  return React.createElement(TextFieldRenderer, props);
}

export { TextFieldRenderer };
export { NumberFieldRenderer };
export { SelectFieldRenderer };
export { CheckboxFieldRenderer };
export { DateFieldRenderer };
export { TextareaFieldRenderer };
export { SwitchFieldRenderer };
</file>

<file path="components/form-fields/renderers/CheckboxFieldRenderer.tsx">
import React from 'react';
import { Checkbox } from '@/components/ui/checkbox';
import { FormControl, FormDescription, FormField, FormItem, FormLabel, FormMessage } from '@/components/ui/form';
import { FieldRendererProps } from '../index';

export function CheckboxFieldRenderer({ field, form, formMode, data, isReadOnly }: FieldRendererProps) {
  const isDisabled = field.disabled || isReadOnly || formMode === 'view';
  
  return (
    <FormField
      control={form.control}
      name={field.name}
      render={({ field: formField }) => (
        <FormItem className="flex flex-row items-start space-x-3 space-y-0 p-1">
          <FormControl>
            <Checkbox
              checked={formField.value}
              onCheckedChange={formField.onChange}
              disabled={isDisabled}
              aria-label={field.label}
              className={isDisabled ? 'opacity-50' : ''}
            />
          </FormControl>
          <div className="space-y-1 leading-none">
            <FormLabel>{field.label}</FormLabel>
            {field.description && <FormDescription>{field.description}</FormDescription>}
          </div>
          <FormMessage />
        </FormItem>
      )}
    />
  );
}
</file>

<file path="components/form-fields/renderers/DateFieldRenderer.tsx">
import React from 'react';
import { format } from 'date-fns';
import { Calendar } from '@/components/ui/calendar';
import { Popover, PopoverContent, PopoverTrigger } from '@/components/ui/popover';
import { Button } from '@/components/ui/button';
import { FormControl, FormDescription, FormField, FormItem, FormLabel, FormMessage } from '@/components/ui/form';
import { FieldRendererProps } from '../index';
import { cn } from '@/lib/utils';

export function DateFieldRenderer({ field, form, formMode, data, isReadOnly }: FieldRendererProps) {
  const isDisabled = field.disabled || isReadOnly || formMode === 'view';
  
  return (
    <FormField
      control={form.control}
      name={field.name}
      render={({ field: formField }) => (
        <FormItem className="flex flex-col">
          <FormLabel>{field.label}</FormLabel>
          <Popover>
            <PopoverTrigger asChild>
              <FormControl>
                <Button
                  variant="outline"
                  className={cn(
                    "pl-3 text-left font-normal",
                    !formField.value && "text-muted-foreground",
                    isDisabled && "bg-gray-50 dark:bg-gray-800 opacity-75"
                  )}
                  disabled={isDisabled}
                  aria-label={field.label}
                >
                  {formField.value ? (
                    format(new Date(formField.value), "PPP")
                  ) : (
                    <span>{field.placeholder || "Select a date"}</span>
                  )}
                  {/* Calendar icon using SVG directly instead of importing from radix-ui */}
                  <svg 
                    xmlns="http://www.w3.org/2000/svg" 
                    className="ml-auto h-4 w-4 opacity-50"
                    width="24" 
                    height="24" 
                    viewBox="0 0 24 24" 
                    fill="none" 
                    stroke="currentColor" 
                    strokeWidth="2" 
                    strokeLinecap="round" 
                    strokeLinejoin="round"
                  >
                    <rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect>
                    <line x1="16" y1="2" x2="16" y2="6"></line>
                    <line x1="8" y1="2" x2="8" y2="6"></line>
                    <line x1="3" y1="10" x2="21" y2="10"></line>
                  </svg>
                </Button>
              </FormControl>
            </PopoverTrigger>
            <PopoverContent className="w-auto p-0" align="start">
              <Calendar
                mode="single"
                selected={formField.value ? new Date(formField.value) : undefined}
                onSelect={formField.onChange}
                disabled={isDisabled}
                initialFocus
              />
            </PopoverContent>
          </Popover>
          {field.description && <FormDescription>{field.description}</FormDescription>}
          <FormMessage />
        </FormItem>
      )}
    />
  );
}
</file>

<file path="components/form-fields/renderers/NumberFieldRenderer.tsx">
import React from 'react';
import { Input } from '@/components/ui/input';
import { FormControl, FormDescription, FormField, FormItem, FormLabel, FormMessage } from '@/components/ui/form';
import { FieldRendererProps } from '../index';

export function NumberFieldRenderer({ field, form, formMode, data, isReadOnly }: FieldRendererProps) {
  const isDisabled = field.disabled || isReadOnly || formMode === 'view';
  
  return (
    <FormField
      control={form.control}
      name={field.name}
      render={({ field: formField }) => (
        <FormItem>
          <FormLabel>{field.label}</FormLabel>
          <FormControl>
            <Input
              {...formField}
              disabled={isDisabled}
              placeholder={field.placeholder}
              type="number"
              min={field.min}
              max={field.max}
              step={field.step || 1}
              className={isDisabled ? 'bg-gray-50 dark:bg-gray-800 opacity-75' : ''}
              aria-label={field.label}
              onChange={(e) => {
                // Convert string value to number for number inputs
                const value = e.target.value === '' ? '' : Number(e.target.value);
                formField.onChange(value);
              }}
            />
          </FormControl>
          {field.description && <FormDescription>{field.description}</FormDescription>}
          <FormMessage />
        </FormItem>
      )}
    />
  );
}
</file>

<file path="components/form-fields/renderers/RadioFieldRenderer.tsx">
import React, { useEffect, useState } from 'react';
import { RadioGroup, RadioGroupItem } from '@/components/ui/radio-group';
import { FormControl, FormDescription, FormField, FormItem, FormLabel, FormMessage } from '@/components/ui/form';
import { FieldRendererProps } from '../index';

export function RadioFieldRenderer({ field, form, formMode, data, isReadOnly }: FieldRendererProps) {
  const isDisabled = field.disabled || isReadOnly || formMode === 'view';
  const [options, setOptions] = useState(field.options || []);
  
  // Handle dynamic options loading
  useEffect(() => {
    const loadOptions = async () => {
      if (field.loadOptions) {
        try {
          const loadedOptions = await field.loadOptions(data);
          setOptions(loadedOptions);
        } catch (error) {
          console.error('Error loading options:', error);
        }
      }
    };
    
    loadOptions();
  }, [field, data]);
  
  return (
    <FormField
      control={form.control}
      name={field.name}
      render={({ field: formField }) => (
        <FormItem>
          <FormLabel>{field.label}</FormLabel>
          <FormControl>
            <RadioGroup
              onValueChange={formField.onChange}
              defaultValue={formField.value}
              value={formField.value}
              disabled={isDisabled}
              className="flex flex-col space-y-2"
            >
              {options.map((option) => (
                <FormItem 
                  key={option.value} 
                  className="flex items-center space-x-3 space-y-0"
                >
                  <FormControl>
                    <RadioGroupItem
                      value={option.value.toString()}
                      className={isDisabled ? 'opacity-50' : ''}
                    />
                  </FormControl>
                  <FormLabel className="font-normal">
                    {option.label}
                  </FormLabel>
                </FormItem>
              ))}
            </RadioGroup>
          </FormControl>
          {field.description && <FormDescription>{field.description}</FormDescription>}
          <FormMessage />
        </FormItem>
      )}
    />
  );
}
</file>

<file path="components/form-fields/renderers/SelectFieldRenderer.tsx">
import React, { useEffect, useState } from 'react';
import { 
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue 
} from '@/components/ui/select';
import { FormControl, FormDescription, FormField, FormItem, FormLabel, FormMessage } from '@/components/ui/form';
import { FieldRendererProps } from '../index';

export function SelectFieldRenderer({ field, form, formMode, data, isReadOnly }: FieldRendererProps) {
  const isDisabled = field.disabled || isReadOnly || formMode === 'view';
  const [options, setOptions] = useState(field.options || []);
  
  // Handle dynamic options loading
  useEffect(() => {
    const loadOptions = async () => {
      if (field.loadOptions) {
        try {
          const loadedOptions = await field.loadOptions(data);
          setOptions(loadedOptions);
        } catch (error) {
          console.error('Error loading options:', error);
        }
      }
    };
    
    loadOptions();
  }, [field, data]);
  
  return (
    <FormField
      control={form.control}
      name={field.name}
      render={({ field: formField }) => (
        <FormItem>
          <FormLabel>{field.label}</FormLabel>
          <Select
            disabled={isDisabled}
            onValueChange={formField.onChange}
            defaultValue={formField.value}
            value={formField.value}
          >
            <FormControl>
              <SelectTrigger 
                className={isDisabled ? 'bg-gray-50 dark:bg-gray-800 opacity-75' : ''}
                aria-label={field.label}
              >
                <SelectValue placeholder={field.placeholder || 'Select an option'} />
              </SelectTrigger>
            </FormControl>
            <SelectContent>
              {options.map((option) => (
                <SelectItem key={option.value} value={option.value.toString()}>
                  {option.label}
                </SelectItem>
              ))}
            </SelectContent>
          </Select>
          {field.description && <FormDescription>{field.description}</FormDescription>}
          <FormMessage />
        </FormItem>
      )}
    />
  );
}
</file>

<file path="components/form-fields/renderers/SwitchFieldRenderer.tsx">
import React from 'react';
import { Switch } from '@/components/ui/switch';
import { FormControl, FormDescription, FormField, FormItem, FormLabel, FormMessage } from '@/components/ui/form';
import { FieldRendererProps } from '../index';

export function SwitchFieldRenderer({ field, form, formMode, data, isReadOnly }: FieldRendererProps) {
  const isDisabled = field.disabled || isReadOnly || formMode === 'view';
  
  return (
    <FormField
      control={form.control}
      name={field.name}
      render={({ field: formField }) => (
        <FormItem className="flex flex-row items-center justify-between p-1">
          <div className="space-y-0.5">
            <FormLabel>{field.label}</FormLabel>
            {field.description && <FormDescription>{field.description}</FormDescription>}
          </div>
          <FormControl>
            <Switch
              checked={formField.value}
              onCheckedChange={formField.onChange}
              disabled={isDisabled}
              aria-label={field.label}
              className={isDisabled ? 'opacity-50' : ''}
            />
          </FormControl>
          <FormMessage />
        </FormItem>
      )}
    />
  );
}
</file>

<file path="components/form-fields/renderers/TextareaFieldRenderer.tsx">
import React from 'react';
import { Textarea } from '@/components/ui/textarea';
import { FormControl, FormDescription, FormField, FormItem, FormLabel, FormMessage } from '@/components/ui/form';
import { FieldRendererProps } from '../index';

export function TextareaFieldRenderer({ field, form, formMode, data, isReadOnly }: FieldRendererProps) {
  const isDisabled = field.disabled || isReadOnly || formMode === 'view';
  
  return (
    <FormField
      control={form.control}
      name={field.name}
      render={({ field: formField }) => (
        <FormItem>
          <FormLabel>{field.label}</FormLabel>
          <FormControl>
            <Textarea
              {...formField}
              disabled={isDisabled}
              placeholder={field.placeholder}
              className={isDisabled ? 'bg-gray-50 dark:bg-gray-800 opacity-75 min-h-[100px]' : 'min-h-[100px]'}
              aria-label={field.label}
              rows={field.rows || 4}
            />
          </FormControl>
          {field.description && <FormDescription>{field.description}</FormDescription>}
          <FormMessage />
        </FormItem>
      )}
    />
  );
}
</file>

<file path="components/form-fields/renderers/TextFieldRenderer.tsx">
import React from 'react';
import { Input } from '@/components/ui/input';
import { FormControl, FormDescription, FormField, FormItem, FormLabel, FormMessage } from '@/components/ui/form';
import { FieldRendererProps } from '../index';

export function TextFieldRenderer({ field, form, formMode, data, isReadOnly }: FieldRendererProps) {
  const isDisabled = field.disabled || isReadOnly || formMode === 'view';
  
  return (
    <FormField
      control={form.control}
      name={field.name}
      render={({ field: formField }) => (
        <FormItem>
          <FormLabel>{field.label}</FormLabel>
          <FormControl>
            <Input
              {...formField}
              disabled={isDisabled}
              placeholder={field.placeholder}
              type="text"
              className={isDisabled ? 'bg-gray-50 dark:bg-gray-800 opacity-75' : ''}
              aria-label={field.label}
            />
          </FormControl>
          {field.description && <FormDescription>{field.description}</FormDescription>}
          <FormMessage />
        </FormItem>
      )}
    />
  );
}
</file>

<file path="components/index.ts">
// Main component
export { EntityManager } from './EntityManager';
export { ErrorBoundary } from './ErrorBoundary';

// Atoms
export * from './atoms';

// Molecules
export * from './molecules';

// Organisms
export * from './organisms';

// Templates
export * from './templates';

// Re-export needed components from nested directories
export * from './data-table';
export * from './entity-form';
</file>

<file path="components/molecules/EntityActionBar.tsx">
import React from 'react';
import { Button } from '@/components/ui/button';
import { useEntityManager } from '../../context';

interface EntityActionBarProps {
  onAdd?: () => void;
  onExport?: () => void;
  enableExport?: boolean;
}

/**
 * Component for the main action buttons (add, export, etc.)
 */
export function EntityActionBar({
  onAdd,
  onExport,
  enableExport = false,
}: EntityActionBarProps) {
  const { labels, canCreate } = useEntityManager();
  
  return (
    <div className="flex justify-end gap-2 mb-4">
      {enableExport && onExport && (
        <Button variant="outline" onClick={onExport}>
          <svg
            xmlns="http://www.w3.org/2000/svg"
            width="16"
            height="16"
            viewBox="0 0 24 24"
            fill="none"
            stroke="currentColor"
            strokeWidth="2"
            strokeLinecap="round"
            strokeLinejoin="round"
            className="mr-2"
          >
            <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4" />
            <polyline points="7 10 12 15 17 10" />
            <line x1="12" y1="15" x2="12" y2="3" />
          </svg>
          Export
        </Button>
      )}
      
      {canCreate && onAdd && (
        <Button onClick={onAdd}>
          <svg
            xmlns="http://www.w3.org/2000/svg"
            width="16"
            height="16"
            viewBox="0 0 24 24"
            fill="none"
            stroke="currentColor"
            strokeWidth="2"
            strokeLinecap="round"
            strokeLinejoin="round"
            className="mr-2"
          >
            <line x1="12" y1="5" x2="12" y2="19" />
            <line x1="5" y1="12" x2="19" y2="12" />
          </svg>
          Add {labels.entityName}
        </Button>
      )}
    </div>
  );
}
</file>

<file path="components/molecules/EntityFormControls.tsx">
import React from 'react';
import { Button } from '@/components/ui/button';
import { FormMode } from '@/features/core/tanstack-query-api';
import { useEntityManager } from '../../context';

interface EntityFormControlsProps {
  formMode: FormMode;
  onChangeFormMode: (mode: FormMode) => void;
  onSubmit?: () => void;
  onDelete?: () => void;
  onClose: () => void;
  isSubmitting?: boolean;
  canEdit: boolean;
  canDelete: boolean;
}

/**
 * Form control buttons for the entity form (edit, delete, submit, cancel)
 */
export function EntityFormControls({
  formMode,
  onChangeFormMode,
  onSubmit,
  onDelete,
  onClose,
  isSubmitting = false,
  canEdit,
  canDelete,
}: EntityFormControlsProps) {
  const { labels } = useEntityManager();
  
  // View mode controls
  if (formMode === 'view') {
    return (
      <div className="flex justify-between">
        <div>
          {canDelete && onDelete && (
            <Button
              variant="destructive"
              onClick={onDelete}
              className="mr-2"
            >
              <svg
                xmlns="http://www.w3.org/2000/svg"
                width="16"
                height="16"
                viewBox="0 0 24 24"
                fill="none"
                stroke="currentColor"
                strokeWidth="2"
                strokeLinecap="round"
                strokeLinejoin="round"
                className="mr-2"
              >
                <path d="M3 6h18" />
                <path d="M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6" />
                <path d="M8 6V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2" />
                <line x1="10" y1="11" x2="10" y2="17" />
                <line x1="14" y1="11" x2="14" y2="17" />
              </svg>
              Delete
            </Button>
          )}
        </div>
        <div>
          {canEdit && (
            <Button
              variant="outline"
              onClick={() => onChangeFormMode('edit')}
              className="mr-2"
            >
              <svg
                xmlns="http://www.w3.org/2000/svg"
                width="16"
                height="16"
                viewBox="0 0 24 24"
                fill="none"
                stroke="currentColor"
                strokeWidth="2"
                strokeLinecap="round"
                strokeLinejoin="round"
                className="mr-2"
              >
                <path d="M17 3a2.85 2.83 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5Z" />
                <path d="m15 5 4 4" />
              </svg>
              Edit
            </Button>
          )}
          <Button variant="ghost" onClick={onClose}>
            Close
          </Button>
        </div>
      </div>
    );
  }
  
  // Edit or Create mode controls
  return (
    <div className="flex justify-end space-x-2">
      <Button
        variant="ghost"
        onClick={formMode === 'edit' ? () => onChangeFormMode('view') : onClose}
        disabled={isSubmitting}
      >
        Cancel
      </Button>
      {onSubmit && (
        <Button
          type="submit"
          onClick={onSubmit}
          disabled={isSubmitting}
        >
          {isSubmitting ? (
            <>
              <svg
                className="animate-spin -ml-1 mr-3 h-4 w-4 text-white"
                xmlns="http://www.w3.org/2000/svg"
                fill="none"
                viewBox="0 0 24 24"
              >
                <circle
                  className="opacity-25"
                  cx="12"
                  cy="12"
                  r="10"
                  stroke="currentColor"
                  strokeWidth="4"
                ></circle>
                <path
                  className="opacity-75"
                  fill="currentColor"
                  d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"
                ></path>
              </svg>
              Saving...
            </>
          ) : (
            'Save'
          )}
        </Button>
      )}
    </div>
  );
}
</file>

<file path="components/molecules/index.ts">
export { EntityActionBar } from './EntityActionBar';
export { EntityFormControls } from './EntityFormControls';
</file>

<file path="components/organisms/EntityFormDialog.tsx">
import React, { useState } from 'react';
import { EntityForm } from '../entity-form';
import { useEntityManager } from '../../context';
import { BaseEntity, FormMode } from '@/features/core/tanstack-query-api';
import { FieldConfig, SectionConfig } from '../../types';

interface EntityFormDialogProps<TData extends BaseEntity = any> {
  open: boolean;
  formMode: FormMode;
  onClose: () => void;
  onChangeFormMode: (mode: FormMode) => void;
  formFields?: FieldConfig[];
  formSections?: SectionConfig[];
  defaultValues?: Partial<TData>;
  formProps?: any;
  validationSchema?: any;
  isSubmitting?: boolean;
  showDeleteInViewMode?: boolean;
}

/**
 * Dialog-style form for entity management
 */
export function EntityFormDialog<TData extends BaseEntity = any>({
  open,
  formMode,
  onClose,
  onChangeFormMode,
  formFields,
  formSections,
  defaultValues,
  formProps,
  validationSchema,
  isSubmitting = false,
  showDeleteInViewMode = false,
}: EntityFormDialogProps<TData>) {
  const {
    entityApi,
    entityStore,
    labels,
    canUpdate,
    canDelete,
  } = useEntityManager<TData>();
  
  const [error, setError] = useState<string | null>(null);
  
  // Handle submit
  const handleSubmit = async (formData: any) => {
    try {
      setError(null);
      const result = await entityApi.handleSubmit(formData);
      return result;
    } catch (error) {
      setError(error instanceof Error ? error.message : String(error));
      throw error;
    }
  };
  
  // Handle delete
  const handleDelete = (id: string | number) => {
    return entityApi.delete(id);
  };
  
  return (
    <EntityForm
      open={open}
      onClose={onClose}
      displayMode="dialog"
      formMode={formMode}
      onChangeFormMode={onChangeFormMode}
      title={formMode === 'create' 
        ? labels.createTitle || `Create ${labels.entityName}`
        : formMode === 'edit' 
          ? labels.editTitle || `Edit ${labels.entityName}`
          : labels.viewTitle || `${labels.entityName} Details`
      }
      description={formMode === 'create' 
        ? labels.createDescription
        : formMode === 'edit' 
          ? labels.editDescription
          : labels.viewDescription
      }
      fields={formFields}
      sections={formSections}
      data={entityApi.selectedItem}
      onSubmit={handleSubmit}
      onDelete={canDelete && (formMode !== 'view' || showDeleteInViewMode) ? 
        handleDelete : undefined}
      canEdit={canUpdate}
      canDelete={canDelete && (formMode !== 'view' || showDeleteInViewMode)}
      defaultValues={defaultValues}
      validationSchema={validationSchema}
      isSubmitting={isSubmitting || entityApi.isCreating || entityApi.isUpdating}
      error={error}
      store={entityStore}
      {...formProps}
    />
  );
}
</file>

<file path="components/organisms/EntityFormSheet.tsx">
import React, { useState, useRef, useCallback } from 'react';
import { EntityForm } from '../entity-form/EntityForm';
import { useEntityManager } from '../../context';
import { BaseEntity, FormMode } from '@/features/core/tanstack-query-api';
import { FieldConfig, SectionConfig } from '../../types';

interface EntityFormSheetProps<TData extends BaseEntity = any> {
  open: boolean;
  formMode: FormMode;
  onClose: () => void;
  onChangeFormMode: (mode: FormMode) => void;
  formFields?: FieldConfig[];
  formSections?: SectionConfig[];
  defaultValues?: Partial<TData>;
  formProps?: any;
  validationSchema?: any;
  isSubmitting?: boolean;
  showDeleteInViewMode?: boolean;
}

/**
 * Sheet-style form for entity management
 */
export function EntityFormSheet<TData extends BaseEntity = any>({
  open,
  formMode,
  onClose,
  onChangeFormMode,
  formFields,
  formSections,
  defaultValues,
  formProps,
  validationSchema,
  isSubmitting = false,
  showDeleteInViewMode = false,
}: EntityFormSheetProps<TData>) {
  const {
    entityApi,
    labels,
    canUpdate,
    canDelete,
  } = useEntityManager<TData>();
  
  const [error, setError] = useState<string | null>(null);
  const closeHandlingRef = useRef(false);
  
  // Handle submit
  const handleSubmit = async (formData: any) => {
    try {
      setError(null);
      const result = await entityApi.handleSubmit(formData);
      return result;
    } catch (error) {
      setError(error instanceof Error ? error.message : String(error));
      throw error;
    }
  };
  
  // Handle delete
  const handleDelete = (id: string | number) => {
    return entityApi.delete(id);
  };
  
  // Handle close with guard against multiple executions
  const safeOnClose = useCallback(() => {
    if (closeHandlingRef.current) return;
    closeHandlingRef.current = true;
    
    // Call the original onClose
    onClose();
    
    // Reset flag after delay
    setTimeout(() => {
      closeHandlingRef.current = false;
    }, 500);
  }, [onClose]);
  
  return (
    <EntityForm
      open={open}
      onClose={safeOnClose}
      displayMode="sheet"
      formMode={formMode}
      onChangeFormMode={onChangeFormMode}
      title={formMode === 'create' 
        ? labels.createTitle || `Create ${labels.entityName}`
        : formMode === 'edit' 
          ? labels.editTitle || `Edit ${labels.entityName}`
          : labels.viewTitle || `${labels.entityName} Details`
      }
      description={formMode === 'create' 
        ? labels.createDescription
        : formMode === 'edit' 
          ? labels.editDescription
          : labels.viewDescription
      }
      fields={formFields}
      sections={formSections}
      data={entityApi.selectedItem}
      onSubmit={handleSubmit}
      onDelete={canDelete && (formMode !== 'view' || showDeleteInViewMode) ? 
        handleDelete : undefined}
      canEdit={canUpdate}
      canDelete={canDelete && (formMode !== 'view' || showDeleteInViewMode)}
      defaultValues={defaultValues}
      validationSchema={validationSchema}
      isSubmitting={isSubmitting || entityApi.isCreating || entityApi.isUpdating}
      submitError={error}
      {...formProps}
    />
  );
}
</file>

<file path="components/organisms/EntityTable.tsx">
import React from 'react';
import { EntityDataTable, EntityDataTableProps } from '../data-table';
import { useEntityManager } from '../../context';
import { BaseEntity } from '@/features/core/tanstack-query-api';
import { ColumnDef, ColumnFiltersState } from '@tanstack/react-table';
import { RowAction } from '../../types/data-table';

interface EntityTableProps<TData extends BaseEntity = any, TFilter = any> {
  columns: ColumnDef<TData, any>[];
  filterableColumns?: string[];
  searchableColumns?: string[];
  enableRowSelection?: boolean;
  enableRowClick?: boolean;
  tableProps?: Partial<EntityDataTableProps<TData, any>>;
  onRowClick?: (item: TData) => void;
  onFilterChange?: (filters: TFilter) => void;
}

/**
 * Component for displaying entity data in a table
 * Connects to EntityManager context for data access
 */
export function EntityTable<TData extends BaseEntity = any, TFilter = any>({
  columns,
  filterableColumns,
  searchableColumns,
  enableRowSelection = false,
  enableRowClick = true,
  tableProps,
  onRowClick,
  onFilterChange,
}: EntityTableProps<TData, TFilter>) {
  const {
    entityApi,
    entityStore,
    labels,
    openModal,
    canCreate,
    canUpdate,
    canDelete,
    permissions,
  } = useEntityManager<TData, TFilter>();
  
  // Define row actions
  const rowActions: RowAction<TData>[] = [
    {
      label: 'View',
      icon: <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className="lucide lucide-eye"><path d="M2 12s3-7 10-7 10 7 10 7-3 7-10 7-10-7-10-7Z"/><circle cx="12" cy="12" r="3"/></svg>,
      onClick: (item: TData) => openModal('view', item),
      permission: permissions ? { 
        feature: permissions.feature, 
        action: permissions.view || 'VIEW' 
      } : undefined,
    },
    {
      label: 'Edit',
      icon: <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className="lucide lucide-pencil"><path d="M17 3a2.85 2.83 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5Z"/><path d="m15 5 4 4"/></svg>,
      onClick: (item: TData) => openModal('edit', item),
      permission: permissions && permissions.update ? { 
        feature: permissions.feature, 
        action: permissions.update 
      } : undefined,
      // Stop event propagation to prevent opening view modal when clicking edit
      stopPropagation: true,
    },
    {
      label: 'Delete',
      icon: <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className="lucide lucide-trash-2"><path d="M3 6h18"/><path d="M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6"/><path d="M8 6V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2"/><line x1="10" x2="10" y1="11" y2="17"/><line x1="14" x2="14" y1="11" y2="17"/></svg>,
      onClick: entityApi.delete,
      variant: 'destructive',
      permission: permissions && permissions.delete ? { 
        feature: permissions.feature, 
        action: permissions.delete 
      } : undefined,
      showConfirm: true,
      confirmTitle: labels.deleteConfirmTitle || `Delete ${labels.entityName}`,
      confirmDescription: labels.deleteConfirmDescription || `Are you sure you want to delete this ${labels.entityName.toLowerCase()}? This action cannot be undone.`,
      confirmActionLabel: 'Delete',
      // Stop event propagation to prevent opening view modal when clicking delete
      stopPropagation: true,
    },
  ];
  
  // Handle export
  const handleExport = () => {
    if (tableProps?.onExport && entityApi.items) {
      tableProps.onExport(entityApi.items);
    } else {
      // Simple CSV export if no custom export function is provided
      const data = entityApi.items || [];
      
      if (data.length === 0) {
        console.warn('No data to export');
        return;
      }
      
      // Convert to CSV
      const header = Object.keys(data[0]).join(',');
      const rows = data.map(item => 
        Object.values(item).map(value => 
          typeof value === 'string' && value.includes(',') ? `"${value}"` : value
        ).join(',')
      );
      
      const csv = [header, ...rows].join('\n');
      
      // Download file
      const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
      const url = URL.createObjectURL(blob);
      const link = document.createElement('a');
      link.setAttribute('href', url);
      link.setAttribute('download', `${labels.entityNamePlural.toLowerCase().replace(/\s+/g, '_')}_export.csv`);
      link.style.visibility = 'hidden';
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
    }
  };
  
  // Handle filter changes and convert to TFilter type when needed
  const handleFilterChange = (filters: ColumnFiltersState) => {
    if (onFilterChange) {
      // Convert column filters to the expected filter format
      const filterObject = filters.reduce((acc, filter) => {
        acc[filter.id] = filter.value;
        return acc;
      }, {} as Record<string, any>);
      
      onFilterChange(filterObject as unknown as TFilter);
    }
  };
  
  return (
    <EntityDataTable
      columns={columns}
      data={entityApi.items}
      actions={rowActions}
      onExport={tableProps?.enableExport ? handleExport : undefined}
      onAdd={canCreate ? () => openModal('create', null) : undefined}
      addPermission={permissions && permissions.create ? {
        feature: permissions.feature,
        action: permissions.create
      } : undefined}
      filterableColumns={filterableColumns}
      searchableColumns={searchableColumns}
      enableMultiSelect={enableRowSelection}
      onRowClick={onRowClick || ((item) => openModal('view', item))}
      enableRowClick={enableRowClick}
      isLoading={entityApi.isLoading}
      title={labels.entityNamePlural}
      description={`Manage ${labels.entityNamePlural.toLowerCase()}`}
      
      // Server-side pagination
      totalItems={entityApi.pagination.totalItems}
      pageCount={entityApi.pagination.totalPages}
      currentPage={entityApi.pagination.currentPage}
      onPageChange={entityApi.onPageChange}
      onPageSizeChange={entityApi.onPageSizeChange}
      onSortingChange={entityApi.onSortChange}
      onFilterChange={handleFilterChange}
      
      // Zustand store
      store={entityStore}
      
      // Additional props
      {...tableProps}
    />
  );
}
</file>

<file path="components/organisms/index.ts">
export { EntityTable } from './EntityTable';
export { EntityFormSheet } from './EntityFormSheet';
export { EntityFormDialog } from './EntityFormDialog';
</file>

<file path="components/templates/EntityManagerLayout.tsx">
import React, { ReactNode } from 'react';
import { ErrorBoundary } from '../ErrorBoundary';
import { EntityNoAccess } from '../atoms';
import { useEntityManager } from '../../context';

interface EntityManagerLayoutProps {
  children: ReactNode;
}

/**
 * Layout template for the EntityManager component
 */
export function EntityManagerLayout({ children }: EntityManagerLayoutProps) {
  const { canView, labels } = useEntityManager();
  
  // If no permissions, don't render the component
  if (!canView) {
    return <EntityNoAccess entityNamePlural={labels.entityNamePlural} />;
  }
  
  return (
    <ErrorBoundary 
      onError={(error) => console.error('Error in EntityManager:', error.message)}
      resetOnPropsChange
    >
      <div className="space-y-6 w-full">
        {children}
      </div>
    </ErrorBoundary>
  );
}
</file>

<file path="components/templates/index.ts">
export { EntityManagerLayout } from './EntityManagerLayout';
</file>

<file path="context/EntityManagerContext.tsx">
import React, { createContext, useContext, useMemo, ReactNode } from 'react';
import { 
  useEntityApi, 
  EntityApiEndpoints, 
  FormMode,
  BaseEntity
} from '@/features/core/tanstack-query-api';
import { EntityStore } from '../store';
import { EntityLabels, EntityPermissions } from '../types';
import { useToast } from '@/components/ui/use-toast';

/**
 * Context type definition for EntityManager
 */
export interface EntityManagerContextValue<TData extends BaseEntity = any, TFilter = any> {
  // Core API
  entityApi: ReturnType<typeof useEntityApi<TData, TFilter>>;
  
  // Store
  entityStore: EntityStore<TData, TFilter>;
  
  // Configuration
  labels: EntityLabels;
  permissions?: EntityPermissions;
  
  // Modal management
  openModal: (mode: FormMode, item?: TData | null) => void;
  closeModal: () => void;
  
  // Permission helpers
  canView: boolean;
  canCreate: boolean;
  canUpdate: boolean;
  canDelete: boolean;
  
  // UI helpers
  showToast: (props: { title: string; description?: string; variant?: 'default' | 'destructive' }) => void;
}

// Create the context with a default value of undefined
const EntityManagerContext = createContext<EntityManagerContextValue | undefined>(undefined);

/**
 * Props for the EntityManagerProvider component
 */
export interface EntityManagerProviderProps<TData extends BaseEntity = any, TFilter = any> {
  children: ReactNode;
  entityApi: ReturnType<typeof useEntityApi<TData, TFilter>>;
  entityStore: EntityStore<TData, TFilter>;
  labels: EntityLabels;
  permissions?: EntityPermissions;
  openModal: (mode: FormMode, item?: TData | null) => void;
  closeModal: () => void;
  canView: boolean;
  canCreate: boolean;
  canUpdate: boolean;
  canDelete: boolean;
}

/**
 * Context provider for the EntityManager
 */
export function EntityManagerProvider<TData extends BaseEntity = any, TFilter = any>({
  children,
  entityApi,
  entityStore,
  labels,
  permissions,
  openModal,
  closeModal,
  canView,
  canCreate,
  canUpdate,
  canDelete,
}: EntityManagerProviderProps<TData, TFilter>) {
  const { toast } = useToast();
  
  // Memoize the context value to prevent unnecessary re-renders
  const contextValue = useMemo(
    () => ({
      entityApi,
      entityStore,
      labels,
      permissions,
      openModal,
      closeModal,
      canView,
      canCreate,
      canUpdate,
      canDelete,
      showToast: (props) => {
        toast({
          title: props.title,
          description: props.description,
          variant: props.variant || 'default',
        });
      },
    }),
    [
      entityApi,
      entityStore,
      labels,
      permissions,
      openModal,
      closeModal,
      canView,
      canCreate,
      canUpdate,
      canDelete,
      toast,
    ]
  );

  return (
    <EntityManagerContext.Provider value={contextValue}>
      {children}
    </EntityManagerContext.Provider>
  );
}

/**
 * Custom hook to use the EntityManager context
 */
export function useEntityManager<TData extends BaseEntity = any, TFilter = any>(): EntityManagerContextValue<TData, TFilter> {
  const context = useContext(EntityManagerContext);
  
  if (context === undefined) {
    throw new Error('useEntityManager must be used within an EntityManagerProvider');
  }
  
  return context as EntityManagerContextValue<TData, TFilter>;
}
</file>

<file path="context/index.ts">
export { 
  EntityManagerProvider, 
  useEntityManager,
  type EntityManagerContextValue,
  type EntityManagerProviderProps
} from './EntityManagerContext';
</file>

<file path="hooks/index.ts">
export { useEntityModal } from './useEntityModal';
export { useEntitySync } from './useEntitySync';
export { useEntityPermissions } from './useEntityPermissions';
export { useDependentFields as useFormDependencies } from './useFormDependencies';
</file>

<file path="hooks/useDependentOptions.ts">
import { useApiQuery } from '@/features/core/tanstack-query-api';
import { useMemo } from 'react';
import { FetchOptionsConfig, useDependentFields } from '../utils/dependent-fields';

interface DependentOptionConfig {
  /**
   * Base endpoint to fetch options from
   */
  endpoint: string;
  
  /**
   * The property to use as the option label
   * @default 'name'
   */
  labelKey?: string;
  
  /**
   * The property to use as the option value
   * @default 'id'
   */
  valueKey?: string;
  
  /**
   * Dependencies for this endpoint. When a key matches a URL parameter,
   * it will be added to the URL directly, otherwise it will be added as a query parameter.
   * 
   * Example: 
   * - endpoint: '/api/countries/{countryId}/cities'
   * - dependencies: { countryId: '123' }
   * - result: '/api/countries/123/cities'
   * 
   * Example 2:
   * - endpoint: '/api/cities'
   * - dependencies: { countryId: '123' }
   * - result: '/api/cities?countryId=123'
   */
  dependencies?: Record<string, any>;
  
  /**
   * Additional query parameters to include in the request
   */
  queryParams?: Record<string, any>;
  
  /**
   * Cache time in milliseconds
   * @default 5 minutes
   */
  cacheTime?: number;
  
  /**
   * Stale time in milliseconds
   * @default 1 minute
   */
  staleTime?: number;
}

/**
 * Custom hook to fetch options for dependent select fields
 * 
 * @deprecated Use the new useDependentFields hook from utils/dependent-fields instead.
 * This hook is maintained for backward compatibility and will be removed in a future version.
 */
export function useDependentOptions(config: DependentOptionConfig) {
  const {
    endpoint,
    labelKey = 'name',
    valueKey = 'id',
    dependencies = {},
    queryParams = {},
    cacheTime = 5 * 60 * 1000, // 5 minutes
    staleTime = 60 * 1000, // 1 minute
  } = config;
  
  // Process the endpoint with any URL parameters
  const processedEndpoint = useMemo(() => {
    let url = endpoint;
    const queryParameters = { ...queryParams };
    
    // Process dependencies
    Object.entries(dependencies).forEach(([key, value]) => {
      // Skip undefined, null, or empty string values
      if (value === undefined || value === null || value === '') {
        return;
      }
      
      // If the endpoint contains a placeholder for this dependency, replace it
      const placeholder = `{${key}}`;
      if (url.includes(placeholder)) {
        url = url.replace(placeholder, encodeURIComponent(String(value)));
      } else {
        // Otherwise, add it as a query parameter
        queryParameters[key] = value;
      }
    });
    
    // Add remaining query parameters
    const queryString = Object.entries(queryParameters)
      .filter(([_, value]) => value !== undefined && value !== null && value !== '')
      .map(([key, value]) => `${encodeURIComponent(key)}=${encodeURIComponent(String(value))}`)
      .join('&');
    
    if (queryString) {
      url += url.includes('?') ? `&${queryString}` : `?${queryString}`;
    }
    
    return url;
  }, [endpoint, dependencies, queryParams]);
  
  // Check if all dependencies that are URL parameters have values
  const hasRequiredDependencies = useMemo(() => {
    // Extract URL parameters from the endpoint
    const urlParams = [];
    let match;
    const regex = /{([^}]+)}/g;
    
    while ((match = regex.exec(endpoint)) !== null) {
      urlParams.push(match[1]);
    }
    
    // Check if all URL parameters have values in dependencies
    return urlParams.every(param => {
      const value = dependencies[param];
      return value !== undefined && value !== null && value !== '';
    });
  }, [endpoint, dependencies]);
  
  // Generate a query key that includes all dependencies for proper caching
  const queryKey = useMemo(() => {
    return [
      'dependentOptions',
      endpoint,
      ...Object.entries(dependencies).map(([key, value]) => `${key}:${value || 'null'}`),
    ];
  }, [endpoint, dependencies]);
  
  // Fetch options using the API query hook
  const { 
    data,
    isLoading,
    error
  } = useApiQuery(
    queryKey,
    processedEndpoint,
    {
      staleTime,
      cacheTime,
      enabled: hasRequiredDependencies,
    }
  );
  
  // Process the response data to get the options
  const options = useMemo(() => {
    if (!data) return [];
    
    let items: any[] = [];
    
    // Handle different response formats
    if (Array.isArray(data)) {
      items = data;
    } else if (data && typeof data === 'object') {
      // Handle API response with content inside data property
      if (data.data && Array.isArray(data.data)) {
        items = data.data;
      } else if (data.content && Array.isArray(data.content)) {
        items = data.content;
      } else if (data.items && Array.isArray(data.items)) {
        items = data.items;
      } else if (data.results && Array.isArray(data.results)) {
        items = data.results;
      } else if (data.page && data.page.content && Array.isArray(data.page.content)) {
        items = data.page.content;
      }
    }
    
    // Map items to option format and filter out any empty values
    return items
      .map(item => ({
        label: item[labelKey] || item.label || item.name || String(item[valueKey] || item.id),
        value: String(item[valueKey] || item.value || item.id) // Ensure value is a string
      }))
      .filter(option => option.value !== '');
  }, [data, labelKey, valueKey]);
  
  return {
    options,
    isLoading,
    error,
    endpoint: processedEndpoint,
    hasRequiredDependencies
  };
}
</file>

<file path="hooks/useEntityApi.ts">
import { useState } from 'react';
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import { useToast } from '@/components/ui/use-toast';
import { BaseEntity, EntityApiConfig, FormMode } from '../types';

/**
 * Hook that provides CRUD operations for an entity type
 * 
 * @param apiConfig API configuration for the entity
 * @param options Additional options
 */
export function useEntityApi<TData extends BaseEntity, TFilter = any>({
  apiConfig,
  options = {}
}: {
  apiConfig: EntityApiConfig<TData, TFilter>;
  options?: {
    onCreated?: (data: TData) => void;
    onUpdated?: (data: TData) => void;
    onDeleted?: (id: string | number) => void;
    transformData?: (data: any, mode: FormMode) => any;
    validateData?: (data: any, mode: FormMode) => void;
    defaultFilter?: TFilter;
    defaultPageSize?: number;
    defaultSort?: { field: string; order: 'asc' | 'desc' };
  };
}) {
  // State
  const [filters, setFilters] = useState<TFilter>(options.defaultFilter || {} as TFilter);
  const [currentPage, setCurrentPage] = useState(0);
  const [pageSize, setPageSize] = useState(options.defaultPageSize || 10);
  const [sort, setSort] = useState(options.defaultSort);
  
  // Hooks
  const { toast } = useToast();
  const queryClient = useQueryClient();
  
  // Get all entities
  const {
    data,
    isLoading,
    isFetching,
    refetch
  } = useQuery({
    queryKey: [apiConfig.queryKeys.all, currentPage, pageSize, sort, filters],
    queryFn: () => apiConfig.getAll({
      page: currentPage,
      pageSize,
      sort,
      filters
    }),
    keepPreviousData: true
  });
  
  // Get entity by ID
  const getById = (id: string | number) => {
    if (!apiConfig.getById) {
      throw new Error('getById not implemented in apiConfig');
    }
    
    return useQuery({
      queryKey: [apiConfig.queryKeys.detail, id],
      queryFn: () => apiConfig.getById!(id),
      enabled: !!id
    });
  };
  
  // Create entity
  const createMutation = useMutation({
    mutationFn: (data: Omit<TData, 'id'>) => {
      const transformedData = options.transformData 
        ? options.transformData(data, 'create') 
        : data;
      
      if (options.validateData) {
        options.validateData(transformedData, 'create');
      }
      
      return apiConfig.create(transformedData);
    },
    onSuccess: (createdItem) => {
      queryClient.invalidateQueries({ queryKey: [apiConfig.queryKeys.all] });
      toast({
        title: 'Success',
        description: `Item created successfully.`,
      });
      
      if (options.onCreated) {
        options.onCreated(createdItem);
      }
    },
    onError: (error) => {
      toast({
        title: 'Error',
        description: `Failed to create item.`,
        variant: 'destructive'
      });
      console.error('Create error:', error);
    }
  });
  
  // Update entity
  const updateMutation = useMutation({
    mutationFn: ({ id, data }: { id: string | number, data: Partial<TData> }) => {
      const transformedData = options.transformData 
        ? options.transformData(data, 'edit') 
        : data;
      
      if (options.validateData) {
        options.validateData(transformedData, 'edit');
      }
      
      return apiConfig.update(id, transformedData);
    },
    onSuccess: (updatedItem) => {
      queryClient.invalidateQueries({ queryKey: [apiConfig.queryKeys.all] });
      queryClient.invalidateQueries({ queryKey: [apiConfig.queryKeys.detail, updatedItem.id] });
      toast({
        title: 'Success',
        description: `Item updated successfully.`,
      });
      
      if (options.onUpdated) {
        options.onUpdated(updatedItem);
      }
    },
    onError: (error) => {
      toast({
        title: 'Error',
        description: `Failed to update item.`,
        variant: 'destructive'
      });
      console.error('Update error:', error);
    }
  });
  
  // Delete entity
  const deleteMutation = useMutation({
    mutationFn: (id: string | number) => apiConfig.delete(id),
    onSuccess: (_, variables) => {
      queryClient.invalidateQueries({ queryKey: [apiConfig.queryKeys.all] });
      toast({
        title: 'Success',
        description: `Item deleted successfully.`,
      });
      
      if (options.onDeleted) {
        options.onDeleted(variables);
      }
    },
    onError: (error) => {
      toast({
        title: 'Error',
        description: `Failed to delete item.`,
        variant: 'destructive'
      });
      console.error('Delete error:', error);
    }
  });
  
  // Pagination actions
  const handlePageChange = (page: number) => {
    setCurrentPage(page);
  };
  
  const handlePageSizeChange = (size: number) => {
    setPageSize(size);
    setCurrentPage(0); // Reset to first page
  };
  
  // Sort actions
  const handleSortChange = (field: string, order: 'asc' | 'desc' | undefined) => {
    setSort(order ? { field, order } : undefined);
  };
  
  // Filter actions
  const handleFilterChange = (newFilters: TFilter) => {
    setFilters(newFilters);
    setCurrentPage(0); // Reset to first page
  };
  
  const resetFilters = () => {
    setFilters({} as TFilter);
    setCurrentPage(0);
  };
  
  return {
    // Data
    items: data?.items || [],
    totalItems: data?.totalItems || 0,
    totalPages: data?.totalPages || 0,
    
    // Loading state
    isLoading,
    isFetching,
    isCreating: createMutation.isPending,
    isUpdating: updateMutation.isPending,
    isDeleting: deleteMutation.isPending,
    
    // Pagination state
    currentPage,
    pageSize,
    
    // Sort state
    sort,
    
    // Filter state
    filters,
    
    // Actions
    create: createMutation.mutate,
    update: updateMutation.mutate,
    delete: deleteMutation.mutate,
    getById,
    refresh: refetch,
    
    // Pagination actions
    onPageChange: handlePageChange,
    onPageSizeChange: handlePageSizeChange,
    
    // Sort actions
    onSortChange: handleSortChange,
    
    // Filter actions
    onFilterChange: handleFilterChange,
    resetFilters,
  };
}
</file>

<file path="hooks/useEntityForm.ts">
import { useCallback, useMemo, useEffect } from 'react';
import { useForm } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';
import { FormMode, BaseEntity } from '../types';
import { EntityStore, createEntityStore } from '../store';
import { logger } from '../utils/logger';

/**
 * Hook for managing entity form state and operations using a Zustand store
 * @param options Form configuration options
 * @returns Form state and methods
 */
export function useEntityForm<TData extends BaseEntity = any, TFilter = any>({
  defaultValues,
  validationSchema,
  onSubmit,
  onCancel,
  initialMode = 'view',
  initialData = null,
  store,
  storeId = 'entity-form',
  keepValuesOnModeChange = false,
}: {
  defaultValues?: Partial<TData>;
  validationSchema?: any;
  onSubmit: (data: TData, mode: FormMode) => void | Promise<void>;
  onCancel?: () => void;
  initialMode?: FormMode;
  initialData?: TData | null;
  store?: EntityStore<TData, TFilter>;
  storeId?: string;
  keepValuesOnModeChange?: boolean;
}) {
  // Create a dedicated logger for this form instance
  const formLogger = useMemo(() => logger.createContext(`EntityForm:${storeId}`), [storeId]);
  
  // Create a local store if none is provided
  const formStore = useMemo(() => {
    if (store) {
      formLogger.debug('Using provided store');
      return store;
    }
    
    formLogger.debug('Creating new entity store');
    return createEntityStore<TData, TFilter>(storeId, {
      enableLogging: true
    });
  }, [store, storeId, formLogger]);
  
  // Initialize store with initial values if provided
  useEffect(() => {
    if (initialMode && formStore.formMode !== initialMode) {
      formLogger.debug(`Setting initial form mode: ${initialMode}`);
      formStore.setFormMode(initialMode);
    }
    
    if (initialData && !formStore.selectedItem) {
      formLogger.debug('Setting initial form data');
      formStore.setSelectedItem(initialData);
    }
  }, [formStore, initialMode, initialData, formLogger]);
  
  // Access store state through selectors
  const formMode = formStore.useFormMode();
  const data = formStore.useSelectedItem();
  const formData = formStore.useFormData();
  const isSubmitting = formStore.useIsSubmitting();
  const submitError = formStore.useSubmitError();
  
  // Create form with react-hook-form
  const form = useForm({
    defaultValues: (data || formData || defaultValues) as any,
    resolver: validationSchema ? zodResolver(validationSchema) : undefined,
  });
  
  // Reset form when data changes
  const resetForm = useCallback(() => {
    form.reset(data || formData || defaultValues || {});
  }, [form, data, formData, defaultValues]);
  
  // Handle form mode changes with option to keep values
  const handleModeChange = useCallback((mode: FormMode, newData?: TData | null) => {
    formLogger.debug(`Changing form mode to ${mode}`, undefined, { newData: !!newData });
    formStore.setFormMode(mode);
    
    if (newData !== undefined) {
      formStore.setSelectedItem(newData);
    }
    
    if (!keepValuesOnModeChange) {
      resetForm();
    }
  }, [formStore, resetForm, keepValuesOnModeChange, formLogger]);
  
  // Handle form submission with better error handling
  const handleSubmit = useCallback(async (data: any) => {
    formLogger.info('Submitting form data', undefined, { mode: formMode });
    formStore.setSubmitError(null);
    formStore.setSubmitting(true);
    
    try {
      // Update form data in store
      formStore.updateFormData(data);
      // Submit the data
      await onSubmit(data, formMode);
      formLogger.info('Form submission successful');
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : 'An error occurred';
      formLogger.error('Form submission error:', errorMessage, { error });
      formStore.setSubmitError(errorMessage);
    } finally {
      formStore.setSubmitting(false);
    }
  }, [formStore, formMode, onSubmit, formLogger]);
  
  // Handle form cancel with logging
  const handleCancel = useCallback(() => {
    formLogger.debug('Cancelling form');
    if (onCancel) {
      onCancel();
    }
    resetForm();
    if (formMode !== 'view') {
      formStore.setFormMode('view');
    }
  }, [formMode, formStore, onCancel, resetForm, formLogger]);
  
  // Utility for phone input fields to copy to another field
  const copyField = useCallback((fromField: string, toField: string) => {
    const value = form.getValues(fromField);
    form.setValue(toField, value);
  }, [form]);
  
  // Return a memoized value to prevent unnecessary re-renders
  const formState = useMemo(() => ({
    // Form state
    form,
    store: formStore,
    formMode,
    data,
    formData,
    isSubmitting,
    submitError,
    isReadOnly: formMode === 'view',
    isCreating: formMode === 'create',
    isEditing: formMode === 'edit',
    
    // Actions
    setFormMode: handleModeChange,
    handleSubmit: form.handleSubmit(handleSubmit),
    handleCancel,
    resetForm,
    copyField,
    
    // Directly expose some store methods for convenience
    updateFormData: formStore.updateFormData,
    setSubmitError: formStore.setSubmitError,
    
    // Logger
    logger: formLogger,
  }), [
    form, 
    formStore, 
    formMode, 
    data, 
    formData, 
    isSubmitting, 
    submitError, 
    handleModeChange, 
    handleSubmit, 
    handleCancel, 
    resetForm, 
    copyField, 
    formLogger
  ]);
  
  return formState;
}
</file>

<file path="hooks/useEntityManager.ts">
import { useState, useCallback } from 'react';
import { useQueryClient } from '@tanstack/react-query';
import { useToast } from '@/components/ui/use-toast';
import { 
  useApiQuery, 
  useApiMutation, 
  useApiDynamicMutation,
  useStandardPaginatedQuery,
  PaginationParams
} from '@/features/core/tanstack-query-api';
import { BaseEntity, EntityApiEndpoints, FormMode } from '../types';

/**
 * Hook that provides entity management operations using the existing tanstack-query-api
 * 
 * @param endpoints API endpoints configuration
 * @param options Additional options
 */
export function useEntityManager<TData extends BaseEntity, TFilter = Record<string, any>>({
  endpoints,
  options = {}
}: {
  endpoints: EntityApiEndpoints;
  options?: {
    onCreated?: (data: TData) => void;
    onUpdated?: (data: TData) => void;
    onDeleted?: (id: string | number) => void;
    transformData?: (data: any, mode: FormMode) => any;
    validateData?: (data: any, mode: FormMode) => void;
    defaultPageSize?: number;
    defaultFilters?: TFilter;
  };
}) {
  // State
  const [filters, setFilters] = useState<TFilter>(options.defaultFilters || {} as TFilter);
  const [currentPage, setCurrentPage] = useState(0);
  const [pageSize, setPageSize] = useState(options.defaultPageSize || 10);
  const [sortBy, setSortBy] = useState<string | undefined>(undefined);
  const [sortOrder, setSortOrder] = useState<'asc' | 'desc' | undefined>(undefined);
  const [isModalOpen, setIsModalOpen] = useState(false);
  const [selectedItem, setSelectedItem] = useState<TData | null>(null);
  const [formMode, setFormMode] = useState<FormMode>('view');
  
  // Hooks
  const { toast } = useToast();
  const queryClient = useQueryClient();
  
  // Prepare query parameters
  const queryParams: PaginationParams = {
    page: currentPage,
    size: pageSize,
    ...(sortBy && sortOrder && { sort: `${sortBy},${sortOrder}` }),
    ...filters
  };
  
  // Prepare API endpoints
  const getAllEndpoint = endpoints.getAll || endpoints.base;
  const getByIdEndpoint = (id: string | number) => 
    endpoints.getById ? `${endpoints.getById}/${id}` : `${endpoints.base}/${id}`;
  const createEndpoint = endpoints.create || endpoints.base;
  const updateEndpoint = (id: string | number) => 
    endpoints.update ? `${endpoints.update}/${id}` : `${endpoints.base}/${id}`;
  const deleteEndpoint = (id: string | number) => 
    endpoints.delete ? `${endpoints.delete}/${id}` : `${endpoints.base}/${id}`;
  
  // Get all entities
  const { 
    data,
    isLoading,
    isFetching,
    refetch
  } = useStandardPaginatedQuery<TData>(
    [endpoints.queryKeys.all],
    getAllEndpoint,
    queryParams
  );
  
  // Create mutation
  const createMutation = useApiMutation<TData, Omit<TData, 'id'>>(
    createEndpoint,
    'POST',
    {
      onSuccess: (createdItem) => {
        queryClient.invalidateQueries({ queryKey: [endpoints.queryKeys.all] });
        toast({
          title: 'Success',
          description: `Item created successfully.`,
        });
        closeModal();
        
        if (options.onCreated) {
          options.onCreated(createdItem);
        }
      },
      onError: (error) => {
        toast({
          title: 'Error',
          description: `Failed to create item: ${error.message}`,
          variant: 'destructive'
        });
      }
    }
  );
  
  // Update mutation
  const updateMutation = useApiDynamicMutation<TData, TData>(
    updateEndpoint,
    'PUT',
    {
      onSuccess: (updatedItem) => {
        queryClient.invalidateQueries({ queryKey: [endpoints.queryKeys.all] });
        queryClient.invalidateQueries({ queryKey: [endpoints.queryKeys.detail, updatedItem.id] });
        toast({
          title: 'Success',
          description: `Item updated successfully.`,
        });
        closeModal();
        
        if (options.onUpdated) {
          options.onUpdated(updatedItem);
        }
      },
      onError: (error) => {
        toast({
          title: 'Error',
          description: `Failed to update item: ${error.message}`,
          variant: 'destructive'
        });
      }
    }
  );
  
  // Delete mutation
  const deleteMutation = useApiDynamicMutation<void, { id: string | number }>(
    deleteEndpoint,
    'DELETE',
    {
      onSuccess: (_, variables) => {
        queryClient.invalidateQueries({ queryKey: [endpoints.queryKeys.all] });
        toast({
          title: 'Success',
          description: `Item deleted successfully.`,
        });
        closeModal();
        
        if (options.onDeleted) {
          options.onDeleted(variables.id);
        }
      },
      onError: (error) => {
        toast({
          title: 'Error',
          description: `Failed to delete item: ${error.message}`,
          variant: 'destructive'
        });
      }
    }
  );
  
  // Action handlers
  const handlePageChange = useCallback((page: number) => {
    setCurrentPage(page);
  }, []);
  
  const handlePageSizeChange = useCallback((size: number) => {
    setPageSize(size);
    setCurrentPage(0); // Reset to first page
  }, []);
  
  const handleSortChange = useCallback((field: string, order: 'asc' | 'desc' | undefined) => {
    setSortBy(field);
    setSortOrder(order);
  }, []);
  
  const handleFilterChange = useCallback((newFilters: TFilter) => {
    setFilters(newFilters);
    setCurrentPage(0); // Reset to first page
  }, []);
  
  const resetFilters = useCallback(() => {
    setFilters({} as TFilter);
    setCurrentPage(0);
  }, []);
  
  const openModal = useCallback((mode: FormMode, item?: TData | null) => {
    // Set form mode and open modal
    setFormMode(mode);
    setSelectedItem(item || null);
    setIsModalOpen(true);
  }, []);
  
  const closeModal = useCallback(() => {
    // First close the modal
    setIsModalOpen(false);
    
    // Small delay to reset state after modal animation completes
    setTimeout(() => {
      setSelectedItem(null);
      setFormMode('view');
    }, 300);
  }, []);
  
  // Get entity by ID
  const getById = useCallback((id: string | number) => {
    return useApiQuery<TData>(
      [endpoints.queryKeys.detail, id],
      getByIdEndpoint(id),
      { enabled: !!id }
    );
  }, [endpoints]);
  
  // Form submission handler
  const handleSubmit = useCallback((formData: any) => {
    // Transform data if needed
    const transformedData = options.transformData 
      ? options.transformData(formData, formMode) 
      : formData;
    
    // Validate data if needed
    if (options.validateData) {
      try {
        options.validateData(transformedData, formMode);
      } catch (error) {
        toast({
          title: 'Validation Error',
          description: error instanceof Error ? error.message : 'Invalid data',
          variant: 'destructive'
        });
        return;
      }
    }
    
    if (formMode === 'create') {
      createMutation.mutate(transformedData);
    } else if (formMode === 'edit' && selectedItem?.id) {
      updateMutation.mutate({ ...transformedData, id: selectedItem.id });
    }
  }, [formMode, selectedItem, options, createMutation, updateMutation, toast]);
  
  const handleDelete = useCallback((item: TData) => {
    if (item && item.id) {
      deleteMutation.mutate({ id: item.id });
    }
  }, [deleteMutation]);
  
  return {
    // Data
    items: data?.data || [],
    pagination: data?.pagination || {
      totalItems: 0,
      totalPages: 0,
      currentPage: 0,
      pageSize,
    },
    selectedItem,
    filters,
    
    // UI state
    isLoading: isLoading || isFetching,
    isCreating: createMutation.isPending,
    isUpdating: updateMutation.isPending,
    isDeleting: deleteMutation.isPending,
    isModalOpen,
    formMode,
    
    // Sort state
    sortBy,
    sortOrder,
    
    // Actions
    create: createMutation.mutate,
    update: updateMutation.mutate,
    delete: handleDelete,
    getById,
    refresh: refetch,
    handleSubmit,
    
    // Modal actions
    openModal,
    closeModal,
    
    // Pagination actions
    onPageChange: handlePageChange,
    onPageSizeChange: handlePageSizeChange,
    
    // Sort actions
    onSortChange: handleSortChange,
    
    // Filter actions
    onFilterChange: handleFilterChange,
    resetFilters,
  };
}
</file>

<file path="hooks/useEntityModal.ts">
import { useCallback, useRef } from 'react';
import { FormMode, BaseEntity } from '@/features/core/tanstack-query-api';
import { EntityStore } from '../store';
import { logger } from '../utils/logger';

/**
 * Props for the useEntityModal hook
 */
interface UseEntityModalProps<TData extends BaseEntity = any, TFilter = any> {
  entityStore: EntityStore<TData, TFilter>;
  onSelectItem: (item: TData | null) => void;
  onSetFormMode: (mode: FormMode) => void;
}

/**
 * Hook to manage modal state and operations for entity management
 */
export function useEntityModal<TData extends BaseEntity = any, TFilter = any>({
  entityStore,
  onSelectItem,
  onSetFormMode,
}: UseEntityModalProps<TData, TFilter>) {
  // Create a logger context
  const hookLogger = logger.createContext('useEntityModal');
  
  // Ref to track updating state to prevent infinite loops
  const isUpdatingRef = useRef(false);
  
  /**
   * Opens the modal in the specified mode with the given item
   */
  const openModal = useCallback((mode: FormMode, item?: TData | null) => {
    hookLogger.debug(`Opening modal in ${mode} mode`, undefined, { item });
    
    if (isUpdatingRef.current) return; // Prevent re-entrant calls
    
    isUpdatingRef.current = true;
    try {
      // For create mode, ensure item is null to prevent showing data from previous items
      const itemToUse = mode === 'create' ? null : (item || null);
      
      // Use requestAnimationFrame + setTimeout to ensure proper batching
      requestAnimationFrame(() => {
        setTimeout(() => {
          try {
            // First update API state
            onSelectItem(itemToUse);
            onSetFormMode(mode);
            
            // Then update store state in a separate tick
            requestAnimationFrame(() => {
              setTimeout(() => {
                try {
                  // Get a fresh snapshot of the store state
                  const storeState = entityStore.getState();
                  
                  // Call the action function if it exists
                  if (typeof storeState.openModal === 'function') {
                    storeState.openModal(mode, itemToUse);
                  }
                } finally {
                  // Only clear the flag after all operations complete
                  isUpdatingRef.current = false;
                }
              }, 0);
            });
          } catch (error) {
            hookLogger.error('Error in openModal:', error instanceof Error ? error.message : String(error));
            isUpdatingRef.current = false;
          }
        }, 0);
      });
    } catch (error) {
      hookLogger.error('Error in openModal:', error instanceof Error ? error.message : String(error));
      isUpdatingRef.current = false;
    }
  }, [entityStore, onSelectItem, onSetFormMode, hookLogger]);
  
  /**
   * Closes the modal and resets state
   */
  const closeModal = useCallback(() => {
    hookLogger.debug('Closing modal');
    
    if (isUpdatingRef.current) return; // Prevent re-entrant calls
    
    isUpdatingRef.current = true;
    try {
      // Use requestAnimationFrame + setTimeout for batching
      requestAnimationFrame(() => {
        setTimeout(() => {
          try {
            // First update API state
            onSelectItem(null);
            onSetFormMode('view');
            
            // Then update store state in a separate tick
            requestAnimationFrame(() => {
              setTimeout(() => {
                try {
                  // Get a fresh snapshot of the store state
                  const storeState = entityStore.getState();
                  
                  // Perform store updates
                  if (typeof storeState.closeModal === 'function') {
                    storeState.closeModal();
                  }
                  
                  // Ensure selected item is completely cleared
                  if (typeof storeState.setSelectedItem === 'function') {
                    storeState.setSelectedItem(null);
                  }
                  
                  hookLogger.debug('Modal closed and state reset successfully');
                } finally {
                  // Only clear the flag after all operations complete
                  isUpdatingRef.current = false;
                }
              }, 0);
            });
          } catch (error) {
            hookLogger.error('Error in closeModal:', error instanceof Error ? error.message : String(error));
            isUpdatingRef.current = false;
          }
        }, 0);
      });
    } catch (error) {
      hookLogger.error('Error in closeModal:', error instanceof Error ? error.message : String(error));
      isUpdatingRef.current = false;
    }
  }, [entityStore, onSelectItem, onSetFormMode, hookLogger]);
  
  /**
   * Creates a wrapper for callbacks that need to close the modal
   */
  const wrapWithModalClose = useCallback((callback?: (data: any) => void) => {
    return async (data: any) => {
      // Call the callback if provided 
      if (callback) {
        await Promise.resolve(callback(data));
      }
      
      // Use setTimeout to break potential render cycles
      setTimeout(() => {
        // Close the modal
        closeModal();
      }, 0);
    };
  }, [closeModal]);
  
  return {
    openModal,
    closeModal,
    wrapWithModalClose,
  };
}
</file>

<file path="hooks/useEntityPermissions.ts">
import { useMemo } from 'react';
import { useAuth } from '@/features/core/auth';
import { EntityPermissions } from '../types';

/**
 * Props for the useEntityPermissions hook
 */
interface UseEntityPermissionsProps {
  permissions?: EntityPermissions;
}

/**
 * Hook to check entity-related permissions
 */
export function useEntityPermissions({ permissions }: UseEntityPermissionsProps) {
  const { hasPermission } = useAuth();
  
  // Calculate permission flags only once
  const permissionFlags = useMemo(() => {
    // If no permissions config is provided, assume user has all permissions
    if (!permissions) {
      return {
        canView: true,
        canCreate: true,
        canUpdate: true,
        canDelete: true,
      };
    }
    
    // Check each permission against the auth system
    return {
      canView: hasPermission(permissions.feature, permissions.view || 'VIEW'),
      canCreate: permissions.create ? hasPermission(permissions.feature, permissions.create) : false,
      canUpdate: permissions.update ? hasPermission(permissions.feature, permissions.update) : false,
      canDelete: permissions.delete ? hasPermission(permissions.feature, permissions.delete) : false,
    };
  }, [permissions, hasPermission]);
  
  return permissionFlags;
}
</file>

<file path="hooks/useEntitySync.ts">
import { useEffect, useRef } from 'react';
import { BaseEntity } from '@/features/core/tanstack-query-api';
import { EntityStore } from '../store';
import { logger } from '../utils/logger';

/**
 * Props for the useEntitySync hook
 */
interface UseEntitySyncProps<TData extends BaseEntity = any, TFilter = any> {
  entityStore: EntityStore<TData, TFilter>;
  items: TData[] | undefined;
  pagination: {
    totalItems: number;
    totalPages: number;
    currentPage: number;
  };
  isLoading: boolean;
  error: Error | null;
  isAuthLoading: boolean;
  isTokenValidated: boolean;
}

/**
 * Hook to synchronize API data with the entity store
 */
export function useEntitySync<TData extends BaseEntity = any, TFilter = any>({
  entityStore,
  items,
  pagination,
  isLoading,
  error,
  isAuthLoading,
  isTokenValidated,
}: UseEntitySyncProps<TData, TFilter>) {
  // Create a logger context
  const hookLogger = logger.createContext('useEntitySync');
  
  // Ref to track updating state to prevent infinite loops
  const isUpdatingRef = useRef(false);
  
  // Sync store with API data
  useEffect(() => {
    // Skip updates while auth is loading or until token is validated
    if (isAuthLoading || !isTokenValidated) {
      return;
    }
    
    // Only update if data is available and we're not already in an update
    if (items && !isUpdatingRef.current) {
      hookLogger.debug('Syncing API data with store');
      
      // Set the updating flag to prevent re-entry
      isUpdatingRef.current = true;
      
      try {
        // Get a snapshot of the store state once
        const storeState = entityStore.getState();
        
        // Batch all store updates together to minimize re-renders
        const updates: Record<string, any> = {};
        
        // Only update the store if the data has actually changed
        if (JSON.stringify(storeState.items) !== JSON.stringify(items)) {
          updates['items'] = items;
        }
        
        // Only update pagination values if they've changed
        if (storeState.totalItems !== pagination.totalItems) {
          updates['totalItems'] = pagination.totalItems;
        }
        
        if (storeState.totalPages !== pagination.totalPages) {
          updates['totalPages'] = pagination.totalPages;
        }
        
        if (storeState.currentPage !== pagination.currentPage) {
          updates['currentPage'] = pagination.currentPage;
        }
        
        if (storeState.isLoading !== isLoading) {
          updates['isLoading'] = isLoading;
        }
        
        // Apply all updates in a single batch if there are any changes
        if (Object.keys(updates).length > 0) {
          // Use setTimeout to break the potential synchronous loop
          setTimeout(() => {
            try {
              // Apply each update using the appropriate method
              if (updates['items'] && typeof storeState.setItems === 'function') {
                storeState.setItems(updates['items']);
              }
              
              if (updates['totalItems'] && typeof storeState.setTotalItems === 'function') {
                storeState.setTotalItems(updates['totalItems']);
              }
              
              if (updates['totalPages'] && typeof storeState.setTotalPages === 'function') {
                storeState.setTotalPages(updates['totalPages']);
              }
              
              if (updates['currentPage'] && typeof storeState.setCurrentPage === 'function') {
                storeState.setCurrentPage(updates['currentPage']);
              }
              
              if (updates['isLoading'] && typeof storeState.setLoading === 'function') {
                storeState.setLoading(updates['isLoading']);
              }
              
              // Handle errors
              if (error && typeof storeState.setError === 'function') {
                storeState.setError(error);
              }
            } finally {
              // Always reset the updating flag after applying updates
              isUpdatingRef.current = false;
            }
          }, 0);
        } else {
          // No updates needed, reset the flag
          isUpdatingRef.current = false;
        }
      } catch (error) {
        hookLogger.error('Error syncing store with API data:', error instanceof Error ? error.message : String(error));
        isUpdatingRef.current = false;
      }
    }
  }, [entityStore, items, pagination, isLoading, error, hookLogger, isAuthLoading, isTokenValidated]);
}
</file>

<file path="hooks/useFieldRelationships.ts">
import { useCallback, useEffect, useRef, useState } from 'react';
import { useFormContext } from 'react-hook-form';
import { useQuery, useQueryClient } from '@tanstack/react-query';
import { apiClient } from '@/features/core/tanstack-query-api/core/apiClient';
import { 
  DependentFieldRelationship, 
  RelationshipType 
} from '../types/entity-form/field-relationships';

interface UseFieldRelationshipsOptions {
  /**
   * Debounce time in milliseconds for dependency updates
   * @default 100
   */
  debounceMs?: number;
  
  /**
   * Whether to skip initial dependency check on first run
   * @default false
   */
  skipFirstRun?: boolean;
  
  /**
   * Cache time for field options in milliseconds
   * @default 5 minutes
   */
  cacheTime?: number;
  
  /**
   * Enable debug mode to log detailed information
   * @default false
   */
  debug?: boolean;
}

/**
 * Hook to manage field relationships and dependencies in forms
 * This hook provides a mechanism to track dependencies between fields,
 * manage field options based on dependencies, and prevent infinite loops.
 */
export function useFieldRelationships(
  relationships: Record<string, DependentFieldRelationship[]>,
  options: UseFieldRelationshipsOptions = {}
) {
  const {
    debounceMs = 100,
    skipFirstRun = false,
    cacheTime = 5 * 60 * 1000, // 5 minutes
    debug = false
  } = options;
  
  const form = useFormContext();
  const queryClient = useQueryClient();
  
  // Refs to track previous values and first runs
  const prevDependencyValuesRef = useRef<Record<string, Record<string, any>>>({});
  const firstRunsRef = useRef<Record<string, boolean>>({});
  const timeoutRefs = useRef<Record<string, NodeJS.Timeout | null>>({});
  
  // Get all fields that have dependencies
  const dependentFields = Object.keys(relationships);
  
  // Map of fields to their dependencies
  const [dependencyMap, setDependencyMap] = useState<Record<string, string[]>>({});
  
  // Set up dependency map
  useEffect(() => {
    const map: Record<string, string[]> = {};
    
    // Process all field relationships
    Object.entries(relationships).forEach(([fieldName, fieldRelationships]) => {
      fieldRelationships.forEach(relationship => {
        if (relationship.type === RelationshipType.DEPENDS_ON) {
          const dependsOn = Array.isArray(relationship.fields) 
            ? relationship.fields 
            : [relationship.fields];
            
          map[fieldName] = (map[fieldName] || []).concat(dependsOn);
          
          // Initialize first run tracking
          if (firstRunsRef.current[fieldName] === undefined) {
            firstRunsRef.current[fieldName] = skipFirstRun;
          }
        }
      });
    });
    
    setDependencyMap(map);
  }, [relationships, skipFirstRun]);
  
  // Check if dependencies changed
  const haveDependenciesChanged = useCallback((
    fieldName: string, 
    newValues: Record<string, any>
  ): boolean => {
    const prevValues = prevDependencyValuesRef.current[fieldName] || {};
    
    // First run case
    if (firstRunsRef.current[fieldName]) {
      firstRunsRef.current[fieldName] = false;
      // Store current values
      prevDependencyValuesRef.current[fieldName] = { ...newValues };
      return false;
    }
    
    // Check if any values changed
    let hasChanged = false;
    const deps = dependencyMap[fieldName] || [];
    
    deps.forEach((dep) => {
      if (prevValues[dep] !== newValues[dep]) {
        hasChanged = true;
      }
    });
    
    // Store current values for next comparison
    if (hasChanged) {
      prevDependencyValuesRef.current[fieldName] = { ...newValues };
    }
    
    return hasChanged;
  }, [dependencyMap]);
  
  // Check if all dependencies are filled
  const allDependenciesFilled = useCallback((
    fieldName: string,
    values: Record<string, any>
  ): boolean => {
    const deps = dependencyMap[fieldName] || [];
    return deps.every(dep => {
      const val = values[dep];
      return val !== undefined && val !== null && val !== '';
    });
  }, [dependencyMap]);
  
  // Get field options fetcher function
  const getFieldOptionsFetcher = useCallback((
    fieldName: string,
    dependencies: Record<string, any>
  ) => {
    // Get the relationship config for the field
    const fieldRelationships = relationships[fieldName] || [];
    const dependsOnRelationship = fieldRelationships.find(
      r => r.type === RelationshipType.DEPENDS_ON
    );
    
    if (!dependsOnRelationship) {
      if (debug) console.log(`[useFieldRelationships] No DEPENDS_ON relationship for ${fieldName}`);
      return null;
    }
    
    // Build fetcher function
    return async () => {
      if (debug) {
        console.log(`[useFieldRelationships] Fetching options for ${fieldName}`, dependencies);
      }
      
      // Apply transformations if specified
      const transformedDeps = dependsOnRelationship.transformDependencies
        ? dependsOnRelationship.transformDependencies(dependencies)
        : dependencies;
        
      // Determine the endpoint
      let endpoint: string;
      
      if (dependsOnRelationship.optionsEndpoint) {
        // Replace placeholders in endpoint template
        endpoint = dependsOnRelationship.optionsEndpoint;
        Object.entries(transformedDeps).forEach(([key, value]) => {
          endpoint = endpoint.replace(`:${key}`, String(value));
        });
      } else if (dependsOnRelationship.endpointsConfig && dependsOnRelationship.endpointKey) {
        // Get from endpointsConfig using endpointKey
        const config = dependsOnRelationship.endpointsConfig;
        const keys = dependsOnRelationship.endpointKey.split('.');
        
        let endpointFn: any = config;
        for (const key of keys) {
          if (endpointFn && typeof endpointFn === 'object') {
            endpointFn = endpointFn[key];
          } else {
            throw new Error(`Invalid endpointKey: ${dependsOnRelationship.endpointKey}`);
          }
        }
        
        // If the endpoint is a function, call it with the first dependency value
        if (typeof endpointFn === 'function') {
          const firstDepValue = Object.values(transformedDeps)[0];
          endpoint = endpointFn(firstDepValue);
        } else if (typeof endpointFn === 'string') {
          endpoint = endpointFn;
        } else {
          throw new Error(`Invalid endpoint for ${fieldName}`);
        }
      } else {
        // Try a default endpoint pattern
        const dependencyField = Array.isArray(dependsOnRelationship.fields)
          ? dependsOnRelationship.fields[0]
          : dependsOnRelationship.fields;
          
        const dependencyValue = transformedDeps[dependencyField];
        
        // Construct a query parameter version
        const fieldEntityName = fieldName.replace(/Id$/, '');
        const baseUrl = `/api/masters/${fieldEntityName.replace(/([A-Z])/g, '-$1').toLowerCase()}`;
        const queryParam = `${dependencyField}=${dependencyValue}`;
        endpoint = `${baseUrl}?${queryParam}`;
      }
      
      // Make the API request
      try {
        const response = await apiClient.get(endpoint);
        
        if (!response.data) {
          return [];
        }
        
        // Format the response data
        const { valueProperty = 'id', displayProperty = 'name' } = 
          dependsOnRelationship.entityConfig || {};
          
        return Array.isArray(response.data)
          ? response.data.map(item => ({
              label: item[displayProperty] || String(item),
              value: String(item[valueProperty] || item)
            }))
          : [];
      } catch (error) {
        console.error(`[useFieldRelationships] Error fetching options for ${fieldName}:`, error);
        return [];
      }
    };
  }, [relationships, debug]);
  
  // Setup form subscription
  useEffect(() => {
    if (!form || !dependentFields.length) return;
    
    // Create the subscription
    const subscription = form.watch((formValues, { name, type }) => {
      // Skip non-change events
      if (type !== 'change') return;
      if (!name) return;
      
      // Get all fields that depend on the changed field
      Object.entries(dependencyMap).forEach(([fieldName, dependencies]) => {
        if (dependencies.includes(name)) {
          // This field depends on the changed field
          const fieldDependencies: Record<string, any> = {};
          
          // Build dependencies object
          dependencies.forEach(dep => {
            fieldDependencies[dep] = formValues[dep];
          });
          
          // Handle the dependency change
          const hasChanged = haveDependenciesChanged(fieldName, fieldDependencies);
          
          if (hasChanged) {
            if (debug) {
              console.log(`[useFieldRelationships] Dependencies changed for ${fieldName}:`, fieldDependencies);
            }
            
            // Get field relationships to determine actions
            const fieldRelationships = relationships[fieldName] || [];
            const dependsOnRelationship = fieldRelationships.find(
              r => r.type === RelationshipType.DEPENDS_ON
            );
            
            if (!dependsOnRelationship) return;
            
            // Check if all dependencies are filled
            const allFilled = allDependenciesFilled(fieldName, fieldDependencies);
            
            // Reset field value if configured and dependencies changed
            const shouldReset = dependsOnRelationship.resetOnChange !== false;
            if (shouldReset && formValues[fieldName]) {
              form.setValue(fieldName, null);
              form.trigger(fieldName).catch(console.error);
            }
            
            // Invalidate query cache to trigger refetch
            if (allFilled) {
              // If we have all dependencies, invalidate the cache with debounce
              if (timeoutRefs.current[fieldName]) {
                clearTimeout(timeoutRefs.current[fieldName]!);
              }
              
              timeoutRefs.current[fieldName] = setTimeout(() => {
                const queryKey = ['fieldOptions', fieldName, Object.values(fieldDependencies).join('_')];
                queryClient.invalidateQueries({ queryKey });
                timeoutRefs.current[fieldName] = null;
              }, debounceMs);
            }
          }
        }
      });
    });
    
    // Clean up
    return () => {
      subscription.unsubscribe();
      
      // Clear any pending timeouts
      Object.values(timeoutRefs.current).forEach(timeout => {
        if (timeout) clearTimeout(timeout);
      });
    };
  }, [
    form, 
    dependentFields, 
    dependencyMap, 
    relationships, 
    haveDependenciesChanged, 
    allDependenciesFilled, 
    queryClient, 
    debounceMs, 
    debug
  ]);
  
  // Get field options from API based on dependencies
  const getFieldOptions = useCallback((
    fieldName: string
  ) => {
    // Get current field dependencies
    const deps = dependencyMap[fieldName] || [];
    if (!deps.length) return { data: [], isLoading: false };
    
    // Get current values
    const dependencies: Record<string, any> = {};
    deps.forEach(dep => {
      dependencies[dep] = form.getValues(dep);
    });
    
    // Check if all dependencies are filled
    const allFilled = allDependenciesFilled(fieldName, dependencies);
    
    // Create query key including all dependency values
    const queryKey = [
      'fieldOptions', 
      fieldName, 
      Object.values(dependencies).join('_')
    ];
    
    // Create the fetcher function
    const fetcher = getFieldOptionsFetcher(fieldName, dependencies);
    
    // Return the query
    return useQuery({
      queryKey,
      queryFn: fetcher || (() => Promise.resolve([])),
      enabled: allFilled && !!fetcher,
      staleTime: cacheTime,
      gcTime: cacheTime,
      refetchOnWindowFocus: false,
    });
  }, [
    form, 
    dependencyMap, 
    allDependenciesFilled, 
    getFieldOptionsFetcher, 
    cacheTime
  ]);
  
  // Auto-select single option
  const autoSelectSingleOption = useCallback((
    fieldName: string,
    options: Array<{ label: string, value: string }>
  ) => {
    if (!options || options.length !== 1) return;
    
    // Get field relationships
    const fieldRelationships = relationships[fieldName] || [];
    const dependsOnRelationship = fieldRelationships.find(
      r => r.type === RelationshipType.DEPENDS_ON
    );
    
    if (!dependsOnRelationship) return;
    
    // Check if auto-select is enabled
    const shouldAutoSelect = dependsOnRelationship.display?.autoSelectSingleOption;
    if (!shouldAutoSelect) return;
    
    // Get current value
    const currentValue = form.getValues(fieldName);
    
    // Only auto-select if the field is empty or has a different value
    if (!currentValue || currentValue !== options[0].value) {
      if (debug) {
        console.log(`[useFieldRelationships] Auto-selecting only option for ${fieldName}:`, options[0]);
      }
      form.setValue(fieldName, options[0].value);
      form.trigger(fieldName).catch(console.error);
    }
  }, [form, relationships, debug]);
  
  // Check for single options and auto-select if needed
  useEffect(() => {
    dependentFields.forEach(fieldName => {
      const options = getFieldOptions(fieldName).data;
      if (options && options.length === 1) {
        autoSelectSingleOption(fieldName, options);
      }
    });
  }, [dependentFields, getFieldOptions, autoSelectSingleOption]);
  
  return {
    /**
     * Get field options for a dependent field
     */
    getFieldOptions,
    
    /**
     * Check if a field depends on another field
     */
    isDependentOn: useCallback((fieldName: string, dependencyName: string) => {
      const deps = dependencyMap[fieldName] || [];
      return deps.includes(dependencyName);
    }, [dependencyMap]),
    
    /**
     * Check if all dependencies for a field are filled
     */
    hasDependenciesFilled: useCallback((fieldName: string) => {
      const deps = dependencyMap[fieldName] || [];
      const dependencies: Record<string, any> = {};
      deps.forEach(dep => {
        dependencies[dep] = form.getValues(dep);
      });
      return allDependenciesFilled(fieldName, dependencies);
    }, [form, dependencyMap, allDependenciesFilled]),
    
    /**
     * Get dependency message for a field
     */
    getDependencyMessage: useCallback((fieldName: string) => {
      const fieldRelationships = relationships[fieldName] || [];
      const dependsOnRelationship = fieldRelationships.find(
        r => r.type === RelationshipType.DEPENDS_ON
      );
      
      if (!dependsOnRelationship) return '';
      
      // Get custom message if provided
      if (dependsOnRelationship.display?.placeholderMessage) {
        return dependsOnRelationship.display.placeholderMessage;
      }
      
      // Generate default message
      const deps = dependencyMap[fieldName] || [];
      const depLabels = deps.map(dep => {
        // Try to get a more readable field name
        return dep.replace(/([A-Z])/g, ' $1')
          .replace(/^./, str => str.toUpperCase())
          .replace(/Id$/, '');
      });
      
      return `Select ${depLabels.join('/')} first`;
    }, [relationships, dependencyMap]),
    
    /**
     * Set field value and handle dependency effects
     */
    setFieldValue: useCallback((fieldName: string, value: any) => {
      form.setValue(fieldName, value);
      form.trigger(fieldName).catch(console.error);
      
      // Check if this field is a dependency for other fields
      Object.entries(dependencyMap).forEach(([depFieldName, deps]) => {
        if (deps.includes(fieldName) && relationships[depFieldName]) {
          const fieldRelationships = relationships[depFieldName] || [];
          const dependsOnRelationship = fieldRelationships.find(
            r => r.type === RelationshipType.DEPENDS_ON
          );
          
          if (dependsOnRelationship?.resetOnChange !== false) {
            form.setValue(depFieldName, null);
          }
        }
      });
    }, [form, dependencyMap, relationships]),
  };
}
</file>

<file path="hooks/useFormDependencies.ts">
import { useEffect, useRef, useState } from 'react';
import { useFormContext } from 'react-hook-form';

/**
 * Custom hook to safely handle form field dependencies
 * and prevent infinite useEffect loops in forms
 * 
 * This hook helps manage relationships between form fields where
 * changing one field affects others (like dropdown cascading).
 * 
 * @param dependencies Array of field names that this field depends on
 * @param onChange Callback when dependencies change
 * @param options Configuration options
 */
export function useDependentFields<T = Record<string, any>>(
  dependencies: string[],
  onChange: (values: T) => void,
  options: {
    clearFieldOnChange?: boolean;
    fieldToClear?: string;
    debounceMs?: number;
    transformValues?: (values: Record<string, any>) => T;
    onlyWhenAllDependenciesFilled?: boolean;
    skipFirstRun?: boolean;
  } = {}
) {
  const { 
    clearFieldOnChange = true,
    fieldToClear,
    debounceMs = 0,
    transformValues = (v) => v as unknown as T,
    onlyWhenAllDependenciesFilled = true,
    skipFirstRun = true
  } = options;
  
  const form = useFormContext();
  
  // Use refs to track previous values and prevent unnecessary triggers
  const prevDependencyValuesRef = useRef<Record<string, any>>({});
  const skipFirstRunRef = useRef<boolean>(skipFirstRun);
  const timeoutRef = useRef<NodeJS.Timeout | null>(null);

  // Create a dependency checker
  const haveDependenciesChanged = (newValues: Record<string, any>) => {
    const prevValues = prevDependencyValuesRef.current;
    
    // First run case
    if (skipFirstRunRef.current) {
      skipFirstRunRef.current = false;
      // Store current values
      dependencies.forEach((dep) => {
        prevDependencyValuesRef.current[dep] = newValues[dep];
      });
      return false;
    }
    
    // Check if any values changed
    let hasChanged = false;
    dependencies.forEach((dep) => {
      if (prevValues[dep] !== newValues[dep]) {
        hasChanged = true;
      }
    });
    
    // Store current values for next comparison
    if (hasChanged) {
      dependencies.forEach((dep) => {
        prevDependencyValuesRef.current[dep] = newValues[dep];
      });
    }
    
    return hasChanged;
  };
  
  // Check if all dependencies have values
  const allDependenciesFilled = (values: Record<string, any>) => {
    return dependencies.every(dep => {
      const val = values[dep];
      return val !== undefined && val !== null && val !== '';
    });
  };
  
  // Handle dependency changes
  const handleDependencyChange = (formValues: Record<string, any>) => {
    // Create dependency values object
    const dependencyValues: Record<string, any> = {};
    dependencies.forEach((dep) => {
      dependencyValues[dep] = formValues[dep];
    });
    
    // Check if dependencies have changed
    const hasChanges = haveDependenciesChanged(dependencyValues);
    
    if (!hasChanges) return;
    
    // Check if all dependencies filled if required
    const allFilled = allDependenciesFilled(dependencyValues);
    if (onlyWhenAllDependenciesFilled && !allFilled) {
      // Clear the field if configured
      if (clearFieldOnChange && fieldToClear) {
        form.setValue(fieldToClear, '');
      }
      return;
    }
    
    // Clear the field if configured
    if (clearFieldOnChange && fieldToClear) {
      form.setValue(fieldToClear, '');
    }
    
    // Call onChange with debounce
    if (debounceMs > 0) {
      if (timeoutRef.current) {
        clearTimeout(timeoutRef.current);
      }
      
      timeoutRef.current = setTimeout(() => {
        onChange(transformValues(dependencyValues));
      }, debounceMs);
    } else {
      onChange(transformValues(dependencyValues));
    }
  };
  
  // Set up form subscription
  useEffect(() => {
    // Create the subscription
    const subscription = form.watch((formValues, { name }) => {
      // Only process if the changed field is one of our dependencies
      if (name && dependencies.includes(name)) {
        handleDependencyChange(formValues);
      }
    });
    
    // Cleanup
    return () => subscription.unsubscribe();
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [JSON.stringify(dependencies)]);
  
  return {
    isDependentOn: (fieldName: string) => dependencies.includes(fieldName),
  };
}
</file>

<file path="hooks/useSafeForm.ts">
"use client";

import { useState, useEffect } from 'react';
import { useForm as useReactHookForm } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';

/**
 * A wrapper around react-hook-form's useForm that provides safer initialization
 * and error handling for turbopack compatibility
 */
export function useSafeForm(options: any = {}) {
  const [isReady, setIsReady] = useState(false);
  const [error, setError] = useState<Error | null>(null);
  
  // Create a safe version of the options
  const safeOptions = {
    defaultValues: options.defaultValues || {},
    resolver: options.validationSchema ? zodResolver(options.validationSchema) : undefined,
    mode: 'onChange'
  };
  
  // Initialize form with error handling
  let form;
  try {
    form = useReactHookForm(safeOptions);
  } catch (e) {
    console.error('Error initializing form:', e);
    setError(e instanceof Error ? e : new Error(String(e)));
    
    // Return a minimal implementation to prevent further errors
    form = {
      register: () => ({}),
      handleSubmit: (cb) => () => {},
      formState: { errors: {} },
      watch: () => {},
      setValue: () => {},
      getValues: () => ({}),
      reset: () => {},
      control: {}
    };
  }
  
  // Mark as ready after initial render
  useEffect(() => {
    setIsReady(true);
  }, []);
  
  return {
    form,
    isReady,
    error
  };
}
</file>

<file path="hooks/useSelectOptions.ts">
import { useQuery } from '@tanstack/react-query';
import { apiClient } from '@/features/core/tanstack-query-api/core/apiClient';
import { UseApiQueryOptions } from '@/features/core/tanstack-query-api';

/**
 * Options for the useSelectOptions hook
 */
export interface SelectOptionsConfig {
  /**
   * API endpoint to fetch options
   */
  endpoint: string;
  
  /**
   * The property name to use as the label in the returned options
   * @default 'name'
   */
  labelKey?: string;
  
  /**
   * The property name to use as the value in the returned options
   * @default 'id'
   */
  valueKey?: string;
  
  /**
   * Path to the array of items in the response
   * Examples: 'content', 'data', 'data.items'
   */
  contentPath?: string;
  
  /**
   * Additional query options for the API request
   */
  queryOptions?: UseApiQueryOptions<any>;
  
  /**
   * Dependencies that will trigger refetching when changed
   * This can be a string, string array, or an object with dependency values
   */
  dependencies?: string | string[] | Record<string, any>;
  
  /**
   * How long to consider the data "fresh" (in milliseconds)
   * @default 5 minutes
   */
  staleTime?: number;
  
  /**
   * Cache time for the query (in milliseconds)
   * @default 10 minutes
   */
  cacheTime?: number;
  
  /**
   * Transform function to convert API response to options format
   */
  transformResponse?: (data: any) => Array<{ label: string; value: string }>;
  
  /**
   * Debug mode to log API requests and responses
   */
  debug?: boolean;
}

/**
 * Hook to fetch options for select fields from an API endpoint
 * 
 * @param config Configuration for the select options
 * @returns Object with options array and loading state
 */
export function useSelectOptions(config: SelectOptionsConfig) {
  const {
    endpoint,
    labelKey = 'name',
    valueKey = 'id',
    queryOptions,
    dependencies,
    staleTime = 5 * 60 * 1000, // 5 minutes
    cacheTime = 10 * 60 * 1000, // 10 minutes
    transformResponse,
    debug = false,
  } = config;
  
  // Enable debugging if specified
  if (debug) {
    console.log(`[useSelectOptions] Setting up query for endpoint: ${endpoint}`);
    console.log(`[useSelectOptions] Dependencies:`, dependencies);
  }
  
  // Build query key based on endpoint and dependencies
  const queryKey = ['select-options', endpoint];
  
  // Add dependencies to query key if present
  if (dependencies) {
    if (typeof dependencies === 'string') {
      queryKey.push(dependencies);
    } else if (Array.isArray(dependencies)) {
      queryKey.push(...dependencies);
    } else {
      // For object dependencies, add each key-value pair
      Object.entries(dependencies).forEach(([key, value]) => {
        queryKey.push(`${key}:${value}`);
      });
    }
  }
  
  // Add queryOptions to query key if present
  if (queryOptions && queryOptions.params) {
    Object.entries(queryOptions.params).forEach(([key, value]) => {
      queryKey.push(`${key}:${value}`);
    });
  }
  
  if (debug) {
    console.log(`[useSelectOptions] Query key:`, queryKey);
  }
  
  // Custom transform function
  const defaultTransform = (data: any) => {
    if (!data) return [];
    
    // Extract data array using contentPath or common patterns
    let items = [];
    
    // If contentPath is specified, use it to extract data
    if (config.contentPath && typeof config.contentPath === 'string') {
      try {
        // Handle nested paths like 'data.items'
        const paths = config.contentPath.split('.');
        let result = data;
        
        for (const path of paths) {
          if (result && result[path]) {
            result = result[path];
          } else {
            result = null;
            break;
          }
        }
        
        if (Array.isArray(result)) {
          items = result;
        }
      } catch (error) {
        console.error(`[useSelectOptions] Error accessing contentPath:`, error);
      }
    }
    // Otherwise try common patterns
    else if (Array.isArray(data)) {
      items = data;
    } else if (data.content && Array.isArray(data.content)) {
      items = data.content;
    } else if (data.data && Array.isArray(data.data)) {
      items = data.data;
    } else if (data.items && Array.isArray(data.items)) {
      items = data.items;
    } else if (data.results && Array.isArray(data.results)) {
      items = data.results;
    }
    
    if (debug) {
      console.log(`[useSelectOptions] Data type:`, typeof data);
      console.log(`[useSelectOptions] Data structure:`, JSON.stringify(data).substring(0, 200));
      console.log(`[useSelectOptions] Extracted items:`, items);
    }
          
    return items
      .filter(item => item) // Filter out null/undefined items
      .map(item => ({
        label: item[labelKey] || String(item),
        value: String(item[valueKey] || item)
      }));
  };
  
  // Execute the query
  const query = useQuery({
    queryKey,
    queryFn: async () => {
      if (debug) {
        console.log(`[useSelectOptions] Fetching data from: ${endpoint}`);
      }
      
      try {
        const response = await apiClient.get(endpoint, queryOptions);
        
        if (debug) {
          console.log(`[useSelectOptions] Response:`, response);
        }
        
        if (!response || !response.data) {
          if (debug) {
            console.warn(`[useSelectOptions] Empty response or no data from ${endpoint}`);
          }
          return [];
        }
        
        const transformedData = transformResponse 
          ? transformResponse(response.data)
          : defaultTransform(response.data);
          
        if (debug) {
          console.log(`[useSelectOptions] Transformed options:`, transformedData);
        }
        
        return transformedData;
      } catch (error) {
        console.error(`[useSelectOptions] Error fetching from ${endpoint}:`, error);
        return [];
      }
    },
    staleTime,
    gcTime: cacheTime,
  });
  
  if (debug && query.isError) {
    console.error(`[useSelectOptions] Query error:`, query.error);
  }
  
  return {
    options: query.data || [],
    isLoading: query.isLoading,
    isError: query.isError,
    error: query.error,
    refetch: query.refetch,
    status: query.status,
  };
}
</file>

<file path="index.d.ts">
declare module '@/features/core/entity-management' {
  import { SortingState, ColumnFiltersState, VisibilityState } from '@tanstack/react-table';
  
  // Base entity interface
  export interface BaseEntity {
    id: string | number;
    [key: string]: any;
  }
  
  // EntityStore interface
  export interface EntityStore<TData = any, TFilter = any> {
    getState: () => EntityState<TData, TFilter>;
    setState: (state: Partial<EntityState<TData, TFilter>>) => void;
    subscribe: (callback: (state: EntityState<TData, TFilter>) => void) => () => void;
    
    // Actions
    setSelectedItems: (items: TData[]) => void;
    setSorting: (sorting: SortingState) => void;
    setColumnFilters: (filters: ColumnFiltersState) => void;
    setColumnVisibility: (visibility: VisibilityState) => void;
    setLoading: (isLoading: boolean) => void;
  }
  
  // EntityState interface
  export interface EntityState<TData = any, TFilter = any> {
    // Form state
    isModalOpen: boolean;
    formMode: FormMode;
    selectedItem: TData | null;
    formData: Partial<TData>;
    isSubmitting: boolean;
    submitError: string | null;
    
    // Table state
    items: TData[];
    totalItems: number;
    totalPages: number;
    currentPage: number;
    pageSize: number;
    isLoading: boolean;
    error: Error | null;
    
    // Selection state
    selectedItems: TData[];
    selectedIds: string[];
    
    // Sorting state
    sorting: SortingState;
    
    // Filtering state
    filters: TFilter;
    columnFilters: ColumnFiltersState;
    columnVisibility: VisibilityState;
    globalFilter: string;
    
    // Search state
    searchQuery: string;
    searchColumn: string;
  }
  
  // Form mode type
  export type FormMode = 'view' | 'create' | 'edit';
  
  // Section config type for forms
  export interface SectionConfig {
    title: string;
    description?: string;
    icon?: React.ReactNode;
    fields: FieldConfig[];
  }
  
  // Field config type for forms
  export interface FieldConfig {
    name: string;
    label: string;
    type: string;
    placeholder?: string;
    description?: string;
    required?: boolean;
    options?: any;
    icon?: React.ReactNode;
    className?: string;
    [key: string]: any;
  }
  
  // Entity Manager creation function
  export function createEntityStore<TData = any, TFilter = any>(
    storeId?: string,
    options?: {
      defaultPageSize?: number;
      defaultSearchColumn?: string;
      defaultFilters?: TFilter;
      persist?: boolean;
      enableLogging?: boolean;
    }
  ): EntityStore<TData, TFilter>;
}
</file>

<file path="index.ts">
/**
 * Entity Management Feature
 * -----------------------
 * A modular system for managing entities with CRUD operations, forms, tables, and more.
 */

// Export main components
export { EntityManager } from './components/EntityManager';

// Export context system
export { 
  EntityManagerProvider,
  useEntityManager,
} from './context';

// Export hooks
export {
  useEntityModal,
  useEntitySync,
  useEntityPermissions,
} from './hooks';

// Export store functions
export {
  createEntityStore,
  type EntityStore,
} from './store';

// Export types
export * from './types';

// Export components for advanced usage
export {
  // Organisms
  EntityTable,
  EntityFormSheet,
  EntityFormDialog,
  // Templates
  EntityManagerLayout,
  // Atoms and Molecules
  EntityNoAccess,
  EntityActionBar,
  EntityFormControls,
  // Data Table and Forms (re-exported)
  EntityDataTable,
  EntityForm,

} from './components';

// Export services, utils and validation
export * from './services';
export * from './utils';
export * from './validation';
</file>

<file path="permissions/index.ts">
export * from './PermissionGuard';
export * from './RoleBasedActions';
</file>

<file path="permissions/PermissionGuard.tsx">
import React from 'react';

// Define a type for the permission checking function
type PermissionChecker = (feature: string, permission: string) => boolean;

// Create a default context
const PermissionContext = React.createContext<{
  checkPermission: PermissionChecker;
}>({
  // Default permission checker
  checkPermission: () => true, // By default, grant all permissions
});

// Provider props
interface PermissionProviderProps {
  children: React.ReactNode;
  checkPermission: PermissionChecker;
}

/**
 * Permission Provider component to provide permission checking to all child components
 */
export function PermissionProvider({
  children,
  checkPermission,
}: PermissionProviderProps) {
  return (
    <PermissionContext.Provider value={{ checkPermission }}>
      {children}
    </PermissionContext.Provider>
  );
}

/**
 * Custom hook to use permissions in any component
 */
export function usePermission() {
  return React.useContext(PermissionContext);
}

/**
 * Permission Guard component to conditionally render content based on permissions
 */
interface PermissionGuardProps {
  /**
   * Feature the permission belongs to
   */
  feature: string;
  
  /**
   * Permission required to view the content
   */
  permission: string;
  
  /**
   * Content to render if allowed
   */
  children: React.ReactNode;
  
  /**
   * Content to render if not allowed
   */
  fallback?: React.ReactNode;
}

export function PermissionGuard({
  feature,
  permission,
  children,
  fallback = null,
}: PermissionGuardProps) {
  const { checkPermission } = usePermission();
  
  const allowed = checkPermission(feature, permission);
  
  if (allowed) {
    return <>{children}</>;
  }
  
  return <>{fallback}</>;
}

/**
 * Higher-order component to apply permission check to any component
 */
export function withPermission<P extends object>(
  Component: React.ComponentType<P>,
  feature: string,
  permission: string,
  FallbackComponent: React.ComponentType<P> | null = null
) {
  return function WithPermissionComponent(props: P) {
    return (
      <PermissionGuard
        feature={feature}
        permission={permission}
        fallback={FallbackComponent ? <FallbackComponent {...props} /> : null}
      >
        <Component {...props} />
      </PermissionGuard>
    );
  };
}

/**
 * Helper hook to check multiple permissions at once
 */
export function useHasPermissions(
  permissions: Array<{ feature: string; permission: string }>
) {
  const { checkPermission } = usePermission();
  
  return permissions.every(({ feature, permission }) =>
    checkPermission(feature, permission)
  );
}

/**
 * Helper function to check if a user has any of the specified permissions
 */
export function hasAnyPermission(
  permissionChecker: PermissionChecker,
  permissions: Array<{ feature: string; permission: string }>
) {
  return permissions.some(({ feature, permission }) =>
    permissionChecker(feature, permission)
  );
}
</file>

<file path="permissions/RoleBasedActions.tsx">
import React from 'react';
import { usePermission } from './PermissionGuard';

export interface RoleBasedAction<T = any> {
  /**
   * Action label
   */
  label: string;
  
  /**
   * Click handler
   */
  onClick: (item: T) => void;
  
  /**
   * Button variant
   */
  variant?: 'default' | 'destructive' | 'outline' | 'ghost';
  
  /**
   * Button size
   */
  size?: 'default' | 'sm' | 'lg';
  
  /**
   * Icon to display
   */
  icon?: React.ReactNode;
  
  /**
   * Whether the action is disabled
   */
  disabled?: boolean | ((item: T) => boolean);
  
  /**
   * Required permission
   */
  permission?: {
    feature: string;
    action: string;
  };
  
  /**
   * Order of the action (for sorting)
   */
  order?: number;
  
  /**
   * Whether to show the action in a dropdown menu
   */
  showInDropdown?: boolean;
  
  /**
   * Whether to confirm before executing
   */
  confirmRequired?: boolean;
  
  /**
   * Confirmation message
   */
  confirmMessage?: string;
  
  /**
   * Custom tooltip
   */
  tooltip?: string;
}

export interface RoleBasedActionsProps<T = any> {
  /**
   * Actions to filter
   */
  actions: RoleBasedAction<T>[];
  
  /**
   * Current item
   */
  item: T;
  
  /**
   * Feature the actions belong to
   */
  feature: string;
  
  /**
   * Whether to filter actions based on permissions
   */
  filterByPermission?: boolean;
  
  /**
   * Render function for actions
   */
  renderActions?: (actions: RoleBasedAction<T>[]) => React.ReactNode;
}

/**
 * Component to filter and render actions based on user permissions
 */
export function RoleBasedActions<T = any>({
  actions,
  item,
  feature,
  filterByPermission = true,
  renderActions,
}: RoleBasedActionsProps<T>) {
  const { checkPermission } = usePermission();
  
  // Filter actions based on permissions
  const filteredActions = React.useMemo(() => {
    if (!filterByPermission) {
      return actions;
    }
    
    return actions.filter(action => {
      // If no permission is specified, always allow
      if (!action.permission) {
        return true;
      }
      
      // Check if user has the required permission
      const { feature: actionFeature, action: permission } = action.permission;
      return checkPermission(actionFeature || feature, permission);
    });
  }, [actions, feature, filterByPermission, checkPermission]);
  
  // Sort actions by order
  const sortedActions = React.useMemo(() => {
    return [...filteredActions].sort((a, b) => {
      const orderA = a.order || 0;
      const orderB = b.order || 0;
      return orderA - orderB;
    });
  }, [filteredActions]);
  
  // Process actions (apply disabled state)
  const processedActions = React.useMemo(() => {
    return sortedActions.map(action => {
      const isDisabled = typeof action.disabled === 'function'
        ? action.disabled(item)
        : action.disabled;
      
      return {
        ...action,
        disabled: isDisabled,
      };
    });
  }, [sortedActions, item]);
  
  // If custom render function is provided, use it
  if (renderActions) {
    return <>{renderActions(processedActions)}</>;
  }
  
  // Default rendering (just return the actions array)
  return <>{processedActions}</>;
}

/**
 * Hook to filter actions based on permissions
 */
export function useRoleBasedActions<T = any>(
  actions: RoleBasedAction<T>[],
  feature: string,
  filterByPermission = true
) {
  const { checkPermission } = usePermission();
  
  return React.useMemo(() => {
    if (!filterByPermission) {
      return actions;
    }
    
    return actions
      .filter(action => {
        // If no permission is specified, always allow
        if (!action.permission) {
          return true;
        }
        
        // Check if user has the required permission
        const { feature: actionFeature, action: permission } = action.permission;
        return checkPermission(actionFeature || feature, permission);
      })
      .sort((a, b) => {
        const orderA = a.order || 0;
        const orderB = b.order || 0;
        return orderA - orderB;
      });
  }, [actions, feature, filterByPermission, checkPermission]);
}
</file>

<file path="README.md">
# Entity Management Framework

A comprehensive framework for building CRUD-based entity management interfaces with tables, forms, and modals following atomic design principles.

## Framework Overview

The Entity Management framework provides a flexible system for managing entities (database records) with consistent CRUD operations, form handling, data tables, and permission controls.

### Key Features

- **Complete CRUD Operations**: Create, read, update, and delete entities with a consistent API
- **Form Management**: Flexible form building with sections, field dependencies, and validation
- **Data Tables**: Sortable, filterable, searchable tables with pagination and bulk actions
- **Permission Controls**: Role-based access control integration
- **UI Components**: Follows atomic design principles with atoms, molecules, organisms, and templates

## Architecture 

The framework follows atomic design and feature-based architecture:

```
entity-management/
├── components/                # UI components organized by atomic design
│   ├── atoms/                 # Basic UI elements
│   ├── molecules/             # Combinations of atoms
│   ├── organisms/             # Complex components made of molecules
│   ├── templates/             # Page layouts
│   ├── data-table/            # Data table components
│   ├── entity-form/           # Form components
│   ├── form-fields/           # Field renderer components
│   └── ...
├── context/                   # React context providers
├── hooks/                     # Custom React hooks
├── services/                  # API and other services
├── store/                     # State management (Zustand)
├── types/                     # TypeScript type definitions
├── utils/                     # Utility functions
└── validation/                # Validation logic
```

## Main Components

### EntityManager

The main entry point for creating entity management interfaces:

```tsx
<EntityManager
  endpoints={{
    getAll: '/api/users',
    getById: '/api/users/{id}',
    create: '/api/users',
    update: '/api/users/{id}',
    delete: '/api/users/{id}',
  }}
  permissions={{
    feature: 'users',
    view: 'users:view',
    create: 'users:create',
    update: 'users:update',
    delete: 'users:delete',
  }}
  labels={{
    entityName: 'User',
    entityNamePlural: 'Users',
    createTitle: 'Create New User',
    editTitle: 'Edit User',
    viewTitle: 'User Details',
  }}
  columns={[
    // Table column definitions
  ]}
  formFields={[
    // Form field definitions
  ]}
  formSections={[
    // Form section definitions
  ]}
/>
```

### EntityTable

Table component for displaying, filtering, and selecting entities:

```tsx
<EntityTable
  columns={columns}
  filterableColumns={['status', 'role']}
  searchableColumns={['name', 'email']}
  enableRowSelection={true}
  enableRowClick={true}
  onRowClick={(item) => showDetails(item)}
/>
```

### EntityForm

Form component for creating, editing, and viewing entities:

```tsx
<EntityForm
  formMode="create"
  fields={formFields}
  sections={formSections}
  onSubmit={handleSubmit}
  validationSchema={validationSchema}
/>
```

## Hooks

- `useEntityManager`: Access entity manager context
- `useEntityModal`: Manage entity modals
- `useEntityPermissions`: Check permissions for actions
- `useFormDependencies`: Handle form field dependencies
- `useDependentFields`: Fetch dependent options (for dropdowns)

## State Management

Uses Zustand for state management:

```tsx
const entityStore = createEntityStore<User, UserFilter>('users', {
  defaultPageSize: 10,
  defaultFilters: { status: 'active' },
});
```

## Types and Interfaces

```tsx
interface EntityManagerProps<TData extends BaseEntity = any, TFilter = any> {
  // Core configuration
  endpoints: EntityApiEndpoints;
  permissions?: EntityPermissions;
  labels: EntityLabels;
  
  // Table configuration
  columns: ColumnDef<TData, any>[];
  tableProps?: Partial<EntityDataTableProps<TData, any>>;
  
  // Form configuration
  formFields?: FieldConfig[];
  formSections?: SectionConfig[];
  defaultValues?: Partial<TData>;
  // ...
}
```

## Usage Guidelines

1. **Use Atomic Design**: Follow the atoms -> molecules -> organisms pattern
2. **Feature-Based Structure**: Keep entity-specific components in their feature folders
3. **Core vs Features**: This framework is a core module that should be consumed by features
4. **TypeScript Best Practices**: Always use proper types instead of `any`
5. **Consistent Naming**: Follow the naming conventions in the codebase

## Future Improvements

- Add comprehensive test suite
- Implement form field polymorphism
- Enhance accessibility features
- Add visual customization options

## Development Guidelines

When modifying the Entity Management framework:

1. Ensure backward compatibility
2. Write comprehensive tests
3. Document public APIs
4. Follow atomic design principles
5. Avoid duplicate code
6. Use TypeScript properly (avoid `any` types)
</file>

<file path="services/api/index.ts">
/**
 * Entity Management API Service Functions
 * Provides helpers for interacting with entity APIs
 */

import { BaseEntity, FormMode } from '@/features/core/tanstack-query-api';

/**
 * Current API service version
 */
export const API_SERVICE_VERSION = '1.0.0';

/**
 * Interface for entity data transformation
 */
export interface EntityDataTransformer<T = any> {
  /**
   * Transform data before sending to API
   * @param data Data to transform
   * @param mode Current form mode
   * @returns Transformed data
   */
  transformFormData?: (data: T, mode: FormMode) => any;
  
  /**
   * Transform data received from API
   * @param data Data from API
   * @returns Transformed data
   */
  transformResponseData?: (data: any) => T;
}

/**
 * Format entity endpoint URL with path parameters
 * 
 * @param url The URL template with path parameters (e.g., "/api/users/{id}")
 * @param params The parameters to substitute
 * @returns Formatted URL with parameters replaced
 */
export function formatEntityUrl(url: string, params: Record<string, string | number>): string {
  let formattedUrl = url;
  
  // Replace all placeholders in format {paramName}
  Object.entries(params).forEach(([key, value]) => {
    const placeholder = `{${key}}`;
    if (formattedUrl.includes(placeholder)) {
      formattedUrl = formattedUrl.replace(placeholder, encodeURIComponent(String(value)));
    }
  });
  
  return formattedUrl;
}

/**
 * Build query string from parameters
 * 
 * @param params Object containing query parameters
 * @returns Formatted query string starting with "?"
 */
export function buildQueryString(params: Record<string, any>): string {
  const validParams = Object.entries(params)
    .filter(([_, value]) => value !== undefined && value !== null && value !== '')
    .reduce((acc, [key, value]) => {
      acc[key] = value;
      return acc;
    }, {} as Record<string, any>);
  
  if (Object.keys(validParams).length === 0) {
    return '';
  }
  
  const searchParams = new URLSearchParams();
  
  Object.entries(validParams).forEach(([key, value]) => {
    if (Array.isArray(value)) {
      value.forEach(item => searchParams.append(`${key}[]`, String(item)));
    } else {
      searchParams.append(key, String(value));
    }
  });
  
  return `?${searchParams.toString()}`;
}

/**
 * Standard entity filter schema
 */
export interface EntityFilter {
  page?: number;
  size?: number;
  sort?: string;
  direction?: 'asc' | 'desc';
  search?: string;
  [key: string]: any;
}

/**
 * Build URL with filter parameters
 * 
 * @param baseUrl Base URL without query parameters
 * @param filter Filter object
 * @returns URL with query parameters
 */
export function buildEntityUrl(baseUrl: string, filter?: EntityFilter): string {
  if (!filter || Object.keys(filter).length === 0) {
    return baseUrl;
  }
  
  return `${baseUrl}${buildQueryString(filter)}`;
}
</file>

<file path="services/index.ts">
/**
 * Entity Management Services
 * 
 * This file exports all services from the entity management module:
 * - API: Functions for interacting with entity APIs
 * - Permissions: Functions for managing entity access permissions
 * - Workflow: Services for entity state workflows and transitions
 */

// Export API services for data transformation and URL formatting
export * from './api';

// Export permission services for access control
export * from './permissions';

// Export workflow services for entity state management
export * from './workflow';
</file>

<file path="services/permissions/index.ts">
/**
 * Entity Management Permissions Service
 * Provides helpers for checking and processing entity permissions
 */

import { EntityPermissions } from '../../types';

/**
 * Current permissions service version
 */
export const PERMISSIONS_SERVICE_VERSION = '1.0.0';

/**
 * Permission requirement configuration
 */
export interface PermissionRequirement {
  feature: string;
  action: string;
}

/**
 * Checks if a user has the required permission based on the EntityPermissions config
 * 
 * @param permissions The entity permissions configuration
 * @param operation The operation being performed ('view', 'create', 'update', 'delete')
 * @param userPermissionCheckFn Function to check if user has permission
 * @returns Whether the user has permission
 */
export function checkEntityPermission(
  permissions: EntityPermissions | undefined,
  operation: 'view' | 'create' | 'update' | 'delete',
  userPermissionCheckFn: (feature: string, action: string) => boolean
): boolean {
  // If no permissions are specified, allow the operation
  if (!permissions) {
    return true;
  }
  
  // Get the permission needed for this operation
  const { feature } = permissions;
  const action = permissions[operation];
  
  // If no action is specified for this operation, allow it
  if (!action) {
    return true;
  }
  
  // Check if the user has this permission
  return userPermissionCheckFn(feature, action);
}

/**
 * Creates a permission object based on entity permissions and operation
 * 
 * @param permissions The entity permissions configuration
 * @param operation The operation being performed ('view', 'create', 'update', 'delete')
 * @returns Permission requirement object or undefined if no permission needed
 */
export function createPermissionRequirement(
  permissions: EntityPermissions | undefined,
  operation: 'view' | 'create' | 'update' | 'delete'
): PermissionRequirement | undefined {
  // If no permissions are specified, no requirement
  if (!permissions) {
    return undefined;
  }
  
  // Get the permission needed for this operation
  const { feature } = permissions;
  const action = permissions[operation];
  
  // If no action is specified for this operation, no requirement
  if (!action) {
    return undefined;
  }
  
  return { feature, action };
}

/**
 * Get entity operation permission attributes for a component
 * Used for attaching data attributes to components for permission checking
 * 
 * @param permissions The entity permissions configuration
 * @param operation The operation being performed ('view', 'create', 'update', 'delete')
 * @returns Data attributes object for the component
 */
export function getPermissionAttributes(
  permissions: EntityPermissions | undefined,
  operation: 'view' | 'create' | 'update' | 'delete'
): Record<string, string> {
  // If no permissions are specified, return empty object
  if (!permissions) {
    return {};
  }
  
  // Get the permission needed for this operation
  const { feature } = permissions;
  const action = permissions[operation];
  
  // If no action is specified for this operation, return empty object
  if (!action) {
    return {};
  }
  
  return {
    'data-permission-feature': feature,
    'data-permission-action': action
  };
}
</file>

<file path="services/workflow/index.ts">
/**
 * Entity Management Workflow Service
 * Provides workflow state management for entities
 */

import { BaseEntity } from '@/features/core/tanstack-query-api';

/**
 * Current workflow service version
 */
export const WORKFLOW_SERVICE_VERSION = '1.0.0';

/**
 * Workflow state interface
 */
export interface WorkflowState {
  id: string;
  name: string;
  color?: string;
  order: number;
  isInitial?: boolean;
  isFinal?: boolean;
  allowDelete?: boolean;
  allowEdit?: boolean;
}

/**
 * Workflow transition interface
 */
export interface WorkflowTransition {
  id: string;
  name: string;
  fromState: string;
  toState: string;
  permission?: string;
  confirmationRequired?: boolean;
  confirmationMessage?: string;
}

/**
 * Workflow configuration interface
 */
export interface WorkflowConfig<T extends BaseEntity = any> {
  entityType: string;
  states: WorkflowState[];
  transitions: WorkflowTransition[];
  stateField: keyof T;
  getAvailableTransitions?: (entity: T, userPermissions: string[]) => WorkflowTransition[];
  onTransition?: (entity: T, transition: WorkflowTransition) => Promise<void>;
}

/**
 * Workflow registry to manage different entity workflows
 */
class WorkflowRegistry {
  private workflows: Map<string, WorkflowConfig> = new Map();
  
  /**
   * Register a new workflow
   * 
   * @param config Workflow configuration
   */
  registerWorkflow<T extends BaseEntity>(config: WorkflowConfig<T>): void {
    this.workflows.set(config.entityType, config);
  }
  
  /**
   * Get workflow configuration by entity type
   * 
   * @param entityType Type of entity
   * @returns Workflow configuration
   */
  getWorkflow<T extends BaseEntity>(entityType: string): WorkflowConfig<T> | undefined {
    return this.workflows.get(entityType) as WorkflowConfig<T> | undefined;
  }
  
  /**
   * Check if workflow exists for entity type
   * 
   * @param entityType Type of entity
   * @returns Whether workflow exists
   */
  hasWorkflow(entityType: string): boolean {
    return this.workflows.has(entityType);
  }
  
  /**
   * Get all registered workflows
   * 
   * @returns List of registered workflow configurations
   */
  getAllWorkflows(): WorkflowConfig[] {
    return Array.from(this.workflows.values());
  }
}

/**
 * Global workflow registry instance
 */
export const workflowRegistry = new WorkflowRegistry();

/**
 * Get the current state of an entity
 * 
 * @param entity Entity to check
 * @param workflow Workflow configuration
 * @returns Current workflow state or undefined
 */
export function getEntityState<T extends BaseEntity>(
  entity: T,
  workflow: WorkflowConfig<T>
): WorkflowState | undefined {
  if (!entity) return undefined;
  
  const stateValue = entity[workflow.stateField] as string;
  return workflow.states.find(state => state.id === stateValue);
}

/**
 * Get available transitions for an entity
 * 
 * @param entity Entity to check
 * @param workflow Workflow configuration
 * @param userPermissions User permissions
 * @returns Available transitions
 */
export function getAvailableTransitions<T extends BaseEntity>(
  entity: T,
  workflow: WorkflowConfig<T>,
  userPermissions: string[] = []
): WorkflowTransition[] {
  if (!entity) return [];
  
  // Use custom function if provided
  if (workflow.getAvailableTransitions) {
    return workflow.getAvailableTransitions(entity, userPermissions);
  }
  
  // Default implementation
  const currentState = entity[workflow.stateField] as string;
  
  return workflow.transitions.filter(transition => {
    // Must match current state
    if (transition.fromState !== currentState) return false;
    
    // Check permission if required
    if (transition.permission && !userPermissions.includes(transition.permission)) {
      return false;
    }
    
    return true;
  });
}

/**
 * Execute a workflow transition
 * 
 * @param entity Entity to transition
 * @param transition Transition to execute
 * @param workflow Workflow configuration
 * @returns Updated entity with new state
 */
export async function executeTransition<T extends BaseEntity>(
  entity: T,
  transition: WorkflowTransition,
  workflow: WorkflowConfig<T>
): Promise<T> {
  // Validate transition is applicable
  const currentState = entity[workflow.stateField] as string;
  if (transition.fromState !== currentState) {
    throw new Error(`Invalid transition: Entity is in state ${currentState}, transition requires ${transition.fromState}`);
  }
  
  // Create updated entity
  const updatedEntity = {
    ...entity,
    [workflow.stateField]: transition.toState
  };
  
  // Call custom hook if provided
  if (workflow.onTransition) {
    await workflow.onTransition(updatedEntity, transition);
  }
  
  return updatedEntity;
}

/**
 * Check if an entity can be edited based on its workflow state
 * 
 * @param entity Entity to check
 * @param workflow Workflow configuration
 * @returns Whether entity can be edited
 */
export function canEditEntity<T extends BaseEntity>(
  entity: T,
  workflow: WorkflowConfig<T>
): boolean {
  const state = getEntityState(entity, workflow);
  if (!state) return true; // If no state is found, default to allowing edit
  
  return state.allowEdit !== false; // Default to true if not specified
}

/**
 * Check if an entity can be deleted based on its workflow state
 * 
 * @param entity Entity to check
 * @param workflow Workflow configuration
 * @returns Whether entity can be deleted
 */
export function canDeleteEntity<T extends BaseEntity>(
  entity: T,
  workflow: WorkflowConfig<T>
): boolean {
  const state = getEntityState(entity, workflow);
  if (!state) return true; // If no state is found, default to allowing delete
  
  return state.allowDelete !== false; // Default to true if not specified
}
</file>

<file path="store/actions.ts">
import { StoreApi } from 'zustand';
import { EntityState, EntityBaseState } from './types';
import { FormMode } from '@/features/core/tanstack-query-api';
import { ColumnFiltersState, SortingState, VisibilityState } from '@tanstack/react-table';

type StoreType<TData, TFilter> = StoreApi<EntityState<TData, TFilter>>;
type StateUpdates<TData, TFilter> = Partial<EntityBaseState<TData, TFilter>>;

interface StoreConfig<TFilter> {
  updateThreshold: number;
  defaultPageSize: number;
  defaultSearchColumn: string;
  defaultFilters: TFilter;
  enableLogging?: boolean;
  storeId: string;
}

export const createActions = <TData extends Record<string, any>, TFilter extends Record<string, any>>(
  store: StoreType<TData, TFilter>,
  config: StoreConfig<TFilter>
) => {
  const {
    updateThreshold,
    defaultPageSize,
    defaultSearchColumn,
    defaultFilters,
    enableLogging,
    storeId
  } = config;

  // Safe update helper with type checking
  const safeUpdate = (updates: StateUpdates<TData, TFilter>, actionType: string) => {
    const state = store.getState();
    const now = Date.now();
    const timeSinceLastUpdate = now - state.lastUpdateTime;
    
    if (timeSinceLastUpdate < updateThreshold) {
      return;
    }

    if (enableLogging) {
      console.log(`[EntityStore:${storeId}] ${actionType}:`, updates);
    }

    store.setState(state => ({
      ...state,
      ...updates,
      lastUpdateTime: now
    }));
  };

  // Form actions
  const formActions = {
    openModal: (mode: FormMode, item: TData | null = null) => {
      safeUpdate({
        isModalOpen: true,
        formMode: mode,
        selectedItem: item,
        formData: item || {},
        submitError: null
      }, 'openModal');
    },

    closeModal: () => {
      safeUpdate({
        isModalOpen: false,
        submitError: null,
        selectedItem: null,
        formData: {}
      }, 'closeModal');
    },

    setFormMode: (mode: FormMode) => {
      safeUpdate({ formMode: mode }, 'setFormMode');
    },

    setSelectedItem: (item: TData | null) => {
      safeUpdate({
        selectedItem: item,
        formData: item || {}
      }, 'setSelectedItem');
    },

    updateFormData: (data: Partial<TData>) => {
      const state = store.getState();
      const currentFormData = state.formData || {};
      const hasChanges = Object.keys(data).some(key => {
        const k = key as keyof TData;
        return !Object.is(currentFormData[k], data[k]);
      });

      if (!hasChanges) return;

      safeUpdate({
        formData: { ...currentFormData, ...data }
      }, 'updateFormData');
    },

    resetFormData: (defaultValues?: Partial<TData>) => {
      safeUpdate({ 
        formData: defaultValues || {} 
      }, 'resetFormData');
    },

    setSubmitting: (isSubmitting: boolean) => {
      safeUpdate({ isSubmitting }, 'setSubmitting');
    },

    setSubmitError: (error: string | null) => {
      safeUpdate({ submitError: error }, 'setSubmitError');
    }
  };

  // Table actions
  const tableActions = {
    setItems: (items: TData[]) => {
      safeUpdate({ items }, 'setItems');
    },

    setTotalItems: (totalItems: number) => {
      safeUpdate({ totalItems }, 'setTotalItems');
    },

    setTotalPages: (totalPages: number) => {
      safeUpdate({ totalPages }, 'setTotalPages');
    },

    setCurrentPage: (page: number) => {
      safeUpdate({ currentPage: page }, 'setCurrentPage');
    },

    setPageSize: (pageSize: number) => {
      safeUpdate({
        pageSize,
        currentPage: 0
      }, 'setPageSize');
    },

    setLoading: (isLoading: boolean) => {
      safeUpdate({ isLoading }, 'setLoading');
    },

    setError: (error: Error | null) => {
      safeUpdate({ error }, 'setError');
    }
  };

  // Selection actions
  const selectionActions = {
    setSelectedItems: (items: TData[]) => {
      safeUpdate({ selectedItems: items }, 'setSelectedItems');
    },

    setSelectedIds: (ids: string[]) => {
      safeUpdate({ selectedIds: ids }, 'setSelectedIds');
    }
  };

  // Filter/Sort actions
  const filterActions = {
    setSorting: (sorting: SortingState) => {
      safeUpdate({ sorting }, 'setSorting');
    },

    setFilters: (filters: Partial<TFilter>) => {
      const state = store.getState();
      safeUpdate({
        filters: { ...state.filters, ...filters },
        currentPage: 0
      }, 'setFilters');
    },

    setColumnFilters: (filters: ColumnFiltersState) => {
      safeUpdate({
        columnFilters: filters,
        currentPage: 0
      }, 'setColumnFilters');
    },

    setColumnVisibility: (visibility: VisibilityState) => {
      safeUpdate({ columnVisibility: visibility }, 'setColumnVisibility');
    },

    setGlobalFilter: (filter: string) => {
      safeUpdate({
        globalFilter: filter,
        currentPage: 0
      }, 'setGlobalFilter');
    },

    setSearchQuery: (query: string) => {
      safeUpdate({
        searchQuery: query,
        currentPage: 0
      }, 'setSearchQuery');
    },

    setSearchColumn: (column: string) => {
      safeUpdate({ searchColumn: column }, 'setSearchColumn');
    }
  };

  // Reset actions
  const resetActions = {
    resetFilters: () => {
      safeUpdate({
        filters: defaultFilters,
        columnFilters: [],
        globalFilter: '',
        searchQuery: '',
        currentPage: 0
      }, 'resetFilters');
    },

    resetPagination: () => {
      safeUpdate({
        currentPage: 0,
        pageSize: defaultPageSize
      }, 'resetPagination');
    },

    resetTable: () => {
      safeUpdate({
        items: [],
        totalItems: 0,
        totalPages: 0,
        currentPage: 0,
        pageSize: defaultPageSize,
        selectedItems: [],
        selectedIds: [],
        sorting: [],
        columnFilters: [],
        columnVisibility: {},
        globalFilter: '',
        searchQuery: '',
        searchColumn: defaultSearchColumn
      }, 'resetTable');
    }
  };

  return {
    ...formActions,
    ...tableActions,
    ...selectionActions,
    ...filterActions,
    ...resetActions,
    reset: () => {
      store.setState({
        isModalOpen: false,
        formMode: 'view' as FormMode,
        selectedItem: null,
        formData: {},
        isSubmitting: false,
        submitError: null,
        items: [],
        totalItems: 0,
        totalPages: 0,
        currentPage: 0,
        pageSize: defaultPageSize,
        isLoading: false,
        error: null,
        selectedItems: [],
        selectedIds: [],
        filters: defaultFilters,
        columnFilters: [],
        columnVisibility: {},
        globalFilter: '',
        searchQuery: '',
        searchColumn: defaultSearchColumn,
        sorting: [],
        lastUpdateTime: Date.now()
      });
    }
  };
};
</file>

<file path="store/core/constants.ts">
/** Default configuration values */
export const DEFAULT_PAGE_SIZE = 10;
export const DEFAULT_SEARCH_COLUMN = '';
export const DEFAULT_UPDATE_THRESHOLD = 100; // ms
export const DEFAULT_STORE_ID = 'entity-store';

/** Form modes */
export const FORM_MODES = ['create', 'edit', 'view', 'delete'] as const;

/** Persistence configuration */
export const PERSISTED_FIELDS = [
  'pageSize',
  'columnVisibility',
  'filters',
  'sorting'
] as const;

/** Action type prefixes */
export const ACTION_TYPES = {
  // Form actions
  OPEN_MODAL: 'openModal',
  CLOSE_MODAL: 'closeModal',
  SET_FORM_MODE: 'setFormMode',
  SET_SELECTED_ITEM: 'setSelectedItem',
  UPDATE_FORM_DATA: 'updateFormData',
  RESET_FORM_DATA: 'resetFormData',
  SET_SUBMITTING: 'setSubmitting',
  SET_SUBMIT_ERROR: 'setSubmitError',

  // Table actions
  SET_ITEMS: 'setItems',
  SET_TOTAL_ITEMS: 'setTotalItems', 
  SET_TOTAL_PAGES: 'setTotalPages',
  SET_CURRENT_PAGE: 'setCurrentPage',
  SET_PAGE_SIZE: 'setPageSize',
  SET_LOADING: 'setLoading',
  SET_ERROR: 'setError',

  // Selection actions  
  SET_SELECTED_ITEMS: 'setSelectedItems',
  SET_SELECTED_IDS: 'setSelectedIds',

  // Filter/Sort actions
  SET_SORTING: 'setSorting',
  SET_FILTERS: 'setFilters',
  SET_COLUMN_FILTERS: 'setColumnFilters', 
  SET_COLUMN_VISIBILITY: 'setColumnVisibility',
  SET_GLOBAL_FILTER: 'setGlobalFilter',
  SET_SEARCH_QUERY: 'setSearchQuery',
  SET_SEARCH_COLUMN: 'setSearchColumn',

  // Reset actions
  RESET_FILTERS: 'resetFilters',
  RESET_PAGINATION: 'resetPagination',
  RESET_TABLE: 'resetTable',
  RESET: 'reset'
} as const;

/** State slice names */
export const STATE_SLICES = {
  FORM: 'form',
  TABLE: 'table',
  SELECTION: 'selection',
  FILTER: 'filter'
} as const;
</file>

<file path="store/core/types.ts">
import { FormMode } from '@/features/core/tanstack-query-api';
import { ColumnFiltersState, SortingState, VisibilityState } from '@tanstack/react-table';

// Core state interfaces
export interface EntityBaseState<TData, TFilter> extends
  FormState<TData>,
  TableState<TData>,
  SelectionState<TData>,
  FilterState<TFilter>,
  UpdateTracking {}

export interface EntityState<TData, TFilter> extends
  EntityBaseState<TData, TFilter>,
  EntityStoreActions<TData, TFilter> {}

export interface EntityStoreActions<TData, TFilter> {
  // Form actions
  openModal: (mode: FormMode, item?: TData | null) => void;
  closeModal: () => void;
  setFormMode: (mode: FormMode) => void;
  setSelectedItem: (item: TData | null) => void;
  updateFormData: (data: Partial<TData>) => void;
  resetFormData: (defaultValues?: Partial<TData>) => void;
  setSubmitting: (isSubmitting: boolean) => void;
  setSubmitError: (error: string | null) => void;

  // Table actions
  setItems: (items: TData[]) => void;
  setTotalItems: (totalItems: number) => void;
  setTotalPages: (totalPages: number) => void;
  setCurrentPage: (page: number) => void;
  setPageSize: (pageSize: number) => void;
  setLoading: (isLoading: boolean) => void;
  setError: (error: Error | null) => void;

  // Selection actions
  setSelectedItems: (items: TData[]) => void;
  setSelectedIds: (ids: string[]) => void;

  // Filter/Sort actions
  setSorting: (sorting: SortingState) => void;
  setFilters: (filters: Partial<TFilter>) => void;
  setColumnFilters: (filters: ColumnFiltersState) => void;
  setColumnVisibility: (visibility: VisibilityState) => void;
  setGlobalFilter: (filter: string) => void;
  setSearchQuery: (query: string) => void;
  setSearchColumn: (column: string) => void;

  // Reset actions
  resetFilters: () => void;
  resetPagination: () => void;
  resetTable: () => void;
  reset: () => void;
}

export interface FormState<TData> {
  isModalOpen: boolean;
  formMode: FormMode;
  selectedItem: TData | null;
  formData: Partial<TData>;
  isSubmitting: boolean;
  submitError: string | null;
}

export interface TableState<TData> {
  items: TData[];
  totalItems: number;
  totalPages: number;
  currentPage: number;
  pageSize: number;
  isLoading: boolean;
  error: Error | null;
}

export interface SelectionState<TData> {
  selectedItems: TData[];
  selectedIds: string[];
}

export interface FilterState<TFilter> {
  filters: TFilter;
  columnFilters: ColumnFiltersState;
  columnVisibility: VisibilityState;
  globalFilter: string;
  searchQuery: string;
  searchColumn: string;
  sorting: SortingState;
}

export interface UpdateTracking {
  lastUpdateTime: number;
}

// Core store configuration types
export interface EntityStoreConfig<TFilter> {
  storeId?: string;
  defaultPageSize?: number;
  defaultSearchColumn?: string;
  defaultFilters?: TFilter;
  persist?: boolean;
  enableLogging?: boolean;
  updateThreshold?: number;
}

export type PersistedState<TFilter> = {
  pageSize: number;
  columnVisibility: VisibilityState;
  filters: TFilter;
  sorting: any[];
};
</file>

<file path="store/core/validation.ts">
import { z } from 'zod';
import { FormMode } from '@/features/core/tanstack-query-api';
import { ColumnFiltersState, SortingState, VisibilityState } from '@tanstack/react-table';

// Primitive schemas
export const formModeSchema = z.enum(['create', 'edit', 'view', 'delete']);

export const columnFilterSchema = z.object({
  id: z.string(),
  value: z.any()
});

export const sortingSchema = z.object({
  id: z.string(),
  desc: z.boolean()
});

// State schemas
export const formStateSchema = <TData>() => z.object({
  isModalOpen: z.boolean(),
  formMode: formModeSchema,
  selectedItem: z.custom<TData | null>(),
  formData: z.record(z.any()),
  isSubmitting: z.boolean(),
  submitError: z.string().nullable()
});

export const tableStateSchema = <TData>() => z.object({
  items: z.array(z.custom<TData>()),
  totalItems: z.number().int().nonnegative(),
  totalPages: z.number().int().nonnegative(),
  currentPage: z.number().int().nonnegative(),
  pageSize: z.number().int().positive(),
  isLoading: z.boolean(),
  error: z.instanceof(Error).nullable()
});

export const selectionStateSchema = <TData>() => z.object({
  selectedItems: z.array(z.custom<TData>()),
  selectedIds: z.array(z.string())
});

export const filterStateSchema = <TFilter>() => z.object({
  filters: z.custom<TFilter>(),
  columnFilters: z.array(columnFilterSchema),
  columnVisibility: z.record(z.boolean()),
  globalFilter: z.string(),
  searchQuery: z.string(),
  searchColumn: z.string(),
  sorting: z.array(sortingSchema)
});

// Configuration schemas
export const entityStoreConfigSchema = <TFilter>() => z.object({
  storeId: z.string().optional(),
  defaultPageSize: z.number().int().positive().optional(),
  defaultSearchColumn: z.string().optional(),
  defaultFilters: z.custom<TFilter>().optional(),
  persist: z.boolean().optional(),
  enableLogging: z.boolean().optional(),
  updateThreshold: z.number().int().positive().optional()
});

// Helper functions
export const validateFormState = <TData>(data: unknown) => {
  return formStateSchema<TData>().parse(data);
};

export const validateTableState = <TData>(data: unknown) => {
  return tableStateSchema<TData>().parse(data);
};

export const validateSelectionState = <TData>(data: unknown) => {
  return selectionStateSchema<TData>().parse(data);
};

export const validateFilterState = <TFilter>(data: unknown) => {
  return filterStateSchema<TFilter>().parse(data);
};

export const validateStoreConfig = <TFilter>(data: unknown) => {
  return entityStoreConfigSchema<TFilter>().parse(data);
};
</file>

<file path="store/createStore.ts">
import { create, StateCreator, StoreApi } from 'zustand';
import { devtools, persist, PersistOptions } from 'zustand/middleware';
import { FormMode } from '@/features/core/tanstack-query-api';
import { createActions } from './actions';

import {
  EntityState,
  EntityBaseState,
  EntityStoreConfig,
  PersistedState
} from './core/types';
import {
  validateStoreConfig,
  validateFormState,
  validateTableState,
  validateFilterState,
  validateSelectionState
} from './core/validation';
import {
  DEFAULT_PAGE_SIZE,
  DEFAULT_SEARCH_COLUMN,
  DEFAULT_UPDATE_THRESHOLD,
  DEFAULT_STORE_ID,
  PERSISTED_FIELDS
} from './core/constants';

/**
 * Creates a type-safe entity store with optimized updates and memoization
 */
const createEntityStore = <
  TData extends Record<string, any>,
  TFilter extends Record<string, any>
>(config: Partial<EntityStoreConfig<TFilter>> = {}) => {
  // Set defaults and cast types
  const storeConfig = {
    storeId: config.storeId ?? DEFAULT_STORE_ID,
    defaultPageSize: config.defaultPageSize ?? DEFAULT_PAGE_SIZE,
    defaultSearchColumn: config.defaultSearchColumn ?? DEFAULT_SEARCH_COLUMN,
    defaultFilters: config.defaultFilters as TFilter ?? {} as TFilter,
    persist: config.persist ?? false,
    enableLogging: config.enableLogging ?? false,
    updateThreshold: config.updateThreshold ?? DEFAULT_UPDATE_THRESHOLD
  } as const;

  // Validate configuration
  const validatedConfig = validateStoreConfig(storeConfig);

  // Create initial state
  const initialState: EntityBaseState<TData, TFilter> = {
    // Form state
    isModalOpen: false,
    formMode: 'view' as FormMode,
    selectedItem: null,
    formData: {} as Partial<TData>,
    isSubmitting: false,
    submitError: null,

    // Table state
    items: [] as TData[],
    totalItems: 0,
    totalPages: 0,
    currentPage: 0,
    pageSize: storeConfig.defaultPageSize,
    isLoading: false,
    error: null,

    // Selection state
    selectedItems: [] as TData[],
    selectedIds: [] as string[],

    // Filter state
    filters: storeConfig.defaultFilters,
    columnFilters: [],
    columnVisibility: {},
    globalFilter: '',
    searchQuery: '',
    searchColumn: storeConfig.defaultSearchColumn,
    sorting: [],

    // Update tracking
    lastUpdateTime: Date.now()
  };

  const createBaseStore: StateCreator<
    EntityState<TData, TFilter>,
    [],
    [],
    EntityState<TData, TFilter>
  > = (set, get) => {
    // Create store API for actions
    const storeApi: StoreApi<EntityState<TData, TFilter>> = {
      setState: set,
      getState: get,
      subscribe: (listener) => {
        // Subscribe handled by Zustand
        return () => {};
      },
      getInitialState: () => initialState as EntityState<TData, TFilter>,
    };

    // Create store actions
    const storeActions = createActions(storeApi, storeConfig);

    // Return combined state and actions
    return {
      ...initialState,
      ...storeActions,
    };
  };

  // Add middleware
  if (storeConfig.persist) {
    type StoreType = EntityState<TData, TFilter>;
    type Persisted = PersistedState<TFilter>;

    const persistConfig: PersistOptions<EntityState<TData, TFilter>, PersistedState<TFilter>> = {
      name: `entity-store-${storeConfig.storeId}`,
      partialize: (state) => ({
        pageSize: state.pageSize,
        columnVisibility: state.columnVisibility,
        filters: state.filters,
        sorting: state.sorting
      } as PersistedState<TFilter>)
    };

    return create<StoreType>()(
      devtools(
        persist(createBaseStore, persistConfig)
      )
    );
  }

  return create<EntityState<TData, TFilter>>()(
    devtools(createBaseStore)
  );
};

export default createEntityStore;
</file>

<file path="store/entityStore.ts">
import { create } from 'zustand';
import { devtools, persist } from 'zustand/middleware';
import { FormMode } from '@/features/core/tanstack-query-api';
import { ColumnFiltersState, SortingState, VisibilityState } from '@tanstack/react-table';
import { StoreApi, StateCreator } from 'zustand';

// Separate interfaces for different state slices to prevent circular updates
interface FormState<TData> {
  isModalOpen: boolean;
  formMode: FormMode;
  selectedItem: TData | null;
  formData: Partial<TData>;
  isSubmitting: boolean;
  submitError: string | null;
}

interface TableState<TData> {
  items: TData[];
  totalItems: number;
  totalPages: number;
  currentPage: number;
  pageSize: number;
  isLoading: boolean;
  error: Error | null;
}

interface SelectionState<TData> {
  selectedItems: TData[];
  selectedIds: string[];
}

interface FilterState<TFilter> {
  filters: TFilter;
  columnFilters: ColumnFiltersState;
  columnVisibility: VisibilityState;
  globalFilter: string;
  searchQuery: string;
  searchColumn: string;
  sorting: SortingState;
}

// Entity store state interface with strict typing
export interface EntityState<TData = any, TFilter = any> extends
  FormState<TData>,
  TableState<TData>,
  SelectionState<TData>,
  FilterState<TFilter> {
  // Form actions
  openModal: (mode: FormMode, item?: TData | null) => void;
  closeModal: () => void;
  setFormMode: (mode: FormMode) => void;
  setSelectedItem: (item: TData | null) => void;
  updateFormData: (data: Partial<TData>) => void;
  resetFormData: (defaultValues?: Partial<TData>) => void;
  setSubmitting: (isSubmitting: boolean) => void;
  setSubmitError: (error: string | null) => void;

  // Table actions
  setItems: (items: TData[]) => void;
  setTotalItems: (totalItems: number) => void;
  setTotalPages: (totalPages: number) => void;
  setCurrentPage: (page: number) => void;
  setPageSize: (pageSize: number) => void;
  setLoading: (isLoading: boolean) => void;
  setError: (error: Error | null) => void;

  // Selection actions
  setSelectedItems: (items: TData[]) => void;
  setSelectedIds: (ids: string[]) => void;

  // Filter/Sort actions
  setSorting: (sorting: SortingState) => void;
  setFilters: (filters: Partial<TFilter>) => void;
  setColumnFilters: (filters: ColumnFiltersState) => void;
  setColumnVisibility: (visibility: VisibilityState) => void;
  setGlobalFilter: (filter: string) => void;
  setSearchQuery: (query: string) => void;
  setSearchColumn: (column: string) => void;

  // Reset actions
  resetFilters: () => void;
  resetPagination: () => void;
  resetTable: () => void;
  reset: () => void;
}

type EntityStoreState<TData, TFilter> = Omit<EntityState<TData, TFilter>, keyof {[K in keyof EntityState<TData, TFilter>]: EntityState<TData, TFilter>[K] extends Function ? K : never}[keyof EntityState<TData, TFilter>]>;

type UpdateFunction<T extends Record<string, any>> = (state: T) => Partial<T>;

/**
 * Creates a Zustand store for managing entity state with improved update guards and memoization
 */
export const createEntityStore = <TData extends Record<string, any>, TFilter extends Record<string, any>>(
  storeId = 'entity-store',
  options: {
    defaultPageSize?: number;
    defaultSearchColumn?: string;
    defaultFilters?: TFilter;
    persist?: boolean;
    enableLogging?: boolean;
    updateThreshold?: number;
  } = {}
) => {
  const {
    defaultPageSize = 10,
    defaultSearchColumn = '',
    defaultFilters = {} as TFilter,
    persist: shouldPersist = false,
    enableLogging = false,
    updateThreshold = 100
  } = options;

  // Initial state with update guards
  const initialState: EntityStoreState<TData, TFilter> = {
    // Form state
    isModalOpen: false,
    formMode: 'view' as FormMode,
    selectedItem: null,
    formData: {} as Partial<TData>,
    isSubmitting: false,
    submitError: null,

    // Table state
    items: [],
    totalItems: 0,
    totalPages: 0,
    currentPage: 0,
    pageSize: defaultPageSize,
    isLoading: false,
    error: null,

    // Selection state
    selectedItems: [],
    selectedIds: [],

    // Filter state
    filters: defaultFilters,
    columnFilters: [],
    columnVisibility: {},
    globalFilter: '',
    searchQuery: '',
    searchColumn: defaultSearchColumn,
    sorting: []
  };

  // Store creator with proper types
  const createStore: StateCreator<
    EntityState<TData, TFilter>, 
    [["zustand/devtools", never]], 
    [],
    EntityState<TData, TFilter>
  > = (set, get) => {
    // Memoized update helper with improved batching and debouncing
    const safeUpdate = (
      fn: UpdateFunction<EntityStoreState<TData, TFilter>>,
      actionType: string
    ) => {
      const state = get();
      const now = Date.now();
      const timeSinceLastUpdate = now - (state.lastUpdateTime || 0);
      
      // Prevent rapid successive updates (debounce)
      if (timeSinceLastUpdate < updateThreshold) {
        // For critical operations like modal closing, we don't want to skip the update
        if (actionType !== 'closeModal') {
          console.log(`[EntityStore:${storeId}] Skipping rapid update for ${actionType}`);
          return;
        }
      }
      
      // Get all updates at once to batch them
      const updates = fn(state);
      
      // Skip update if no changes were made
      if (Object.keys(updates).length === 0) {
        console.log(`[EntityStore:${storeId}] No changes in ${actionType}, skipping update`);
        return;
      }
      
      if (enableLogging) {
        console.log(`[EntityStore:${storeId}] ${actionType}:`, updates);
      }

      // Batch update with a timestamp to track update frequency
      set({ ...updates, lastUpdateTime: now }, false, actionType);
    };

    return {
      ...initialState,

      // Form actions
      openModal: (mode: FormMode, item: TData | null = null) => {
        safeUpdate(() => ({
          isModalOpen: true,
          formMode: mode,
          selectedItem: item,
          formData: item || {},
          submitError: null
        }), 'openModal');
      },

      closeModal: () => {
        // Get current state to check if already closed
        const state = get();
        if (!state.isModalOpen) return; // Already closed, no need to update
        
        // Batch all state changes in a single update
        safeUpdate(() => ({
          isModalOpen: false,
          submitError: null,
          selectedItem: null,
          formData: {}
        }), 'closeModal');
      },

      setFormMode: (mode: FormMode) => {
        safeUpdate(() => ({ formMode: mode }), 'setFormMode');
      },

      setSelectedItem: (item: TData | null) => {
        safeUpdate(() => ({
          selectedItem: item,
          formData: item || {}
        }), 'setSelectedItem');
      },

      updateFormData: (data: Partial<TData>) => {
        safeUpdate((state) => {
          const currentFormData = state.formData || {};
          const hasChanges = Object.keys(data).some(key => {
            const k = key as keyof TData;
            return !Object.is(currentFormData[k], data[k]);
          });

          if (!hasChanges) return {};

          return {
            formData: { ...currentFormData, ...data }
          };
        }, 'updateFormData');
      },

      resetFormData: (defaultValues?: Partial<TData>) => {
        safeUpdate(() => ({ 
          formData: defaultValues || {} 
        }), 'resetFormData');
      },

      setSubmitting: (isSubmitting: boolean) => {
        safeUpdate(() => ({ isSubmitting }), 'setSubmitting');
      },

      setSubmitError: (error: string | null) => {
        safeUpdate(() => ({ submitError: error }), 'setSubmitError');
      },

      // Table actions
      setItems: (items: TData[]) => {
        safeUpdate(() => ({ items }), 'setItems');
      },

      setTotalItems: (totalItems: number) => {
        safeUpdate(() => ({ totalItems }), 'setTotalItems');
      },

      setTotalPages: (totalPages: number) => {
        safeUpdate(() => ({ totalPages }), 'setTotalPages');
      },

      setCurrentPage: (page: number) => {
        safeUpdate(() => ({ currentPage: page }), 'setCurrentPage');
      },

      setPageSize: (pageSize: number) => {
        safeUpdate(() => ({
          pageSize,
          currentPage: 0
        }), 'setPageSize');
      },

      setLoading: (isLoading: boolean) => {
        safeUpdate(() => ({ isLoading }), 'setLoading');
      },

      setError: (error: Error | null) => {
        safeUpdate(() => ({ error }), 'setError');
      },

      // Selection actions
      setSelectedItems: (items: TData[]) => {
        safeUpdate(() => ({ selectedItems: items }), 'setSelectedItems');
      },

      setSelectedIds: (ids: string[]) => {
        safeUpdate(() => ({ selectedIds: ids }), 'setSelectedIds');
      },

      // Filter/Sort actions
      setSorting: (sorting: SortingState) => {
        safeUpdate(() => ({ sorting }), 'setSorting');
      },

      setFilters: (filters: Partial<TFilter>) => {
        safeUpdate((state) => ({
          filters: { ...state.filters, ...filters },
          currentPage: 0
        }), 'setFilters');
      },

      setColumnFilters: (filters: ColumnFiltersState) => {
        safeUpdate(() => ({
          columnFilters: filters,
          currentPage: 0
        }), 'setColumnFilters');
      },

      setColumnVisibility: (visibility: VisibilityState) => {
        safeUpdate(() => ({ columnVisibility: visibility }), 'setColumnVisibility');
      },

      setGlobalFilter: (filter: string) => {
        safeUpdate(() => ({
          globalFilter: filter,
          currentPage: 0
        }), 'setGlobalFilter');
      },

      setSearchQuery: (query: string) => {
        safeUpdate(() => ({
          searchQuery: query,
          currentPage: 0
        }), 'setSearchQuery');
      },

      setSearchColumn: (column: string) => {
        safeUpdate(() => ({ searchColumn: column }), 'setSearchColumn');
      },

      // Reset actions
      resetFilters: () => {
        safeUpdate(() => ({
          filters: defaultFilters,
          columnFilters: [],
          globalFilter: '',
          searchQuery: '',
          currentPage: 0
        }), 'resetFilters');
      },

      resetPagination: () => {
        safeUpdate(() => ({
          currentPage: 0,
          pageSize: defaultPageSize
        }), 'resetPagination');
      },

      resetTable: () => {
        safeUpdate(() => ({
          items: [],
          totalItems: 0,
          totalPages: 0,
          currentPage: 0,
          pageSize: defaultPageSize,
          selectedItems: [],
          selectedIds: [],
          sorting: [],
          columnFilters: [],
          columnVisibility: {},
          globalFilter: '',
          searchQuery: '',
          searchColumn: defaultSearchColumn
        }), 'resetTable');
      },

      reset: () => {
        set(initialState, false, 'reset');
      }
    };
  };

  // Create store with persistence and devtools
  if (shouldPersist) {
    return create<EntityState<TData, TFilter>>()(
      persist(
        devtools(
          createStore,
          { name: `EntityStore-${storeId}` }
        ),
        {
          name: `entity-store-${storeId}`,
          partialize: (state) => ({
            pageSize: state.pageSize,
            columnVisibility: state.columnVisibility,
            filters: state.filters,
            sorting: state.sorting,
          }),
        }
      )
    );
  }

  return create<EntityState<TData, TFilter>>()(
    devtools(
      createStore,
      { name: `EntityStore-${storeId}` }
    )
  );
};

// Export type for better TypeScript support
export type EntityStore<TData = any, TFilter = any> = ReturnType<typeof createEntityStore<TData, TFilter>>;

// Type-safe selector creator
export const createSelector = <TData extends Record<string, any>, TFilter extends Record<string, any>, Selected = unknown>(
  selector: (state: EntityState<TData, TFilter>) => Selected
) => selector;

// Common selectors with proper typing
export const createEntitySelectors = <TData extends Record<string, any>, TFilter extends Record<string, any>>(store: EntityStore<TData, TFilter>) => ({
  useFormState: () => store(
    createSelector((s) => ({
      isModalOpen: s.isModalOpen,
      formMode: s.formMode,
      selectedItem: s.selectedItem,
      formData: s.formData,
      isSubmitting: s.isSubmitting,
      submitError: s.submitError
    }))
  ),

  useTableState: () => store(
    createSelector((s) => ({
      items: s.items,
      totalItems: s.totalItems,
      totalPages: s.totalPages,
      currentPage: s.currentPage,
      pageSize: s.pageSize,
      isLoading: s.isLoading,
      error: s.error
    }))
  ),

  useFilterState: () => store(
    createSelector((s) => ({
      filters: s.filters,
      columnFilters: s.columnFilters,
      globalFilter: s.globalFilter,
      searchQuery: s.searchQuery,
      searchColumn: s.searchColumn,
      sorting: s.sorting
    }))
  )
});
</file>

<file path="store/index.ts">
// Export core types and utils
export * from './core/types';
export * from './core/validation';
export * from './core/constants';

// Re-export store creator
export { default as createEntityStore } from './createStore';

// Re-export selectors and utils
export * from './selectors';
export * from './actions';
</file>

<file path="store/selectors.ts">
import { EntityState } from './types';
import { FormMode } from '@/features/core/tanstack-query-api';
import { ColumnFiltersState, SortingState, VisibilityState } from '@tanstack/react-table';

export interface FormStateSelector<TData> {
  isModalOpen: boolean;
  formMode: FormMode;
  selectedItem: TData | null;
  formData: Partial<TData>;
  isSubmitting: boolean;
  submitError: string | null;
}

export interface TableStateSelector<TData> {
  items: TData[];
  totalItems: number;
  totalPages: number;
  currentPage: number;
  pageSize: number;
  isLoading: boolean;
  error: Error | null;
}

export interface SelectionStateSelector<TData> {
  selectedItems: TData[];
  selectedIds: string[];
}

export interface FilterStateSelector<TFilter> {
  filters: TFilter;
  columnFilters: ColumnFiltersState;
  columnVisibility: VisibilityState;
  globalFilter: string;
  searchQuery: string;
  searchColumn: string;
  sorting: SortingState;
}

/**
 * Type-safe selector creator with memoization support
 */
export const createSelectors = <TData extends Record<string, any>, TFilter extends Record<string, any>>() => {
  // Form state selector
  const selectFormState = (state: EntityState<TData, TFilter>): FormStateSelector<TData> => ({
    isModalOpen: state.isModalOpen,
    formMode: state.formMode,
    selectedItem: state.selectedItem,
    formData: state.formData,
    isSubmitting: state.isSubmitting,
    submitError: state.submitError
  });

  // Table state selector
  const selectTableState = (state: EntityState<TData, TFilter>): TableStateSelector<TData> => ({
    items: state.items,
    totalItems: state.totalItems,
    totalPages: state.totalPages,
    currentPage: state.currentPage,
    pageSize: state.pageSize,
    isLoading: state.isLoading,
    error: state.error
  });

  // Selection state selector
  const selectSelectionState = (state: EntityState<TData, TFilter>): SelectionStateSelector<TData> => ({
    selectedItems: state.selectedItems,
    selectedIds: state.selectedIds
  });

  // Filter state selector
  const selectFilterState = (state: EntityState<TData, TFilter>): FilterStateSelector<TFilter> => ({
    filters: state.filters,
    columnFilters: state.columnFilters,
    columnVisibility: state.columnVisibility,
    globalFilter: state.globalFilter,
    searchQuery: state.searchQuery,
    searchColumn: state.searchColumn,
    sorting: state.sorting
  });

  // Individual field selectors for fine-grained updates
  const selectItems = (state: EntityState<TData, TFilter>) => state.items;
  const selectFormData = (state: EntityState<TData, TFilter>) => state.formData;
  const selectSelectedItem = (state: EntityState<TData, TFilter>) => state.selectedItem;
  const selectIsLoading = (state: EntityState<TData, TFilter>) => state.isLoading;
  const selectError = (state: EntityState<TData, TFilter>) => state.error;
  const selectFilters = (state: EntityState<TData, TFilter>) => state.filters;
  const selectSorting = (state: EntityState<TData, TFilter>) => state.sorting;
  const selectPagination = (state: EntityState<TData, TFilter>) => ({
    currentPage: state.currentPage,
    pageSize: state.pageSize,
    totalItems: state.totalItems,
    totalPages: state.totalPages
  });

  return {
    // Slice selectors
    selectFormState,
    selectTableState,
    selectSelectionState,
    selectFilterState,
    
    // Individual field selectors
    selectItems,
    selectFormData,
    selectSelectedItem,
    selectIsLoading,
    selectError,
    selectFilters,
    selectSorting,
    selectPagination,
    
    // Utility selector creator for custom selections
    createCustomSelector: <T>(selector: (state: EntityState<TData, TFilter>) => T) => selector
  };
};
</file>

<file path="store/types.ts">
import { FormMode } from '@/features/core/tanstack-query-api';
import { ColumnFiltersState, SortingState, VisibilityState } from '@tanstack/react-table';

export interface FormState<TData> {
  isModalOpen: boolean;
  formMode: FormMode;
  selectedItem: TData | null;
  formData: Partial<TData>;
  isSubmitting: boolean;
  submitError: string | null;
}

export interface TableState<TData> {
  items: TData[];
  totalItems: number;
  totalPages: number;
  currentPage: number;
  pageSize: number;
  isLoading: boolean;
  error: Error | null;
}

export interface SelectionState<TData> {
  selectedItems: TData[];
  selectedIds: string[];
}

export interface FilterState<TFilter> {
  filters: TFilter;
  columnFilters: ColumnFiltersState;
  columnVisibility: VisibilityState;
  globalFilter: string;
  searchQuery: string;
  searchColumn: string;
  sorting: SortingState;
}

export interface UpdateTracking {
  lastUpdateTime: number;
}

export type EntityBaseState<TData, TFilter> = FormState<TData> & 
  TableState<TData> & 
  SelectionState<TData> & 
  FilterState<TFilter> &
  UpdateTracking;

export interface EntityStoreActions<TData, TFilter> {
  // Form actions
  openModal: (mode: FormMode, item?: TData | null) => void;
  closeModal: () => void;
  setFormMode: (mode: FormMode) => void;
  setSelectedItem: (item: TData | null) => void;
  updateFormData: (data: Partial<TData>) => void;
  resetFormData: (defaultValues?: Partial<TData>) => void;
  setSubmitting: (isSubmitting: boolean) => void;
  setSubmitError: (error: string | null) => void;

  // Table actions
  setItems: (items: TData[]) => void;
  setTotalItems: (totalItems: number) => void;
  setTotalPages: (totalPages: number) => void;
  setCurrentPage: (page: number) => void;
  setPageSize: (pageSize: number) => void;
  setLoading: (isLoading: boolean) => void;
  setError: (error: Error | null) => void;

  // Selection actions
  setSelectedItems: (items: TData[]) => void;
  setSelectedIds: (ids: string[]) => void;

  // Filter/Sort actions
  setSorting: (sorting: SortingState) => void;
  setFilters: (filters: Partial<TFilter>) => void;
  setColumnFilters: (filters: ColumnFiltersState) => void;
  setColumnVisibility: (visibility: VisibilityState) => void;
  setGlobalFilter: (filter: string) => void;
  setSearchQuery: (query: string) => void;
  setSearchColumn: (column: string) => void;

  // Reset actions
  resetFilters: () => void;
  resetPagination: () => void;
  resetTable: () => void;
  reset: () => void;
}

export type EntityState<TData, TFilter> = EntityBaseState<TData, TFilter> & EntityStoreActions<TData, TFilter>;
</file>

<file path="test-utils/test-setup.tsx">
import { vi } from 'vitest';
import React, { ReactElement } from 'react';
import { render, RenderOptions } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import { ThemeProvider } from '@/features/core/theme/ThemeProvider';

// Common test utilities
export const createMockClickHandler = () => vi.fn();

export const setupUserEvent = () => userEvent.setup();

const AllTheProviders = ({ children }: { children: React.ReactNode }) => {
  return (
    <ThemeProvider>
      {children}
    </ThemeProvider>
  );
};

const customRender = (
  ui: ReactElement,
  options?: Omit<RenderOptions, 'wrapper'>,
) => {
  return render(ui, {
    wrapper: AllTheProviders,
    ...options,
  });
};

// Vitest helpers
export * from '@testing-library/react';
export { userEvent };
export { vi };

// Override render method
export { customRender as render };

// Common selectors
export const selectors = {
  button: (name: string) => ({
    get: () => cy.findByRole('button', { name }),
  }),
  spinner: () => cy.findByRole('status'),
} as const;
</file>

<file path="types/data-table.ts">
import { ColumnDef } from "@tanstack/react-table";
import { EntityTableStore } from "../components/data-table/store";

import type { JSX } from "react";

/**
 * Props for the EntityDataTable component - extends the TanStack Table functionality
 */
export interface EntityDataTableProps<TData, TValue> {
  columns: ColumnDef<TData, TValue>[];
  data: TData[];
  actions?: Action<TData>[];
  onExport?: () => void;
  onAdd?: () => void;
  addPermission?: { feature: string; action: string };
  filterableColumns?: FilterableColumn[];
  searchableColumns?: SearchableColumn[];
  enableMultiSelect?: boolean;
  onSelectionChange?: (selectedRows: TData[]) => void;
  defaultPageSize?: number;
  bulkActions?: BulkAction<TData>[];
  enableRowClick?: boolean | ((event: React.MouseEvent<HTMLTableRowElement>) => boolean);
  onRowClick?: (row: TData) => void;
  title?: string;
  description?: string;
  isLoading?: boolean;
  
  // Server-side features
  totalItems?: number;
  pageCount?: number;
  currentPage?: number;
  onPageChange?: (page: number) => void;
  onPageSizeChange?: (pageSize: number) => void;
  onSortingChange?: (columnId: string, direction: 'asc' | 'desc' | undefined) => void;
  onFilterChange?: (columnId: string, value: string) => void;
  onSearchChange?: (columnId: string, value: string) => void;
  
  // Zustand state management (optional)
  store?: EntityTableStore<TData>;
}

/**
 * Action configuration for table rows
 */
export interface Action<TData = any> {
  label: string;
  icon: JSX.Element;
  onClick: (row: TData) => void;
  variant?: "link" | "default" | "destructive" | "outline" | "secondary" | "ghost";
  className?: string;
  tooltip?: string;
  showConfirm?: boolean;
  confirmTitle?: string;
  confirmDescription?: string;
  confirmActionLabel?: string;
  showWhen?: (row: TData) => boolean;
  disabled?: boolean | ((row: TData) => boolean);
  permission?: {
    feature: string;
    action: string;
  };
}

/**
 * Column that can be filtered
 */
export interface FilterableColumn {
  id: string;
  title: string;
  options: {
    label: string;
    value: string;
  }[];
}

/**
 * Column that can be searched
 */
export interface SearchableColumn {
  id: string;
  title: string;
}

/**
 * Bulk action configuration
 */
export interface BulkAction<TData> {
  column: string;
  options: { label: string; value: string }[];
  onUpdate: (selectedRows: TData[], value: string) => Promise<void>;
}

/**
 * Sort information
 */
export interface SortInfo {
  sortBy?: string;
  sortOrder?: 'asc' | 'desc';
}

/**
 * Filter information
 */
export interface FilterInfo {
  [columnId: string]: string | number | boolean | null;
}

/**
 * Pagination information
 */
export interface PaginationInfo {
  currentPage: number;
  pageSize: number;
  totalItems: number;
  totalPages: number;
}

/**
 * DataTable state for managing all table state
 */
export interface DataTableState {
  pagination: PaginationInfo;
  sorting: SortInfo;
  filters: FilterInfo;
  search: { [columnId: string]: string };
  selection: Record<string, boolean>;
}
</file>

<file path="types/entity-form.ts">
import { ReactNode } from 'react';
import { UseFormReturn } from 'react-hook-form';
import { FormMode, UseApiQueryOptions } from '@/features/core/tanstack-query-api';
import { EntityFormStore } from '../components/entity-form/store';

/**
 * Display mode for entity forms
 */
export type DisplayMode = 'dialog' | 'sheet' | 'page';

/**
 * Supported form field types
 */
export type FieldType = 
  | 'text' 
  | 'number' 
  | 'email' 
  | 'password' 
  | 'select' 
  | 'multiselect'
  | 'dependent-select' 
  | 'phone' 
  | 'date' 
  | 'checkbox' 
  | 'switch' 
  | 'textarea'
  | 'custom';

/**
 * Base field configuration
 */
export interface BaseFieldConfig {
  name: string;
  label: string;
  description?: string;
  required?: boolean;
  disabled?: boolean | ((mode: FormMode, data?: any) => boolean);
  hidden?: boolean | ((mode: FormMode, data?: any) => boolean);
  icon?: ReactNode;
  className?: string;
  gridClassName?: string;
  readOnlyFormatter?: (value: any, data?: any) => ReactNode;
}

/**
 * Input field configuration
 */
export interface InputFieldConfig extends BaseFieldConfig {
  type: 'text' | 'number' | 'email' | 'password';
  placeholder?: string;
  validation?: {
    pattern?: {
      value: RegExp;
      message: string;
    };
    min?: number;
    max?: number;
    minLength?: number;
    maxLength?: number;
  };
}

/**
 * SelectFieldConfig for endpoints
 */
export interface SelectEndpointOptions {
  endpoint: string;
  labelKey?: string;
  valueKey?: string;
  queryOptions?: UseApiQueryOptions<any>;
  /**
   * Dependencies for this select field.
   * When specified, the options will be refetched when dependency values change.
   * Typically used for dependent dropdowns (like Country → State → City).
   */
  dependencies?: string | string[] | Record<string, any>;
}

/**
 * Select field configuration
 */
export interface SelectFieldConfig extends BaseFieldConfig {
  type: 'select';
  placeholder?: string;
  options: 
    | { label: string; value: string }[] 
    | ((data?: any) => { label: string; value: string }[])
    | SelectEndpointOptions;
  searchable?: boolean;
  loadOptions?: (searchText: string) => Promise<{ label: string; value: string }[]>;
  
  /**
   * Dependent field configuration.
   * Used to define which fields this select depends on.
   * When those fields change, this field's value will be reset and options refetched.
   * 
   * Example: "callTypeId" or ["stateId", "cityId"]
   */
  dependsOn?: string | string[];
  
  /**
   * When true, the field's value will be automatically cleared when its dependencies change.
   * Default is true for fields with dependsOn specified.
   */
  clearOnDependencyChange?: boolean;
  
  /**
   * Function to fetch options for dependent fields.
   * Receives an object with keys as dependency field names and values as their current values.
   * Example: { callTypeId: "123" } or { stateId: "10", cityId: "20" }
   * 
   * This is an alternative to using options with endpoint for dependent fields.
   */
  fetchOptions?: (dependencyValues: Record<string, any>) => Promise<{ label: string; value: string }[]>;
  
  /**
   * Whether to auto-select the first option when options change and there's only one option.
   * Useful for dependent fields when there's often only one valid option.
   * @default false
   */
  autoSelectSingleOption?: boolean;
  
  /**
   * Custom message to show when no options are available.
   * @default "No options available"
   */
  noOptionsMessage?: string;
  
  /**
   * Custom message to show when dependencies are not selected.
   * @default "Select [dependency] first"
   */
  missingDependenciesMessage?: string;
  
  /**
   * Custom transform function for formatting dependency values before fetching options.
   * Useful when you need to transform values before sending to the API.
   */
  transformDependencyValues?: (dependencies: Record<string, any>) => Record<string, any>;
  
  /**
   * The field that, if this field is dependent on multiple fields, acts as the primary dependency.
   * This is used to determine which API endpoint to use if this field has both dependsOn and options.endpoint.
   */
  primaryDependencyField?: string;
}

/**
 * Multi-select field configuration
 */
export interface MultiSelectFieldConfig extends BaseFieldConfig {
  type: 'multiselect';
  placeholder?: string;
  options: { label: string; value: string }[] | ((data?: any) => { label: string; value: string }[]);
  searchable?: boolean;
  loadOptions?: (searchText: string) => Promise<{ label: string; value: string }[]>;
}

/**
 * Phone field configuration
 */
export interface PhoneFieldConfig extends BaseFieldConfig {
  type: 'phone';
  placeholder?: string;
  defaultCountry?: string;
  copyFromField?: string;
  copyToField?: string;
}

/**
 * Date field configuration
 */
export interface DateFieldConfig extends BaseFieldConfig {
  type: 'date';
  placeholder?: string;
  min?: Date | string;
  max?: Date | string;
  format?: string;
}

/**
 * Checkbox field configuration
 */
export interface CheckboxFieldConfig extends BaseFieldConfig {
  type: 'checkbox';
}

/**
 * Switch field configuration
 */
export interface SwitchFieldConfig extends BaseFieldConfig {
  type: 'switch';
}

/**
 * Textarea field configuration
 */
export interface TextareaFieldConfig extends BaseFieldConfig {
  type: 'textarea';
  placeholder?: string;
  rows?: number;
}

/**
 * Custom field configuration
 */
export interface CustomFieldConfig extends BaseFieldConfig {
  type: 'custom';
  render: (props: {
    field: any;
    fieldState: any;
    formState: any;
    mode: FormMode;
    data?: any;
  }) => ReactNode;
  renderReadOnly?: (value: any, data?: any) => ReactNode;
}

/**
 * Dependent Select field configuration
 */
export interface DependentSelectFieldConfig extends BaseFieldConfig {
  type: 'dependent-select';
  placeholder?: string;
  
  /**
   * The parent field name(s) that this select depends on.
   * Can be a single field name or an array of field names.
   * Example: "callTypeId" or ["stateId", "cityId"]
   */
  dependsOn: string | string[];
  
  /**
   * API endpoint to fetch options when dependencies change.
   * Can be a string template with :param or {param} placeholders that will be
   * replaced with dependency values.
   * Example: "/api/states/:countryId/cities" or "/api/masters/call-type/{callTypeId}/sub-types"
   */
  endpoint?: string;
  
  /**
   * Whether to use path parameters instead of query parameters
   * @default false
   */
  usePathParams?: boolean;
  
  /**
   * Path to extract the array of items from the response
   * Example: 'content', 'data', 'data.items'
   */
  contentPath?: string;
  
  /**
   * Function to fetch options based on parent field values.
   * Receives an object with keys as dependency field names and values as their current values.
   * Example: { callTypeId: "123" } or { stateId: "10", cityId: "20" }
   * Must return a promise resolving to an array of { label: string; value: string } objects.
   */
  fetchOptions?: (dependencyValues: Record<string, any>) => Promise<{ label: string; value: string }[]>;
  
  /**
   * Whether to clear this field's value when dependencies change.
   * @default true
   */
  clearOnDependencyChange?: boolean;
  
  /**
   * Whether to auto-select the first option when options change and there's only one option.
   * @default false
   */
  autoSelectSingleOption?: boolean;
  
  /**
   * Custom message to show when no options are available.
   * @default "No options available"
   */
  noOptionsMessage?: string;
  
  /**
   * Custom message to show when dependencies are not selected.
   * @default "Select [dependency] first"
   */
  missingDependenciesMessage?: string;
  
  /**
   * Custom transform function for formatting the dependency values before fetching.
   * Useful when you need to transform the values before sending to the API.
   */
  transformDependencyValues?: (dependencies: Record<string, any>) => Record<string, any>;
  
  /**
   * Debug mode - logs additional information about the component lifecycle
   */
  debug?: boolean;
}

/**
 * Union type of all field configurations
 */
export type FieldConfig =
  | InputFieldConfig
  | SelectFieldConfig
  | MultiSelectFieldConfig
  | PhoneFieldConfig
  | DateFieldConfig
  | CheckboxFieldConfig
  | SwitchFieldConfig
  | TextareaFieldConfig
  | DependentSelectFieldConfig
  | CustomFieldConfig;

/**
 * Field layout types
 */
export type FieldLayout = 'default' | '2-column' | 'compact';

/**
 * Section configuration for grouping fields
 */
export interface SectionConfig {
  title?: string;
  description?: string;
  icon?: ReactNode;
  fields: FieldConfig[];
  layout?: FieldLayout;
  expandable?: boolean;
  defaultExpanded?: boolean;
  visible?: boolean | ((mode: FormMode, data?: any) => boolean);
}

/**
 * Props for the EntityForm component
 */
export interface EntityFormProps<TData = any> {
  // Modal state
  open: boolean;
  onClose: () => void;
  
  // Display configuration
  displayMode?: DisplayMode;
  
  // Form configuration
  formMode: FormMode;
  onChangeFormMode?: (mode: FormMode) => void;
  title?: string | ((mode: FormMode) => string);
  description?: string | ((mode: FormMode) => string);
  
  // Field configuration
  sections?: SectionConfig[];
  fields?: FieldConfig[];
  layout?: FieldLayout;
  
  // Data and callbacks
  data?: TData;
  onSubmit: (data: any) => void | Promise<void>;
  onDelete?: (data: TData) => void | Promise<void>;
  
  // Permissions
  canEdit?: boolean;
  canDelete?: boolean;
  
  // Form control
  form?: UseFormReturn<any>;
  defaultValues?: any;
  validationSchema?: any;
  
  // UI states
  isSubmitting?: boolean;
  submitError?: string;
  
  // Custom rendering
  renderFooter?: (props: {
    formMode: FormMode;
    isSubmitting: boolean;
    onClose: () => void;
    onEdit?: () => void;
    onSubmit: () => void;
    canEdit: boolean;
    canDelete: boolean;
  }) => ReactNode;
  
  renderHeader?: (props: {
    formMode: FormMode;
    title?: string;
    description?: string;
  }) => ReactNode;
  
  // Zustand state management (optional)
  store?: EntityFormStore<TData>;
}
</file>

<file path="types/entity-form/field-relationships.ts">
import { EntityApiEndpoints } from '@/features/core/tanstack-query-api';

/**
 * Field relationship types for defining dependencies between fields
 */
export enum RelationshipType {
  DEPENDS_ON = 'dependsOn',
  PARENT_OF = 'parentOf',
  FILTER_FOR = 'filterFor',
  FILTERED_BY = 'filteredBy'
}

/**
 * Configuration for dependent relationship between fields
 */
export interface DependentFieldRelationship {
  /**
   * Type of relationship between fields
   */
  type: RelationshipType;
  
  /**
   * Field name(s) that this field depends on
   */
  fields: string | string[];
  
  /**
   * Whether to reset this field's value when dependency changes
   * @default true
   */
  resetOnChange?: boolean;
  
  /**
   * API endpoint to fetch options when dependencies change
   * Can be a string template with :param placeholders that will be
   * replaced with dependency values
   * Example: "/api/states/:countryId/cities"
   */
  optionsEndpoint?: string;
  
  /**
   * EntityApiEndpoints object to use for fetching options
   * This is used with the endpointKey to build the API url
   */
  endpointsConfig?: EntityApiEndpoints;
  
  /**
   * Key from the endpoints object to use
   * For example: "subTypes.list" would translate to
   * endpointsConfig.subTypes.list(dependencyValue)
   */
  endpointKey?: string;
  
  /**
   * Configuration for entity resolution when using entity references
   */
  entityConfig?: {
    /**
     * The name of the entity property to use as the field value
     * @default "id"
     */
    valueProperty?: string;
    
    /**
     * The name of the entity property to display
     * @default "name"
     */
    displayProperty?: string;
  };
  
  /**
   * Function to transform dependency values before building URL or making requests
   */
  transformDependencies?: (dependencies: Record<string, any>) => Record<string, any>;
  
  /**
   * Display configuration
   */
  display?: {
    /**
     * Message to show when dependencies are not selected
     */
    placeholderMessage?: string;
    
    /**
     * Message to show when no options are available
     */
    emptyOptionsMessage?: string;
    
    /**
     * Whether to auto-select a single option
     * @default false
     */
    autoSelectSingleOption?: boolean;
  };
}

/**
 * Extended field config with relationship information
 * To be used in the entity form configuration
 */
export interface FieldRelationships {
  [fieldName: string]: DependentFieldRelationship[];
}
</file>

<file path="types/entity-manager.ts">
import { ColumnDef } from '@tanstack/react-table';
import { ReactNode } from 'react';
import { EntityDataTableProps } from './data-table';
import { EntityFormProps, FieldConfig, SectionConfig, DisplayMode } from './entity-form';
import { EntityApiEndpoints, BaseEntity, FormMode } from '@/features/core/tanstack-query-api';

/**
 * Permission configuration for entity operations
 */
export interface EntityPermissions {
  feature: string;
  view?: string;
  create?: string;
  update?: string;
  delete?: string;
}

/**
 * Configuration for entity labels and messages
 */
export interface EntityLabels {
  entityName: string;
  entityNamePlural: string;
  createTitle?: string;
  editTitle?: string;
  viewTitle?: string;
  createDescription?: string;
  editDescription?: string;
  viewDescription?: string;
  deleteConfirmTitle?: string;
  deleteConfirmDescription?: string;
  noDataMessage?: string;
  loadingMessage?: string;
}

/**
 * Props for the EntityManager component
 */
export interface EntityManagerProps<TData extends BaseEntity = any, TFilter = any> {
  // Core configuration
  endpoints: EntityApiEndpoints;
  permissions?: EntityPermissions;
  labels: EntityLabels;
  
  // Table configuration
  columns: ColumnDef<TData, any>[];
  tableProps?: Partial<EntityDataTableProps<TData, any>>;
  filterableColumns?: EntityDataTableProps<TData, any>['filterableColumns'];
  searchableColumns?: EntityDataTableProps<TData, any>['searchableColumns'];
  
  // Form configuration
  formFields?: FieldConfig[];
  formSections?: SectionConfig[];
  defaultValues?: Partial<TData>;
  transformFormData?: (data: any, mode: FormMode) => any;
  validateFormData?: (data: any, mode: FormMode) => any;
  formProps?: Partial<EntityFormProps<TData>>;
  validationSchema?: any;
  
  // Customization
  renderFilters?: (props: {
    filters: TFilter;
    setFilters: (filters: TFilter) => void;
    resetFilters: () => void;
  }) => ReactNode;
  
  // Events
  onCreated?: (data: TData) => void;
  onUpdated?: (data: TData) => void;
  onDeleted?: (id: string | number) => void;
  onFilterChange?: (filters: TFilter) => void;
  
  // Additional features
  enableExport?: boolean;
  exportData?: (data: TData[]) => void;
  enableRowSelection?: boolean;
  bulkActions?: EntityDataTableProps<TData, any>['bulkActions'];
  enableInlineEdit?: boolean;
  
  // UI behavior
  showDeleteInViewMode?: boolean; // Whether to show delete button in view mode, defaults to false
  formDisplayMode?: DisplayMode; // Display mode for the form, defaults to 'dialog'
  
  // Default pagination
  defaultPageSize?: number;
  defaultFilters?: TFilter;
}

/**
 * Entity operation types
 */
export type EntityOperation = 'view' | 'create' | 'update' | 'delete';

/**
 * Entity manager state interface
 */
export interface EntityManagerState<TData = any, TFilter = any> {
  // Data
  data: TData[];
  selectedItem: TData | null;
  filters: TFilter;
  
  // UI state
  isLoading: boolean;
  isModalOpen: boolean;
  formMode: FormMode;
  currentPage: number;
  pageSize: number;
  totalItems: number;
  totalPages: number;
  sortBy?: string;
  sortOrder?: 'asc' | 'desc';
  
  // Actions
  setFilters: (filters: TFilter) => void;
  resetFilters: () => void;
  setPage: (page: number) => void;
  setPageSize: (size: number) => void;
  setSort: (field: string, order: 'asc' | 'desc') => void;
  selectItem: (item: TData | null) => void;
  openModal: (mode: FormMode, item?: TData | null) => void;
  closeModal: () => void;
  refresh: () => void;
}

// Re-export types from tanstack-query-api for convenience
export type { BaseEntity, FormMode, EntityApiEndpoints };
</file>

<file path="types/index.ts">
export * from './data-table';
export * from './entity-form';
export * from './entity-manager';
export * from './entity-form/field-relationships';
</file>

<file path="utils/dependent-fields/dependentSchemas.ts">
import { z } from 'zod';
import { createDependentFieldSchema, commonSchemas } from '../../validation';

/**
 * Creates a comprehensive schema setup for dependent field relationships
 * 
 * @param parentFieldKey The key of the parent field
 * @param parentFieldSchema The schema for the parent field
 * @param dependentFieldKey The key of the dependent field
 * @param dependentFieldRequired Whether the dependent field is required when the parent has a value
 * @param dependentFieldMessage Custom error message for the dependent field
 * @returns An object schema with proper parent-dependent field relationship
 */
export function createDependentRelationshipSchema(
  parentFieldKey: string,
  parentFieldSchema: z.ZodType,
  dependentFieldKey: string,
  dependentFieldRequired: boolean = false,
  dependentFieldMessage: string = 'This field is required when parent field has a value'
) {
  return z.object({
    [parentFieldKey]: parentFieldSchema,
    [dependentFieldKey]: createDependentFieldSchema(dependentFieldRequired, dependentFieldMessage)
  });
}

/**
 * Creates default values for dependent field relationships with proper null handling
 * 
 * @param parentFieldValue The default value for the parent field (usually empty string or null)
 * @returns An object with default values for both parent and dependent fields
 */
export function createDependentFieldDefaults(parentFieldValue: string | null = '') {
  return {
    // Parent field with provided default value
    parent: parentFieldValue,
    // Dependent field always starts as null (not empty string)
    dependent: null
  };
}

/**
 * Creates a transformation function for dependent field data
 * that properly handles null values
 * 
 * @param parentFieldKey The key of the parent field
 * @param dependentFieldKey The key of the dependent field
 * @param convertToNumber Whether to convert string IDs to numbers
 * @returns A transformer function for form data
 */
export function createDependentFieldTransformer(
  parentFieldKey: string,
  dependentFieldKey: string,
  convertToNumber: boolean = true
) {
  return (data: Record<string, any>) => {
    const transformed = { ...data };
    
    // Handle parent field
    if (convertToNumber && transformed[parentFieldKey] && typeof transformed[parentFieldKey] === 'string') {
      transformed[parentFieldKey] = parseInt(transformed[parentFieldKey], 10);
    }
    
    // Handle dependent field - ensure null if empty or null
    if (transformed[dependentFieldKey] === null || transformed[dependentFieldKey] === '') {
      transformed[dependentFieldKey] = null;
    } else if (convertToNumber && typeof transformed[dependentFieldKey] === 'string') {
      transformed[dependentFieldKey] = parseInt(transformed[dependentFieldKey], 10);
    }
    
    return transformed;
  };
}
</file>

<file path="utils/dependent-fields/index.ts">
export * from './useDependentFields';
export * from './types';
export * from './dependentSchemas';
</file>

<file path="utils/dependent-fields/types.ts">
/**
 * Configuration for dynamic dependency mapping
 */
export interface DependencyParamConfig {
  /**
   * The parent field that the dependent field relies on
   */
  parentField: string;
  
  /**
   * The name of the query parameter to use when making the API request
   * @default same as parentField
   */
  paramName?: string;
  
  /**
   * Optional transform function to modify the dependency value before using it
   */
  transform?: (value: any) => any;
  
  /**
   * Whether this dependency is required for the API call to proceed
   * @default true
   */
  required?: boolean;
}

/**
 * Configuration for creating a fetch function
 */
export interface FetchOptionsConfig {
  /**
   * The API endpoint to fetch options from
   */
  endpoint: string;
  
  /**
   * The parameter in the API response to use as the option label
   * @default 'name'
   */
  labelKey?: string;
  
  /**
   * The parameter in the API response to use as the option value
   * @default 'id'
   */
  valueKey?: string;
  
  /**
   * Path to the array of items in the response
   * Examples: 'content', 'data', 'data.items'
   */
  contentPath?: string;
  
  /**
   * Dependency mapping configuration
   * 
   * Can be:
   * - A simple string (the parent field name)
   * - An array of strings (multiple parent field names)
   * - A Record object mapping parameter names to field names
   * - An array of DependencyParamConfig objects for complex mapping
   */
  dependencies?: string | string[] | Record<string, string> | DependencyParamConfig[];
  
  /**
   * Whether to include the dependency values as path parameters instead of query parameters
   * @default false
   */
  usePathParams?: boolean;
  
  /**
   * Additional static query parameters to include in every request
   */
  staticParams?: Record<string, any>;
  
  /**
   * Function to transform the entire dependency object before creating the request
   */
  transformDependencies?: (dependencies: Record<string, any>) => Record<string, any>;
  
  /**
   * Stale time for React Query caching (in milliseconds)
   * @default 5 minutes (5 * 60 * 1000)
   */
  staleTime?: number;
  
  /**
   * Cache time for React Query caching (in milliseconds)
   * @default 10 minutes (10 * 60 * 1000)
   */
  cacheTime?: number;
  
  /**
   * Query key prefix for React Query caching
   * @default dependent-[endpoint]
   */
  queryKeyPrefix?: string;
}

/**
 * Standard option format used throughout the application
 */
export interface OptionItem {
  /**
   * Display label for the option
   */
  label: string;
  
  /**
   * Value used when the option is selected
   */
  value: string;
  
  /**
   * Optional additional data associated with the option
   */
  data?: any;
  
  /**
   * Whether the option is disabled
   */
  disabled?: boolean;
  
  /**
   * Group that the option belongs to (for grouped selects)
   */
  group?: string;
  
  /**
   * Any additional properties
   */
  [key: string]: any;
}

/**
 * Function type for fetching dependent options
 */
export type FetchOptionsFunction = (dependencyValues: Record<string, any>) => Promise<OptionItem[]>;

/**
 * Hook result for useDependentFields
 */
export interface UseDependentFieldsResult {
  /**
   * Fetch options for a dependent select field
   * 
   * @param config Configuration for the fetch operation
   * @param dependencies Values of the dependency fields
   * @returns An array of options in { label, value } format
   */
  fetchOptions: (config: FetchOptionsConfig, dependencyValues: Record<string, any>) => Promise<OptionItem[]>;
  
  /**
   * Create a fetch function for a specific endpoint configuration
   * 
   * @param config The endpoint configuration or a simple endpoint string
   * @returns A function that takes dependencies and returns options
   */
  createFetchFunction: (config: string | FetchOptionsConfig) => FetchOptionsFunction;
  
  /**
   * Prefetch options for a dependent field to improve UI responsiveness
   * 
   * @param config The endpoint configuration
   * @param dependencies The dependency values
   * @param queryKey The query key to use for caching
   */
  prefetchOptions: (config: FetchOptionsConfig, dependencies: Record<string, any>, queryKey: unknown[]) => void;
  
  /**
   * Process dependencies based on various input formats
   * 
   * @param dependencies The dependency configuration
   * @param dependencyValues The current values of all fields
   * @returns Processed dependency object ready for API request
   */
  processDependencies: (
    dependencyConfig: FetchOptionsConfig['dependencies'], 
    dependencyValues: Record<string, any>
  ) => Record<string, any>;
}
</file>

<file path="utils/dependent-fields/useDependentFields.ts">
import { useCallback } from 'react';
import { useQueryClient } from '@tanstack/react-query';
import { apiClient } from '@/features/core/tanstack-query-api/core/apiClient';
import { 
  DependencyParamConfig, 
  FetchOptionsConfig, 
  OptionItem, 
  UseDependentFieldsResult 
} from './types';

/**
 * Hook for fetching dependent field options across the application
 * 
 * This hook provides a standardized way to handle dependent select fields
 * like Call Type → Sub Call Type, Country → State → City, etc.
 * 
 * Features:
 * - Efficient caching with React Query
 * - Support for path parameters and query parameters
 * - Flexible dependency configuration
 * - Prefetching support
 * - Proper error handling
 * 
 * @returns Functions for handling dependent field operations
 */
export function useDependentFields(): UseDependentFieldsResult {
  const queryClient = useQueryClient();
  
  /**
   * Process dependencies based on various input formats
   * 
   * @param dependencyConfig The dependency configuration
   * @param dependencyValues The current values of all fields
   * @returns Processed dependency object ready for API request
   */
  const processDependencies = useCallback(
    (dependencyConfig: FetchOptionsConfig['dependencies'], dependencyValues: Record<string, any>) => {
      // Initialize an empty dependency object
      const result: Record<string, any> = {};
      
      if (!dependencyConfig) {
        return result;
      }
      
      // Handle string (single dependency)
      if (typeof dependencyConfig === 'string') {
        const fieldName = dependencyConfig;
        result[fieldName] = dependencyValues[fieldName];
        return result;
      }
      
      // Handle string array (multiple dependencies with same param names)
      if (Array.isArray(dependencyConfig) && dependencyConfig.length > 0 && typeof dependencyConfig[0] === 'string') {
        for (const fieldName of dependencyConfig as string[]) {
          result[fieldName] = dependencyValues[fieldName];
        }
        return result;
      }
      
      // Handle record object (mapping from param names to field names)
      if (!Array.isArray(dependencyConfig) && typeof dependencyConfig === 'object') {
        for (const [paramName, fieldName] of Object.entries(dependencyConfig)) {
          result[paramName] = dependencyValues[fieldName as string];
        }
        return result;
      }
      
      // Handle array of DependencyParamConfig (most flexible)
      if (Array.isArray(dependencyConfig) && dependencyConfig.length > 0 && typeof dependencyConfig[0] === 'object') {
        for (const config of dependencyConfig as DependencyParamConfig[]) {
          const { parentField, paramName = parentField, transform } = config;
          const value = dependencyValues[parentField];
          
          if (transform) {
            result[paramName] = transform(value);
          } else {
            result[paramName] = value;
          }
        }
        return result;
      }
      
      return result;
    },
    []
  );
  
  /**
   * Fetch options for a dependent select field
   * 
   * @param config Configuration for the fetch operation
   * @param dependencyValues Values of the dependency fields
   * @returns An array of options in { label, value } format
   */
  const fetchOptions = useCallback(
    async (config: FetchOptionsConfig, dependencyValues: Record<string, any>): Promise<OptionItem[]> => {
      const {
        endpoint,
        labelKey = 'name',
        valueKey = 'id',
        dependencies,
        usePathParams = false,
        staticParams = {},
        transformDependencies,
      } = config;
      
      try {
        // Process dependencies based on configuration
        const processedDeps = processDependencies(dependencies, dependencyValues);
        
        // Apply custom transformation if provided
        const finalDependencies = transformDependencies ? transformDependencies(processedDeps) : processedDeps;
        
        // Filter out empty dependency values
        const validDependencies = Object.entries(finalDependencies)
          .filter(([_, value]) => value !== undefined && value !== null && value !== '')
          .reduce((acc, [key, value]) => {
            acc[key] = value;
            return acc;
          }, {} as Record<string, any>);
        
        // Add static parameters
        Object.entries(staticParams).forEach(([key, value]) => {
          if (value !== undefined && value !== null && value !== '') {
            validDependencies[key] = value;
          }
        });
        
        // Check if we have any dependencies to process
        const hasDependencies = Object.keys(validDependencies).length > 0;
        
        // Don't fetch if required dependencies are missing
        if (!hasDependencies) {
          return [];
        }
        
        let url = endpoint;
        
        // Apply path parameters if configured
        if (usePathParams) {
          // Replace path parameters in URL template
          // Example: /api/masters/{stateId}/cities
          for (const [key, value] of Object.entries(validDependencies)) {
            const placeholder = `{${key}}`;
            if (url.includes(placeholder)) {
              url = url.replace(placeholder, encodeURIComponent(String(value)));
              // Remove used parameters so they're not added as query params
              delete validDependencies[key];
            }
          }
        }
        
        // Construct query parameters from remaining dependencies
        const queryParams = new URLSearchParams();
        Object.entries(validDependencies).forEach(([key, value]) => {
          queryParams.append(key, String(value));
        });
        
        const queryString = queryParams.toString();
        const finalUrl = queryString ? `${url}?${queryString}` : url;
        
        // Make the API request using the same apiClient
        const response = await apiClient.get(finalUrl);
        
        if (!response || !response.data) {
          console.error(`Failed to fetch options from ${finalUrl}: Empty response`);
          return [];
        }
        
        // Get the data from the response
        const data = response.data;
        
        // Handle different response formats
        let items: any[] = [];
        
        // If contentPath is specified, use it to extract data
        if (config.contentPath && typeof config.contentPath === 'string') {
          try {
            // Handle nested paths like 'data.items'
            const paths = config.contentPath.split('.');
            let result = data;
            
            for (const path of paths) {
              if (result && result[path]) {
                result = result[path];
              } else {
                result = null;
                break;
              }
            }
            
            if (Array.isArray(result)) {
              items = result;
            }
          } catch (error) {
            console.error(`Error accessing contentPath:`, error);
          }
        }
        // Otherwise try common patterns
        else if (Array.isArray(data)) {
          items = data;
        } else if (data?.content && Array.isArray(data.content)) {
          items = data.content;
        } else if (data?.data && Array.isArray(data.data)) {
          items = data.data;
        } else if (data?.items && Array.isArray(data.items)) {
          items = data.items;
        } else if (data?.results && Array.isArray(data.results)) {
          items = data.results;
        } else if (data?.page?.content && Array.isArray(data.page.content)) {
          items = data.page.content;
        }
        
        // Map items to the required format
        return items.map(item => ({
          label: item[labelKey] || item.name || item.label || String(item[valueKey] || item.id),
          value: String(item[valueKey] || item.id || item.value),
          data: item // Store the original item data for reference
        }));
      } catch (error) {
        console.error(`Error fetching options from ${endpoint}:`, error);
        return [];
      }
    },
    [processDependencies]
  );
  
  /**
   * Create a fetch function for a specific endpoint configuration
   * 
   * @param config The endpoint configuration or a simple endpoint string
   * @returns A function that takes dependencies and returns options
   */
  const createFetchFunction = useCallback(
    (config: string | FetchOptionsConfig) => {
      // Handle string shorthand (just the endpoint)
      const fullConfig = typeof config === 'string' ? { endpoint: config } : config;
      
      return async (dependencies: Record<string, any>): Promise<OptionItem[]> => {
        return await fetchOptions(fullConfig, dependencies);
      };
    },
    [fetchOptions]
  );
  
  /**
   * Prefetch options for a dependent field
   * 
   * @param config The endpoint configuration
   * @param dependencies The dependency values
   * @param queryKey The query key to use for caching
   */
  const prefetchOptions = useCallback(
    (config: FetchOptionsConfig, dependencies: Record<string, any>, queryKey: unknown[]) => {
      const { staleTime = 5 * 60 * 1000 } = config; // Default 5 minutes
      
      queryClient.prefetchQuery({
        queryKey,
        queryFn: () => fetchOptions(config, dependencies),
        staleTime,
      });
    },
    [queryClient, fetchOptions]
  );
  
  return {
    fetchOptions,
    createFetchFunction,
    prefetchOptions,
    processDependencies,
  };
}

/**
 * Helper functions for common dependent dropdown relationships
 * These functions create standard fetch functions for common entity relationships
 */
export const createCommonDependentFetchFunctions = () => {
  const { createFetchFunction } = useDependentFields();
  
  return {
    /**
     * Get the fetch function for sub call types based on call type
     * 
     * @returns A function that fetches sub call types based on call type ID
     */
    subCallTypes: () => 
      createFetchFunction({
        endpoint: '/api/masters/call-type/{callTypeId}/sub-types',
        labelKey: 'name',
        valueKey: 'id',
        usePathParams: true, // Use path parameters instead of query string
        dependencies: {
          callTypeId: 'callTypeId',
        },
        contentPath: 'content', // For paginated responses
        queryKeyPrefix: 'subCallTypes',
      }),
    
    /**
     * Get the fetch function for cities based on state
     * 
     * @returns A function that fetches cities based on state ID
     */
    cities: () => 
      createFetchFunction({
        endpoint: '/api/masters/city',
        labelKey: 'name',
        valueKey: 'id',
        dependencies: 'stateId',
        queryKeyPrefix: 'cities',
      }),
    
    /**
     * Get the fetch function for areas based on city
     * 
     * @returns A function that fetches areas based on city ID
     */
    areas: () => 
      createFetchFunction({
        endpoint: '/api/masters/area',
        labelKey: 'name',
        valueKey: 'id',
        dependencies: 'cityId',
        queryKeyPrefix: 'areas',
      }),
  };
};

/**
 * Create a generic fetch function for any entity
 * 
 * @param endpoint The API endpoint
 * @param dependencyField The field to use as a dependency
 * @param paramName The parameter name to use in the API request (defaults to dependencyField)
 * @returns A function that fetches dependent options
 */
export function createDependentFetchFunction(
  endpoint: string,
  dependencyField: string,
  paramName?: string
) {
  const { createFetchFunction } = useDependentFields();
  
  return createFetchFunction({
    endpoint,
    labelKey: 'name',
    valueKey: 'id',
    dependencies: {
      [paramName || dependencyField]: dependencyField,
    },
    queryKeyPrefix: `dependent-${endpoint}-${dependencyField}`,
  });
}
</file>

<file path="utils/field-relationships.ts">
import { 
  DependentFieldRelationship, 
  FieldRelationships, 
  RelationshipType 
} from '../types/entity-form/field-relationships';
import { SelectFieldConfig } from '../types/entity-form';
import { EntityApiEndpoints } from '@/features/core/tanstack-query-api';

/**
 * Create a dependent field relationship configuration
 * 
 * @param dependentField Field that depends on other fields
 * @param parentFields Fields that the dependent field depends on
 * @param options Additional options for the relationship
 * @returns A field relationship configuration object
 */
export function createDependentFieldRelationship(
  dependentField: string,
  parentFields: string | string[],
  options?: {
    resetOnChange?: boolean;
    optionsEndpoint?: string;
    endpointsConfig?: EntityApiEndpoints;
    endpointKey?: string;
    entityConfig?: {
      valueProperty?: string;
      displayProperty?: string;
    };
    transformDependencies?: (dependencies: Record<string, any>) => Record<string, any>;
    display?: {
      placeholderMessage?: string;
      emptyOptionsMessage?: string;
      autoSelectSingleOption?: boolean;
    };
  }
): FieldRelationships {
  const relationship: DependentFieldRelationship = {
    type: RelationshipType.DEPENDS_ON,
    fields: parentFields,
    resetOnChange: options?.resetOnChange,
    optionsEndpoint: options?.optionsEndpoint,
    endpointsConfig: options?.endpointsConfig,
    endpointKey: options?.endpointKey,
    entityConfig: options?.entityConfig,
    transformDependencies: options?.transformDependencies,
    display: options?.display,
  };
  
  return {
    [dependentField]: [relationship]
  };
}

/**
 * Extract field relationships from field configurations
 * 
 * @param fields Array of field configs
 * @returns Field relationships configuration
 */
export function extractFieldRelationships(
  fields: Array<SelectFieldConfig | any>
): FieldRelationships {
  const relationships: FieldRelationships = {};
  
  fields.forEach(field => {
    if (field.type === 'select' && field.dependsOn) {
      // Process select fields with dependencies
      const relationship: DependentFieldRelationship = {
        type: RelationshipType.DEPENDS_ON,
        fields: field.dependsOn,
        resetOnChange: field.clearOnDependencyChange !== false,
        entityConfig: {
          valueProperty: 'value',
          displayProperty: 'label',
        },
        display: {
          placeholderMessage: field.missingDependenciesMessage,
          emptyOptionsMessage: field.noOptionsMessage,
          autoSelectSingleOption: field.autoSelectSingleOption,
        },
        transformDependencies: field.transformDependencyValues,
      };
      
      // Process endpoint config
      if (typeof field.options === 'object' && 'endpoint' in field.options) {
        relationship.optionsEndpoint = field.options.endpoint;
      }
      
      relationships[field.name] = [relationship];
    }
  });
  
  return relationships;
}

/**
 * Register dependent field relationships in the entity form
 * 
 * This is a convenience function to create a field relationships
 * configuration for use with the entity form
 * 
 * @param config Array of dependency configurations
 * @returns Field relationships configuration
 */
export function registerDependentFields(config: Array<{
  field: string;
  dependsOn: string | string[];
  endpoint?: string;
  endpointsConfig?: EntityApiEndpoints;
  endpointKey?: string;
  resetOnChange?: boolean;
  autoSelectSingleOption?: boolean;
  placeholderMessage?: string;
  emptyOptionsMessage?: string;
  transformDependencies?: (dependencies: Record<string, any>) => Record<string, any>;
}>): FieldRelationships {
  const relationships: FieldRelationships = {};
  
  config.forEach(item => {
    const relationship: DependentFieldRelationship = {
      type: RelationshipType.DEPENDS_ON,
      fields: item.dependsOn,
      resetOnChange: item.resetOnChange !== false,
      optionsEndpoint: item.endpoint,
      endpointsConfig: item.endpointsConfig,
      endpointKey: item.endpointKey,
      display: {
        placeholderMessage: item.placeholderMessage,
        emptyOptionsMessage: item.emptyOptionsMessage,
        autoSelectSingleOption: item.autoSelectSingleOption,
      },
      transformDependencies: item.transformDependencies,
    };
    
    relationships[item.field] = [relationship];
  });
  
  return relationships;
}
</file>

<file path="utils/fieldValidation.ts">
/**
 * Utility functions for field validation
 */

// Cache to prevent redundant validation
const validationCache = new WeakMap();
let lastValueStringified = '';

/**
 * Checks if a field value should be considered filled
 * 
 * @param value Any value to check
 * @param fieldName Optional field name for additional context
 * @returns boolean indicating if the field is considered filled
 */
export function hasValidValue(value: any, fieldName?: string): boolean {
  // Handle special cases for certain field names
  if (fieldName) {
    // Only log in development or when debugging is needed
    if (process.env.NODE_ENV === 'development' && process.env.DEBUG_VALIDATION) {
      console.log(`[ValidationUtil] Checking field ${fieldName} with value:`, value, 'type:', typeof value);
    }
  }

  // Undefined or null values are always empty
  if (value === undefined || value === null) {
    if (fieldName && process.env.DEBUG_VALIDATION) console.log(`[ValidationUtil] ${fieldName}: false - undefined/null`);
    return false;
  }
  
  // Empty strings or whitespace-only strings are empty
  if (typeof value === 'string' && value.trim() === '') {
    if (fieldName && process.env.DEBUG_VALIDATION) console.log(`[ValidationUtil] ${fieldName}: false - empty string`);
    return false;
  }
  
  // NaN is considered empty
  if (typeof value === 'number' && isNaN(value)) {
    if (fieldName && process.env.DEBUG_VALIDATION) console.log(`[ValidationUtil] ${fieldName}: false - NaN`);
    return false;
  }
  
  // Special case: 0 is a valid value for numbers
  if (typeof value === 'number') {
    if (fieldName && process.env.DEBUG_VALIDATION) console.log(`[ValidationUtil] ${fieldName}: true - number ${value}`);
    return true;
  }
  
  // Empty arrays are considered empty
  if (Array.isArray(value) && value.length === 0) {
    if (fieldName && process.env.DEBUG_VALIDATION) console.log(`[ValidationUtil] ${fieldName}: false - empty array`);
    return false;
  }
  
  // For objects, check if it has any properties
  if (typeof value === 'object' && !Array.isArray(value) && Object.keys(value).length === 0) {
    if (fieldName && process.env.DEBUG_VALIDATION) console.log(`[ValidationUtil] ${fieldName}: false - empty object`);
    return false;
  }
  
  // All other values are considered filled
  if (fieldName && process.env.DEBUG_VALIDATION) console.log(`[ValidationUtil] ${fieldName}: true - has value`);
  return true;
}

/**
 * Returns a deeply cloned copy of form values to prevent cross-references
 * Uses caching to prevent redundant processing of the same values
 * 
 * @param values Form values object
 * @returns Deep clone of form values
 */
export function isolateFormValues(values: Record<string, any>): Record<string, any> {
  // Skip validation if values haven't changed to prevent infinite loops
  try {
    // Create a simple hash of the values for comparison
    const valueStringified = JSON.stringify(values);
    
    // If the values haven't changed, return the cached result
    if (valueStringified === lastValueStringified && validationCache.has(values)) {
      return validationCache.get(values);
    }
    
    // Only log in development environment
    if (process.env.NODE_ENV === 'development' && process.env.DEBUG_VALIDATION) {
      console.log('[ValidationUtil] Isolating form values', values);
    }
    
    // Create a completely new object with no references to the original
    const clean: Record<string, any> = {};
    
    // Iterate through each key and explicitly create new values
    for (const key in values) {
      if (Object.prototype.hasOwnProperty.call(values, key)) {
        const value = values[key];
        
        // Handle different value types appropriately
        if (value === null || value === undefined) {
          clean[key] = value;
        } else if (typeof value === 'string' || typeof value === 'number' || typeof value === 'boolean') {
          // For primitive types, direct assignment is fine
          clean[key] = value;
        } else if (typeof value === 'object') {
          // For objects (including arrays), do a deep clone
          try {
            clean[key] = JSON.parse(JSON.stringify(value));
          } catch (e) {
            // Fallback for circular references or other JSON errors
            clean[key] = value;
          }
        }
      }
    }
    
    // Store in cache for future use
    lastValueStringified = valueStringified;
    validationCache.set(values, clean);
    
    if (process.env.NODE_ENV === 'development' && process.env.DEBUG_VALIDATION) {
      console.log('[ValidationUtil] Isolated values:', clean);
    }
    
    return clean;
  } catch (error) {
    console.error('[ValidationUtil] Error isolating form values:', error);
    // Create a completely fresh object as a fallback
    const fallback: Record<string, any> = {};
    
    for (const key in values) {
      if (Object.prototype.hasOwnProperty.call(values, key)) {
        fallback[key] = values[key];
      }
    }
    
    return fallback;
  }
}

/**
 * Verifies if a required field is properly filled
 * 
 * @param values Form values
 * @param fieldName Field name to check
 * @returns boolean indicating if the field is properly filled
 */
export function isRequiredFieldFilled(values: Record<string, any>, fieldName: string): boolean {
  // Get the exact field value by name to prevent cross-field contamination
  const value = values[fieldName];
  // Use the validation function to check if it's filled
  return hasValidValue(value, fieldName);
}

/**
 * Gets a specific field value from form values
 * 
 * @param values Form values
 * @param fieldName Field name to get
 * @returns The field value
 */
export function getFieldValue(values: Record<string, any>, fieldName: string): any {
  return values[fieldName];
}
</file>

<file path="utils/formTransformations.ts">
import { FormMode } from '../types';

/**
 * Interface for a form transformation function
 */
export interface FormTransformer<T = any> {
  /**
   * Transform form values before submission
   * @param data The form data to transform
   * @param mode The current form mode (view, create, edit)
   * @returns The transformed data
   */
  transformFormData: (data: any, mode: FormMode) => T;
  
  /**
   * Transform API data for display in the form
   * @param data The API data to transform for form display
   * @param mode The current form mode (view, create, edit)
   * @returns The transformed data for the form
   */
  transformApiData?: (data: T, mode: FormMode) => any;
  
  /**
   * Validate form data before submission
   * @param data The form data to validate
   * @param mode The current form mode (view, create, edit)
   * @returns void if valid, throws an error if invalid
   */
  validateFormData?: (data: any, mode: FormMode) => void;
}

/**
 * Transform a JS Date object to an ISO string (or keep string as-is)
 */
export const transformDateFields = (
  data: any,
  dateFields: string[]
): any => {
  const transformedData = { ...data };
  
  dateFields.forEach((field) => {
    if (transformedData[field] instanceof Date) {
      transformedData[field] = transformedData[field].toISOString();
    }
  });
  
  return transformedData;
};

/**
 * Transform nested objects into a flattened format for API submission
 */
export const flattenNestedFields = (
  data: any,
  nestedFields: Record<string, string>
): any => {
  const transformedData = { ...data };
  
  Object.entries(nestedFields).forEach(([nestedField, targetField]) => {
    if (transformedData[nestedField]) {
      const value = 
        typeof transformedData[nestedField] === 'object' && 'id' in transformedData[nestedField]
          ? transformedData[nestedField].id
          : transformedData[nestedField];
      
      transformedData[targetField] = value;
      delete transformedData[nestedField];
    }
  });
  
  return transformedData;
};

/**
 * Transform array fields for API submission
 */
export const transformArrayFields = (
  data: any,
  arrayFields: Record<string, { idField: string; targetField?: string }>
): any => {
  const transformedData = { ...data };
  
  Object.entries(arrayFields).forEach(([arrayField, config]) => {
    if (Array.isArray(transformedData[arrayField])) {
      const targetField = config.targetField || arrayField;
      
      // Extract IDs if objects, or use values directly if primitives
      const transformedArray = transformedData[arrayField].map((item) => {
        if (typeof item === 'object' && item !== null && config.idField in item) {
          return item[config.idField];
        }
        return item;
      });
      
      if (targetField !== arrayField) {
        transformedData[targetField] = transformedArray;
        delete transformedData[arrayField];
      } else {
        transformedData[arrayField] = transformedArray;
      }
    }
  });
  
  return transformedData;
};

/**
 * Remove null/undefined fields from an object
 */
export const removeEmptyFields = (
  data: any,
  fieldsToCheck?: string[]
): any => {
  const transformedData = { ...data };
  
  Object.keys(transformedData).forEach((key) => {
    if (
      (!fieldsToCheck || fieldsToCheck.includes(key)) &&
      (transformedData[key] === null || transformedData[key] === undefined)
    ) {
      delete transformedData[key];
    }
  });
  
  return transformedData;
};

/**
 * Transform boolean fields from string values
 */
export const transformBooleanFields = (
  data: any,
  booleanFields: string[]
): any => {
  const transformedData = { ...data };
  
  booleanFields.forEach((field) => {
    if (field in transformedData) {
      // Handle string representations of booleans
      if (transformedData[field] === 'true') {
        transformedData[field] = true;
      } else if (transformedData[field] === 'false') {
        transformedData[field] = false;
      }
    }
  });
  
  return transformedData;
};

/**
 * Compose multiple transformation functions together
 */
export const composeTransformers = (
  ...transformers: ((data: any, mode: FormMode) => any)[]
) => {
  return (data: any, mode: FormMode) => {
    return transformers.reduce((result, transformer) => {
      return transformer(result, mode);
    }, data);
  };
};

/**
 * Create a form transformer from a transformation function
 */
export const createFormTransformer = <T = any>(
  transformFormData: (data: any, mode: FormMode) => T,
  transformApiData?: (data: T, mode: FormMode) => any,
  validateFormData?: (data: any, mode: FormMode) => void
): FormTransformer<T> => {
  return {
    transformFormData,
    transformApiData,
    validateFormData,
  };
};
</file>

<file path="utils/index.ts">
export * from './formTransformations';
export * from './logger';
export * from './dependent-fields';
export * from './responsive';
</file>

<file path="utils/logger.ts">
/**
 * Logging levels for the entity-management framework
 */
export enum LogLevel {
  DEBUG = 'debug',
  INFO = 'info',
  WARN = 'warn',
  ERROR = 'error'
}

/**
 * Configuration options for the logger
 */
export interface LoggerOptions {
  enabled: boolean;
  level: LogLevel;
  prefix?: string;
  includeTimestamp?: boolean;
  includeContext?: boolean;
}

/**
 * Default logger configuration
 */
const DEFAULT_OPTIONS: LoggerOptions = {
  enabled: process.env.NODE_ENV !== 'production',
  level: LogLevel.INFO,
  prefix: '[EntityMgmt]',
  includeTimestamp: true,
  includeContext: true
};

/**
 * Logger class for entity-management framework
 * Provides structured logging with different levels, context, and formatting
 */
export class Logger {
  private options: LoggerOptions;

  constructor(options: Partial<LoggerOptions> = {}) {
    this.options = { ...DEFAULT_OPTIONS, ...options };
  }

  /**
   * Helper to format log messages
   */
  private formatMessage(level: LogLevel, message: string, context?: string): string {
    const parts: string[] = [];

    if (this.options.includeTimestamp) {
      parts.push(`[${new Date().toISOString()}]`);
    }

    if (this.options.prefix) {
      parts.push(this.options.prefix);
    }

    parts.push(`[${level.toUpperCase()}]`);

    if (this.options.includeContext && context) {
      parts.push(`[${context}]`);
    }

    parts.push(message);

    return parts.join(' ');
  }

  /**
   * Check if this log level should be shown based on configuration
   */
  private shouldLog(level: LogLevel): boolean {
    if (!this.options.enabled) {
      return false;
    }

    const levels = [LogLevel.DEBUG, LogLevel.INFO, LogLevel.WARN, LogLevel.ERROR];
    const configLevelIndex = levels.indexOf(this.options.level);
    const messageLevelIndex = levels.indexOf(level);

    return messageLevelIndex >= configLevelIndex;
  }

  /**
   * Log a debug message
   */
  debug(message: string, context?: string, ...args: any[]): void {
    if (this.shouldLog(LogLevel.DEBUG)) {
      console.debug(this.formatMessage(LogLevel.DEBUG, message, context), ...args);
    }
  }

  /**
   * Log an info message
   */
  info(message: string, context?: string, ...args: any[]): void {
    if (this.shouldLog(LogLevel.INFO)) {
      console.info(this.formatMessage(LogLevel.INFO, message, context), ...args);
    }
  }

  /**
   * Log a warning message
   */
  warn(message: string, context?: string, ...args: any[]): void {
    if (this.shouldLog(LogLevel.WARN)) {
      console.warn(this.formatMessage(LogLevel.WARN, message, context), ...args);
    }
  }

  /**
   * Log an error message
   */
  error(message: string | Error, context?: string, ...args: any[]): void {
    if (this.shouldLog(LogLevel.ERROR)) {
      const errorMessage = message instanceof Error ? message.message : message;
      console.error(this.formatMessage(LogLevel.ERROR, errorMessage, context), ...args);
      
      if (message instanceof Error) {
        console.error(message.stack);
      }
    }
  }

  /**
   * Create a child logger with a specific context
   */
  createContext(context: string): Logger {
    return new Logger({
      ...this.options,
      prefix: this.options.prefix ? `${this.options.prefix}:${context}` : context
    });
  }

  /**
   * Create a logger instance configured for a specific feature
   */
  static forFeature(featureName: string): Logger {
    return new Logger({
      prefix: `[EntityMgmt:${featureName}]`
    });
  }

  /**
   * Create a logger instance configured for a specific component
   */
  static forComponent(componentName: string): Logger {
    return new Logger({
      prefix: `[EntityMgmt:Component:${componentName}]`
    });
  }
}

// Export a default logger instance
export const logger = new Logger();

export default logger;
</file>

<file path="utils/responsive.ts">
/**
 * Responsive utility functions and classes for entity management
 * Provides consistent responsive behavior across components
 */

/**
 * Custom breakpoint constants for consistent usage
 */
export const BREAKPOINTS = {
  xs: 480,
  sm: 640,
  md: 768,
  lg: 1024,
  xl: 1280,
  xxl: 1536,
};

/**
 * Responsive CSS class map
 * Provides consistent responsive classes for different screen sizes
 */
export const RESPONSIVE_CLASSES = {
  // Container classes
  container: {
    base: "w-full px-4",
    sm: "sm:px-6",
    lg: "lg:px-8 lg:max-w-7xl lg:mx-auto",
  },
  
  // Card classes
  card: {
    base: "bg-white dark:bg-gray-900 rounded-lg border border-gray-200 dark:border-gray-800 overflow-hidden",
    sm: "sm:rounded-xl",
  },
  
  // Grid classes
  grid: {
    // One column on mobile, two on tablet and up
    "1-2": "grid grid-cols-1 sm:grid-cols-2 gap-4 sm:gap-6",
    
    // One column on mobile, three on desktop and up
    "1-3": "grid grid-cols-1 md:grid-cols-3 gap-4 sm:gap-6",
    
    // One column mobile, two columns tablet, four columns desktop
    "1-2-4": "grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-4 gap-4 sm:gap-6",
  },
  
  // Spacing classes
  spacing: {
    section: "my-4 sm:my-6 lg:my-8",
    betweenSections: "mb-4 sm:mb-6 lg:mb-8",
  },
  
  // Table classes
  table: {
    container: "overflow-x-auto",
    wrapper: "min-w-full align-middle",
  },
  
  // Form classes
  form: {
    field: "mb-4",
    fieldGroup: "grid grid-cols-1 sm:grid-cols-2 gap-4 mb-4",
  },
  
  // Dialog/Modal classes
  dialog: {
    content: "w-[95vw] sm:w-auto sm:max-w-lg md:max-w-xl lg:max-w-2xl p-0",
    maxHeight: "max-h-[85vh] sm:max-h-[80vh]",
  },
  
  // Button classes
  buttons: {
    group: "flex flex-col-reverse sm:flex-row gap-2 sm:gap-3",
    mobileFullWidth: "w-full sm:w-auto",
  },
};

/**
 * Returns true if the current viewport width is below the specified breakpoint
 * @param breakpoint Breakpoint to check against (xs, sm, md, lg, xl)
 * @returns True if viewport width is below the breakpoint
 */
export const isBelowBreakpoint = (breakpoint: keyof typeof BREAKPOINTS): boolean => {
  if (typeof window === 'undefined') return false;
  return window.innerWidth < BREAKPOINTS[breakpoint];
};

/**
 * Returns true if the current viewport width is above the specified breakpoint
 * @param breakpoint Breakpoint to check against (xs, sm, md, lg, xl)
 * @returns True if viewport width is above the breakpoint
 */
export const isAboveBreakpoint = (breakpoint: keyof typeof BREAKPOINTS): boolean => {
  if (typeof window === 'undefined') return true;
  return window.innerWidth >= BREAKPOINTS[breakpoint];
};

/**
 * Get responsive classes for a specific component type
 * @param componentType Type of component (container, card, grid, etc.)
 * @param variant Specific variant of the component
 * @returns String of CSS classes
 */
export const getResponsiveClasses = (
  componentType: keyof typeof RESPONSIVE_CLASSES,
  variant?: string
): string => {
  const classes = RESPONSIVE_CLASSES[componentType];
  
  if (!classes) {
    return '';
  }
  
  if (variant && classes[variant as keyof typeof classes]) {
    return classes[variant as keyof typeof classes] as string;
  }
  
  // If no variant is specified or variant doesn't exist, return base classes
  if (typeof classes === 'object' && 'base' in classes) {
    return Object.values(classes).join(' ');
  }
  
  return '';
};
</file>

<file path="validation/ErrorDisplay.tsx">
import React from 'react';
import {
  Alert,
  AlertDescription,
  AlertTitle,
} from '@/components/ui/alert';
import { XCircle, AlertCircle, Info } from 'lucide-react';
import { Button } from '@/components/ui/button';
import { cn } from '@/lib/utils';

/**
 * Type definition for an API error
 */
export interface ApiError {
  /**
   * Error message
   */
  message: string;
  
  /**
   * Error code
   */
  code?: string;
  
  /**
   * HTTP status code
   */
  status?: number;
  
  /**
   * Field-specific errors
   */
  fieldErrors?: Record<string, string>;
  
  /**
   * Raw error response
   */
  raw?: any;
}

/**
 * Props for the ErrorDisplay component
 */
export interface ErrorDisplayProps {
  /**
   * Error object or message
   */
  error: ApiError | string;
  
  /**
   * Error title
   */
  title?: string;
  
  /**
   * Show retry button
   */
  showRetry?: boolean;
  
  /**
   * Show stack trace
   */
  showStackTrace?: boolean;
  
  /**
   * Retry handler
   */
  onRetry?: () => void;
  
  /**
   * Dismiss handler
   */
  onDismiss?: () => void;
  
  /**
   * Additional className
   */
  className?: string;
  
  /**
   * Whether to show field errors
   */
  showFieldErrors?: boolean;
}

/**
 * Component to display API errors
 */
export function ErrorDisplay({
  error,
  title = 'Error',
  showRetry = false,
  showStackTrace = false,
  onRetry,
  onDismiss,
  className,
  showFieldErrors = false,
}: ErrorDisplayProps) {
  // Parse the error
  const errorObj = typeof error === 'string' ? { message: error } : error;
  
  // Get field errors
  const fieldErrors = errorObj.fieldErrors || {};
  
  // Get error severity based on status code
  const getSeverity = () => {
    if (!errorObj.status) return 'error';
    
    if (errorObj.status >= 500) return 'error'; // Server errors
    if (errorObj.status >= 400) return 'warning'; // Client errors
    return 'info'; // Informational
  };
  
  const severity = getSeverity();
  
  // Get icon based on severity
  const getIcon = () => {
    switch (severity) {
      case 'error':
        return <XCircle className="h-5 w-5" />;
      case 'warning':
        return <AlertCircle className="h-5 w-5" />;
      case 'info':
        return <Info className="h-5 w-5" />;
      default:
        return <AlertCircle className="h-5 w-5" />;
    }
  };
  
  return (
    <Alert 
      variant={severity === 'error' ? 'destructive' : 'default'}
      className={cn('relative', className)}
    >
      <div className="flex items-start">
        <div className="flex-shrink-0 mt-0.5">
          {getIcon()}
        </div>
        <div className="ml-3 flex-grow">
          <AlertTitle className="text-base font-medium">
            {title}
          </AlertTitle>
          <AlertDescription className="text-sm">
            {errorObj.message}
            
            {/* Field errors */}
            {showFieldErrors && Object.keys(fieldErrors).length > 0 && (
              <ul className="mt-2 text-sm space-y-1">
                {Object.entries(fieldErrors).map(([field, message]) => (
                  <li key={field} className="flex items-start">
                    <span className="font-medium mr-1">{field}:</span> {message}
                  </li>
                ))}
              </ul>
            )}
            
            {/* Stack trace */}
            {showStackTrace && errorObj.raw?.stack && (
              <pre className="mt-2 text-xs overflow-auto p-2 bg-muted rounded-md max-h-32">
                {errorObj.raw.stack}
              </pre>
            )}
          </AlertDescription>
          
          {/* Action buttons */}
          {(showRetry || onDismiss) && (
            <div className="mt-3 flex justify-end space-x-2">
              {onDismiss && (
                <Button
                  variant="outline"
                  size="sm"
                  onClick={onDismiss}
                >
                  Dismiss
                </Button>
              )}
              
              {showRetry && onRetry && (
                <Button
                  variant="default"
                  size="sm"
                  onClick={onRetry}
                >
                  Retry
                </Button>
              )}
            </div>
          )}
        </div>
      </div>
    </Alert>
  );
}
</file>

<file path="validation/index.ts">
export * from './validationSchemas';
export * from './ValidationContext';
export * from './ErrorDisplay';
// ErrorBoundary is now imported from components
</file>

<file path="validation/ValidationContext.tsx">
import React, { createContext, useContext, useState, useCallback, useMemo } from 'react';
import { z } from 'zod';
import { zodErrorToObject } from './validationSchemas';
import { logger } from '../utils/logger';

/**
 * Interface for the validation context
 * Provides form validation functionality with error handling
 */
interface ValidationContextType {
  /**
   * Errors record
   */
  errors: Record<string, string>;
  
  /**
   * Set a single error
   */
  setError: (field: string, message: string) => void;
  
  /**
   * Set multiple errors
   */
  setErrors: (errors: Record<string, string>) => void;
  
  /**
   * Clear a single error
   */
  clearError: (field: string) => void;
  
  /**
   * Clear all errors
   */
  clearErrors: () => void;
  
  /**
   * Check if a field has an error
   */
  hasError: (field: string) => boolean;
  
  /**
   * Get the error message for a field
   */
  getError: (field: string) => string | undefined;
  
  /**
   * Validate values against a schema
   */
  validate: <T>(values: T, schema: z.ZodType<T>) => boolean;
  
  /**
   * Validate a single field
   */
  validateField: <T>(
    field: string,
    value: any,
    schema: z.ZodType<T>
  ) => boolean;
  
  /**
   * Get error severity based on error type
   */
  getErrorSeverity: (field: string) => 'error' | 'warning' | 'info';

  /**
   * Set field validation status
   */
  setFieldStatus: (field: string, status: 'valid' | 'invalid' | 'pending') => void;

  /**
   * Get field validation status
   */
  getFieldStatus: (field: string) => 'valid' | 'invalid' | 'pending' | undefined;
}

// Create the context
const ValidationContext = createContext<ValidationContextType>({
  errors: {},
  setError: () => {},
  setErrors: () => {},
  clearError: () => {},
  clearErrors: () => {},
  hasError: () => false,
  getError: () => undefined,
  validate: () => true,
  validateField: () => true,
  getErrorSeverity: () => 'error',
  setFieldStatus: () => {},
  getFieldStatus: () => undefined,
});

/**
 * Provider for the validation context
 */
interface ValidationProviderProps {
  children: React.ReactNode;
  context?: string;
}

export function ValidationProvider({ 
  children,
  context = 'validation' 
}: ValidationProviderProps) {
  const [errors, setErrorsState] = useState<Record<string, string>>({});
  const [fieldStatus, setFieldStatusState] = useState<Record<string, 'valid' | 'invalid' | 'pending'>>({});
  
  // Create a logger for this validation context
  const validationLogger = useMemo(() => 
    logger.createContext(`ValidationContext:${context}`), 
  [context]);
  
  // Set a single error
  const setError = useCallback((field: string, message: string) => {
    validationLogger.debug(`Setting error for field: ${field}`, 'setError', { message });
    setErrorsState(prev => ({
      ...prev,
      [field]: message,
    }));
    setFieldStatusState(prev => ({
      ...prev,
      [field]: 'invalid'
    }));
  }, [validationLogger]);
  
  // Set multiple errors
  const setErrors = useCallback((newErrors: Record<string, string>) => {
    validationLogger.debug('Setting multiple errors', 'setErrors', { errorCount: Object.keys(newErrors).length });
    setErrorsState(newErrors);
    
    // Update status for all error fields
    const newStatus: Record<string, 'invalid'> = {};
    Object.keys(newErrors).forEach(field => {
      newStatus[field] = 'invalid';
    });
    
    setFieldStatusState(prev => ({
      ...prev,
      ...newStatus
    }));
  }, [validationLogger]);
  
  // Clear a single error
  const clearError = useCallback((field: string) => {
    validationLogger.debug(`Clearing error for field: ${field}`, 'clearError');
    setErrorsState(prev => {
      const updated = { ...prev };
      delete updated[field];
      return updated;
    });
    
    setFieldStatusState(prev => {
      const updated = { ...prev };
      if (updated[field] === 'invalid') {
        updated[field] = 'valid';
      }
      return updated;
    });
  }, [validationLogger]);
  
  // Clear all errors
  const clearErrors = useCallback(() => {
    validationLogger.debug('Clearing all errors', 'clearErrors');
    setErrorsState({});
    
    // Update status for all fields with errors
    setFieldStatusState(prev => {
      const updated = { ...prev };
      Object.keys(errors).forEach(field => {
        if (updated[field] === 'invalid') {
          updated[field] = 'valid';
        }
      });
      return updated;
    });
  }, [errors, validationLogger]);
  
  // Check if a field has an error
  const hasError = useCallback(
    (field: string) => {
      return field in errors;
    },
    [errors]
  );
  
  // Get the error message for a field
  const getError = useCallback(
    (field: string) => {
      return errors[field];
    },
    [errors]
  );
  
  // Set field validation status
  const setFieldStatus = useCallback((field: string, status: 'valid' | 'invalid' | 'pending') => {
    validationLogger.debug(`Setting field status: ${field} -> ${status}`, 'setFieldStatus');
    setFieldStatusState(prev => ({
      ...prev,
      [field]: status
    }));
  }, [validationLogger]);
  
  // Get field validation status
  const getFieldStatus = useCallback((field: string) => {
    return fieldStatus[field];
  }, [fieldStatus]);
  
  // Get error severity based on error type
  const getErrorSeverity = useCallback((field: string): 'error' | 'warning' | 'info' => {
    // You can implement custom logic here based on field type or error content
    return 'error';
  }, []);
  
  // Validate values against a schema
  const validate = useCallback(<T,>(values: T, schema: z.ZodType<T>) => {
    validationLogger.debug('Validating schema', 'validate', { values });
    try {
      schema.parse(values);
      clearErrors();
      return true;
    } catch (error) {
      if (error instanceof z.ZodError) {
        const errorObj = zodErrorToObject(error);
        validationLogger.warn('Validation failed', 'validate', { errors: errorObj });
        setErrors(errorObj);
      } else {
        validationLogger.error('Unexpected validation error', 'validate', { error });
      }
      return false;
    }
  }, [setErrors, clearErrors, validationLogger]);
  
  // Validate a single field
  const validateField = useCallback(
    <T,>(field: string, value: any, schema: z.ZodType<T>) => {
      validationLogger.debug(`Validating field: ${field}`, 'validateField', { value });
      setFieldStatus(field, 'pending');
      
      try {
        const obj = { [field]: value } as any;
        schema.parse(obj);
        clearError(field);
        setFieldStatus(field, 'valid');
        return true;
      } catch (error) {
        if (error instanceof z.ZodError) {
          const errors = zodErrorToObject(error);
          if (field in errors) {
            validationLogger.debug(`Field validation failed: ${field}`, 'validateField', { error: errors[field] });
            setError(field, errors[field]);
          }
          setFieldStatus(field, 'invalid');
        } else {
          validationLogger.error(`Unexpected field validation error: ${field}`, 'validateField', { error });
        }
        return false;
      }
    },
    [clearError, setError, setFieldStatus, validationLogger]
  );
  
  // Memoize the context value to prevent unnecessary re-renders
  const value = useMemo(() => ({
    errors,
    setError,
    setErrors,
    clearError,
    clearErrors,
    hasError,
    getError,
    validate,
    validateField,
    getErrorSeverity,
    setFieldStatus,
    getFieldStatus,
  }), [
    errors,
    setError,
    setErrors,
    clearError,
    clearErrors,
    hasError,
    getError,
    validate,
    validateField,
    getErrorSeverity,
    setFieldStatus,
    getFieldStatus,
  ]);
  
  return (
    <ValidationContext.Provider value={value}>
      {children}
    </ValidationContext.Provider>
  );
}

/**
 * Hook to use validation in components
 */
export function useValidation() {
  return useContext(ValidationContext);
}

/**
 * HOC to provide validation to a component
 */
export function withValidation<P extends object>(
  Component: React.ComponentType<P>,
  options: {
    context?: string;
  } = {}
) {
  const { context } = options;
  
  return function WithValidationComponent(props: P) {
    return (
      <ValidationProvider context={context}>
        <Component {...props} />
      </ValidationProvider>
    );
  };
}
</file>

<file path="validation/validationSchemas.ts">
import { z } from 'zod';

/**
 * Common validation schemas used throughout the application
 */
export const commonSchemas = {
  id: z.string().or(z.number()).nullable(),
  name: z.string().min(1, 'Name is required'),
  code: z.string().min(1, 'Code is required'),
  description: z.string().nullable().optional(),
  isActive: z.boolean().default(true),
  date: z.date().or(z.string().regex(/^\d{4}-\d{2}-\d{2}/).transform((val) => new Date(val))).nullable().optional(),
  email: z.string().email('Invalid email address').nullable().optional(),
  phone: z.string().regex(/^[0-9+\-\s()]*$/, 'Invalid phone number').nullable().optional(),
  required: z.string().min(1, 'This field is required'),
  optionalText: z.string().nullable().optional(),
  optionalNumber: z.number().nullable().optional(),
  optionalBoolean: z.boolean().nullable().optional(),
  // Add more common schemas as needed
};

/**
 * Creates a schema for dependent fields
 * 
 * @param isRequired Whether the field is required when parent field has a value
 * @param message Custom error message
 * @returns A schema with conditional validation based on parent field
 */
export function createDependentFieldSchema(
  isRequired: boolean = false,
  message: string = 'This field is required when parent field has a value'
) {
  // If the field is not required, just return a nullable/optional schema
  if (!isRequired) {
    return z.string().nullable().optional();
  }
  
  // If required, we need to conditionally validate based on parent field
  return z.string().nullable().refine(
    (val, ctx) => {
      // If parent field exists (will be available in ctx.parent)
      const parentField = Object.values(ctx.parent)[0];
      
      // If parent has value, this field is required
      if (parentField && (parentField !== '' && parentField !== null)) {
        return val !== null && val !== '';
      }
      
      // Otherwise, it's optional
      return true;
    },
    {
      message,
    }
  );
}

// Add more validation utility functions as needed
</file>

</files>
