/**
 * Generated by orval v7.8.0 üç∫
 * Do not edit manually.
 * Crm Backend API
 * Crm Backend API documentation
 * OpenAPI spec version: 0.0.1
 */
import { useInfiniteQuery, useMutation, useQuery } from '@tanstack/react-query';
import type {
  MutationFunction,
  QueryFunction,
  QueryKey,
  UseInfiniteQueryOptions,
  UseInfiniteQueryResult,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult,
} from '@tanstack/react-query';

import type {
  CountPrioritiesParams,
  GetAllPrioritiesParams,
  PriorityDTO,
  SearchPrioritiesParams,
} from '../../schemas';

import { customFetch } from '../../../client/fetch-client';

type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];

export const getPriority = (
  id: number,
  options?: SecondParameter<typeof customFetch>,
  signal?: AbortSignal
) => {
  return customFetch<PriorityDTO>({ url: `/api/priorities/${id}`, method: 'GET', signal }, options);
};

export const getGetPriorityQueryKey = (id: number) => {
  return [`/api/priorities/${id}`] as const;
};

export const getGetPriorityInfiniteQueryOptions = <
  TData = Awaited<ReturnType<typeof getPriority>>,
  TError = unknown,
>(
  id: number,
  options?: {
    query?: UseInfiniteQueryOptions<Awaited<ReturnType<typeof getPriority>>, TError, TData>;
    request?: SecondParameter<typeof customFetch>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetPriorityQueryKey(id);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getPriority>>> = ({ signal }) =>
    getPriority(id, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    staleTime: 10000,
    ...queryOptions,
  } as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getPriority>>, TError, TData> & {
    queryKey: QueryKey;
  };
};

export type GetPriorityInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getPriority>>>;
export type GetPriorityInfiniteQueryError = unknown;

export function useGetPriorityInfinite<
  TData = Awaited<ReturnType<typeof getPriority>>,
  TError = unknown,
>(
  id: number,
  options?: {
    query?: UseInfiniteQueryOptions<Awaited<ReturnType<typeof getPriority>>, TError, TData>;
    request?: SecondParameter<typeof customFetch>;
  }
): UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetPriorityInfiniteQueryOptions(id, options);

  const query = useInfiniteQuery(queryOptions) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGetPriorityQueryOptions = <
  TData = Awaited<ReturnType<typeof getPriority>>,
  TError = unknown,
>(
  id: number,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof getPriority>>, TError, TData>;
    request?: SecondParameter<typeof customFetch>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetPriorityQueryKey(id);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getPriority>>> = ({ signal }) =>
    getPriority(id, requestOptions, signal);

  return { queryKey, queryFn, enabled: !!id, staleTime: 10000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getPriority>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetPriorityQueryResult = NonNullable<Awaited<ReturnType<typeof getPriority>>>;
export type GetPriorityQueryError = unknown;

export function useGetPriority<TData = Awaited<ReturnType<typeof getPriority>>, TError = unknown>(
  id: number,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof getPriority>>, TError, TData>;
    request?: SecondParameter<typeof customFetch>;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetPriorityQueryOptions(id, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const updatePriority = (
  id: number,
  priorityDTO: PriorityDTO,
  options?: SecondParameter<typeof customFetch>
) => {
  return customFetch<PriorityDTO>(
    {
      url: `/api/priorities/${id}`,
      method: 'PUT',
      headers: { 'Content-Type': 'application/json' },
      data: priorityDTO,
    },
    options
  );
};

export const getUpdatePriorityMutationOptions = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updatePriority>>,
    TError,
    { id: number; data: PriorityDTO },
    TContext
  >;
  request?: SecondParameter<typeof customFetch>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof updatePriority>>,
  TError,
  { id: number; data: PriorityDTO },
  TContext
> => {
  const mutationKey = ['updatePriority'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updatePriority>>,
    { id: number; data: PriorityDTO }
  > = props => {
    const { id, data } = props ?? {};

    return updatePriority(id, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdatePriorityMutationResult = NonNullable<Awaited<ReturnType<typeof updatePriority>>>;
export type UpdatePriorityMutationBody = PriorityDTO;
export type UpdatePriorityMutationError = unknown;

export const useUpdatePriority = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updatePriority>>,
    TError,
    { id: number; data: PriorityDTO },
    TContext
  >;
  request?: SecondParameter<typeof customFetch>;
}): UseMutationResult<
  Awaited<ReturnType<typeof updatePriority>>,
  TError,
  { id: number; data: PriorityDTO },
  TContext
> => {
  const mutationOptions = getUpdatePriorityMutationOptions(options);

  return useMutation(mutationOptions);
};
export const deletePriority = (id: number, options?: SecondParameter<typeof customFetch>) => {
  return customFetch<void>({ url: `/api/priorities/${id}`, method: 'DELETE' }, options);
};

export const getDeletePriorityMutationOptions = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deletePriority>>,
    TError,
    { id: number },
    TContext
  >;
  request?: SecondParameter<typeof customFetch>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof deletePriority>>,
  TError,
  { id: number },
  TContext
> => {
  const mutationKey = ['deletePriority'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deletePriority>>,
    { id: number }
  > = props => {
    const { id } = props ?? {};

    return deletePriority(id, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type DeletePriorityMutationResult = NonNullable<Awaited<ReturnType<typeof deletePriority>>>;

export type DeletePriorityMutationError = unknown;

export const useDeletePriority = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deletePriority>>,
    TError,
    { id: number },
    TContext
  >;
  request?: SecondParameter<typeof customFetch>;
}): UseMutationResult<
  Awaited<ReturnType<typeof deletePriority>>,
  TError,
  { id: number },
  TContext
> => {
  const mutationOptions = getDeletePriorityMutationOptions(options);

  return useMutation(mutationOptions);
};
export const partialUpdatePriority = (
  id: number,
  priorityDTO: PriorityDTO,
  options?: SecondParameter<typeof customFetch>
) => {
  return customFetch<PriorityDTO>(
    {
      url: `/api/priorities/${id}`,
      method: 'PATCH',
      headers: { 'Content-Type': 'application/json' },
      data: priorityDTO,
    },
    options
  );
};

export const getPartialUpdatePriorityMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof partialUpdatePriority>>,
    TError,
    { id: number; data: PriorityDTO },
    TContext
  >;
  request?: SecondParameter<typeof customFetch>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof partialUpdatePriority>>,
  TError,
  { id: number; data: PriorityDTO },
  TContext
> => {
  const mutationKey = ['partialUpdatePriority'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof partialUpdatePriority>>,
    { id: number; data: PriorityDTO }
  > = props => {
    const { id, data } = props ?? {};

    return partialUpdatePriority(id, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PartialUpdatePriorityMutationResult = NonNullable<
  Awaited<ReturnType<typeof partialUpdatePriority>>
>;
export type PartialUpdatePriorityMutationBody = PriorityDTO;
export type PartialUpdatePriorityMutationError = unknown;

export const usePartialUpdatePriority = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof partialUpdatePriority>>,
    TError,
    { id: number; data: PriorityDTO },
    TContext
  >;
  request?: SecondParameter<typeof customFetch>;
}): UseMutationResult<
  Awaited<ReturnType<typeof partialUpdatePriority>>,
  TError,
  { id: number; data: PriorityDTO },
  TContext
> => {
  const mutationOptions = getPartialUpdatePriorityMutationOptions(options);

  return useMutation(mutationOptions);
};
export const getAllPriorities = (
  params?: GetAllPrioritiesParams,
  options?: SecondParameter<typeof customFetch>,
  signal?: AbortSignal
) => {
  return customFetch<PriorityDTO[]>(
    { url: `/api/priorities`, method: 'GET', params, signal },
    options
  );
};

export const getGetAllPrioritiesQueryKey = (params?: GetAllPrioritiesParams) => {
  return [`/api/priorities`, ...(params ? [params] : [])] as const;
};

export const getGetAllPrioritiesInfiniteQueryOptions = <
  TData = Awaited<ReturnType<typeof getAllPriorities>>,
  TError = unknown,
>(
  params?: GetAllPrioritiesParams,
  options?: {
    query?: UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAllPriorities>>, TError, TData>;
    request?: SecondParameter<typeof customFetch>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetAllPrioritiesQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getAllPriorities>>> = ({
    signal,
    pageParam,
  }) =>
    getAllPriorities({ ...params, page: pageParam || params?.['page'] }, requestOptions, signal);

  return { queryKey, queryFn, staleTime: 10000, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof getAllPriorities>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetAllPrioritiesInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof getAllPriorities>>
>;
export type GetAllPrioritiesInfiniteQueryError = unknown;

export function useGetAllPrioritiesInfinite<
  TData = Awaited<ReturnType<typeof getAllPriorities>>,
  TError = unknown,
>(
  params?: GetAllPrioritiesParams,
  options?: {
    query?: UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAllPriorities>>, TError, TData>;
    request?: SecondParameter<typeof customFetch>;
  }
): UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetAllPrioritiesInfiniteQueryOptions(params, options);

  const query = useInfiniteQuery(queryOptions) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGetAllPrioritiesQueryOptions = <
  TData = Awaited<ReturnType<typeof getAllPriorities>>,
  TError = unknown,
>(
  params?: GetAllPrioritiesParams,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof getAllPriorities>>, TError, TData>;
    request?: SecondParameter<typeof customFetch>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetAllPrioritiesQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getAllPriorities>>> = ({ signal }) =>
    getAllPriorities(params, requestOptions, signal);

  return { queryKey, queryFn, staleTime: 10000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getAllPriorities>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetAllPrioritiesQueryResult = NonNullable<Awaited<ReturnType<typeof getAllPriorities>>>;
export type GetAllPrioritiesQueryError = unknown;

export function useGetAllPriorities<
  TData = Awaited<ReturnType<typeof getAllPriorities>>,
  TError = unknown,
>(
  params?: GetAllPrioritiesParams,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof getAllPriorities>>, TError, TData>;
    request?: SecondParameter<typeof customFetch>;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetAllPrioritiesQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const createPriority = (
  priorityDTO: PriorityDTO,
  options?: SecondParameter<typeof customFetch>,
  signal?: AbortSignal
) => {
  return customFetch<PriorityDTO>(
    {
      url: `/api/priorities`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: priorityDTO,
      signal,
    },
    options
  );
};

export const getCreatePriorityMutationOptions = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createPriority>>,
    TError,
    { data: PriorityDTO },
    TContext
  >;
  request?: SecondParameter<typeof customFetch>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createPriority>>,
  TError,
  { data: PriorityDTO },
  TContext
> => {
  const mutationKey = ['createPriority'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createPriority>>,
    { data: PriorityDTO }
  > = props => {
    const { data } = props ?? {};

    return createPriority(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreatePriorityMutationResult = NonNullable<Awaited<ReturnType<typeof createPriority>>>;
export type CreatePriorityMutationBody = PriorityDTO;
export type CreatePriorityMutationError = unknown;

export const useCreatePriority = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createPriority>>,
    TError,
    { data: PriorityDTO },
    TContext
  >;
  request?: SecondParameter<typeof customFetch>;
}): UseMutationResult<
  Awaited<ReturnType<typeof createPriority>>,
  TError,
  { data: PriorityDTO },
  TContext
> => {
  const mutationOptions = getCreatePriorityMutationOptions(options);

  return useMutation(mutationOptions);
};
export const countPriorities = (
  params?: CountPrioritiesParams,
  options?: SecondParameter<typeof customFetch>,
  signal?: AbortSignal
) => {
  return customFetch<number>(
    { url: `/api/priorities/count`, method: 'GET', params, signal },
    options
  );
};

export const getCountPrioritiesQueryKey = (params?: CountPrioritiesParams) => {
  return [`/api/priorities/count`, ...(params ? [params] : [])] as const;
};

export const getCountPrioritiesInfiniteQueryOptions = <
  TData = Awaited<ReturnType<typeof countPriorities>>,
  TError = unknown,
>(
  params?: CountPrioritiesParams,
  options?: {
    query?: UseInfiniteQueryOptions<Awaited<ReturnType<typeof countPriorities>>, TError, TData>;
    request?: SecondParameter<typeof customFetch>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getCountPrioritiesQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof countPriorities>>> = ({
    signal,
    pageParam,
  }) => countPriorities({ ...params, page: pageParam || params?.['page'] }, requestOptions, signal);

  return { queryKey, queryFn, staleTime: 10000, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof countPriorities>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type CountPrioritiesInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof countPriorities>>
>;
export type CountPrioritiesInfiniteQueryError = unknown;

export function useCountPrioritiesInfinite<
  TData = Awaited<ReturnType<typeof countPriorities>>,
  TError = unknown,
>(
  params?: CountPrioritiesParams,
  options?: {
    query?: UseInfiniteQueryOptions<Awaited<ReturnType<typeof countPriorities>>, TError, TData>;
    request?: SecondParameter<typeof customFetch>;
  }
): UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getCountPrioritiesInfiniteQueryOptions(params, options);

  const query = useInfiniteQuery(queryOptions) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getCountPrioritiesQueryOptions = <
  TData = Awaited<ReturnType<typeof countPriorities>>,
  TError = unknown,
>(
  params?: CountPrioritiesParams,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof countPriorities>>, TError, TData>;
    request?: SecondParameter<typeof customFetch>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getCountPrioritiesQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof countPriorities>>> = ({ signal }) =>
    countPriorities(params, requestOptions, signal);

  return { queryKey, queryFn, staleTime: 10000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof countPriorities>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type CountPrioritiesQueryResult = NonNullable<Awaited<ReturnType<typeof countPriorities>>>;
export type CountPrioritiesQueryError = unknown;

export function useCountPriorities<
  TData = Awaited<ReturnType<typeof countPriorities>>,
  TError = unknown,
>(
  params?: CountPrioritiesParams,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof countPriorities>>, TError, TData>;
    request?: SecondParameter<typeof customFetch>;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getCountPrioritiesQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const searchPriorities = (
  params: SearchPrioritiesParams,
  options?: SecondParameter<typeof customFetch>,
  signal?: AbortSignal
) => {
  return customFetch<PriorityDTO[]>(
    { url: `/api/priorities/_search`, method: 'GET', params, signal },
    options
  );
};

export const getSearchPrioritiesQueryKey = (params: SearchPrioritiesParams) => {
  return [`/api/priorities/_search`, ...(params ? [params] : [])] as const;
};

export const getSearchPrioritiesInfiniteQueryOptions = <
  TData = Awaited<ReturnType<typeof searchPriorities>>,
  TError = unknown,
>(
  params: SearchPrioritiesParams,
  options?: {
    query?: UseInfiniteQueryOptions<Awaited<ReturnType<typeof searchPriorities>>, TError, TData>;
    request?: SecondParameter<typeof customFetch>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getSearchPrioritiesQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof searchPriorities>>> = ({
    signal,
    pageParam,
  }) =>
    searchPriorities({ ...params, page: pageParam || params?.['page'] }, requestOptions, signal);

  return { queryKey, queryFn, staleTime: 10000, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof searchPriorities>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type SearchPrioritiesInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof searchPriorities>>
>;
export type SearchPrioritiesInfiniteQueryError = unknown;

export function useSearchPrioritiesInfinite<
  TData = Awaited<ReturnType<typeof searchPriorities>>,
  TError = unknown,
>(
  params: SearchPrioritiesParams,
  options?: {
    query?: UseInfiniteQueryOptions<Awaited<ReturnType<typeof searchPriorities>>, TError, TData>;
    request?: SecondParameter<typeof customFetch>;
  }
): UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getSearchPrioritiesInfiniteQueryOptions(params, options);

  const query = useInfiniteQuery(queryOptions) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getSearchPrioritiesQueryOptions = <
  TData = Awaited<ReturnType<typeof searchPriorities>>,
  TError = unknown,
>(
  params: SearchPrioritiesParams,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof searchPriorities>>, TError, TData>;
    request?: SecondParameter<typeof customFetch>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getSearchPrioritiesQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof searchPriorities>>> = ({ signal }) =>
    searchPriorities(params, requestOptions, signal);

  return { queryKey, queryFn, staleTime: 10000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof searchPriorities>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type SearchPrioritiesQueryResult = NonNullable<Awaited<ReturnType<typeof searchPriorities>>>;
export type SearchPrioritiesQueryError = unknown;

export function useSearchPriorities<
  TData = Awaited<ReturnType<typeof searchPriorities>>,
  TError = unknown,
>(
  params: SearchPrioritiesParams,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof searchPriorities>>, TError, TData>;
    request?: SecondParameter<typeof customFetch>;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getSearchPrioritiesQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey;

  return query;
}
