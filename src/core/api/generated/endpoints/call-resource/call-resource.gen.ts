/**
 * Generated by orval v7.8.0 üç∫
 * Do not edit manually.
 * Crm Backend API
 * Crm Backend API documentation
 * OpenAPI spec version: 0.0.1
 */
import { useInfiniteQuery, useMutation, useQuery } from '@tanstack/react-query';
import type {
  MutationFunction,
  QueryFunction,
  QueryKey,
  UseInfiniteQueryOptions,
  UseInfiniteQueryResult,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult,
} from '@tanstack/react-query';

import type {
  CallDTO,
  CountCallsParams,
  GetAllCallsParams,
  SearchCallsParams,
} from '../../schemas';

import { customFetch } from '../../../client/fetch-client';

type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];

export const getCall = (
  id: number,
  options?: SecondParameter<typeof customFetch>,
  signal?: AbortSignal
) => {
  return customFetch<CallDTO>({ url: `/api/calls/${id}`, method: 'GET', signal }, options);
};

export const getGetCallQueryKey = (id: number) => {
  return [`/api/calls/${id}`] as const;
};

export const getGetCallInfiniteQueryOptions = <
  TData = Awaited<ReturnType<typeof getCall>>,
  TError = unknown,
>(
  id: number,
  options?: {
    query?: UseInfiniteQueryOptions<Awaited<ReturnType<typeof getCall>>, TError, TData>;
    request?: SecondParameter<typeof customFetch>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetCallQueryKey(id);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getCall>>> = ({ signal }) =>
    getCall(id, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    staleTime: 10000,
    ...queryOptions,
  } as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getCall>>, TError, TData> & {
    queryKey: QueryKey;
  };
};

export type GetCallInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getCall>>>;
export type GetCallInfiniteQueryError = unknown;

export function useGetCallInfinite<TData = Awaited<ReturnType<typeof getCall>>, TError = unknown>(
  id: number,
  options?: {
    query?: UseInfiniteQueryOptions<Awaited<ReturnType<typeof getCall>>, TError, TData>;
    request?: SecondParameter<typeof customFetch>;
  }
): UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetCallInfiniteQueryOptions(id, options);

  const query = useInfiniteQuery(queryOptions) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGetCallQueryOptions = <
  TData = Awaited<ReturnType<typeof getCall>>,
  TError = unknown,
>(
  id: number,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof getCall>>, TError, TData>;
    request?: SecondParameter<typeof customFetch>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetCallQueryKey(id);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getCall>>> = ({ signal }) =>
    getCall(id, requestOptions, signal);

  return { queryKey, queryFn, enabled: !!id, staleTime: 10000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getCall>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetCallQueryResult = NonNullable<Awaited<ReturnType<typeof getCall>>>;
export type GetCallQueryError = unknown;

export function useGetCall<TData = Awaited<ReturnType<typeof getCall>>, TError = unknown>(
  id: number,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof getCall>>, TError, TData>;
    request?: SecondParameter<typeof customFetch>;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetCallQueryOptions(id, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const updateCall = (
  id: number,
  callDTO: CallDTO,
  options?: SecondParameter<typeof customFetch>
) => {
  return customFetch<CallDTO>(
    {
      url: `/api/calls/${id}`,
      method: 'PUT',
      headers: { 'Content-Type': 'application/json' },
      data: callDTO,
    },
    options
  );
};

export const getUpdateCallMutationOptions = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateCall>>,
    TError,
    { id: number; data: CallDTO },
    TContext
  >;
  request?: SecondParameter<typeof customFetch>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateCall>>,
  TError,
  { id: number; data: CallDTO },
  TContext
> => {
  const mutationKey = ['updateCall'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateCall>>,
    { id: number; data: CallDTO }
  > = props => {
    const { id, data } = props ?? {};

    return updateCall(id, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdateCallMutationResult = NonNullable<Awaited<ReturnType<typeof updateCall>>>;
export type UpdateCallMutationBody = CallDTO;
export type UpdateCallMutationError = unknown;

export const useUpdateCall = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateCall>>,
    TError,
    { id: number; data: CallDTO },
    TContext
  >;
  request?: SecondParameter<typeof customFetch>;
}): UseMutationResult<
  Awaited<ReturnType<typeof updateCall>>,
  TError,
  { id: number; data: CallDTO },
  TContext
> => {
  const mutationOptions = getUpdateCallMutationOptions(options);

  return useMutation(mutationOptions);
};
export const deleteCall = (id: number, options?: SecondParameter<typeof customFetch>) => {
  return customFetch<void>({ url: `/api/calls/${id}`, method: 'DELETE' }, options);
};

export const getDeleteCallMutationOptions = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteCall>>,
    TError,
    { id: number },
    TContext
  >;
  request?: SecondParameter<typeof customFetch>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteCall>>,
  TError,
  { id: number },
  TContext
> => {
  const mutationKey = ['deleteCall'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteCall>>,
    { id: number }
  > = props => {
    const { id } = props ?? {};

    return deleteCall(id, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type DeleteCallMutationResult = NonNullable<Awaited<ReturnType<typeof deleteCall>>>;

export type DeleteCallMutationError = unknown;

export const useDeleteCall = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteCall>>,
    TError,
    { id: number },
    TContext
  >;
  request?: SecondParameter<typeof customFetch>;
}): UseMutationResult<Awaited<ReturnType<typeof deleteCall>>, TError, { id: number }, TContext> => {
  const mutationOptions = getDeleteCallMutationOptions(options);

  return useMutation(mutationOptions);
};
export const partialUpdateCall = (
  id: number,
  callDTO: CallDTO,
  options?: SecondParameter<typeof customFetch>
) => {
  return customFetch<CallDTO>(
    {
      url: `/api/calls/${id}`,
      method: 'PATCH',
      headers: { 'Content-Type': 'application/json' },
      data: callDTO,
    },
    options
  );
};

export const getPartialUpdateCallMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof partialUpdateCall>>,
    TError,
    { id: number; data: CallDTO },
    TContext
  >;
  request?: SecondParameter<typeof customFetch>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof partialUpdateCall>>,
  TError,
  { id: number; data: CallDTO },
  TContext
> => {
  const mutationKey = ['partialUpdateCall'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof partialUpdateCall>>,
    { id: number; data: CallDTO }
  > = props => {
    const { id, data } = props ?? {};

    return partialUpdateCall(id, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PartialUpdateCallMutationResult = NonNullable<
  Awaited<ReturnType<typeof partialUpdateCall>>
>;
export type PartialUpdateCallMutationBody = CallDTO;
export type PartialUpdateCallMutationError = unknown;

export const usePartialUpdateCall = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof partialUpdateCall>>,
    TError,
    { id: number; data: CallDTO },
    TContext
  >;
  request?: SecondParameter<typeof customFetch>;
}): UseMutationResult<
  Awaited<ReturnType<typeof partialUpdateCall>>,
  TError,
  { id: number; data: CallDTO },
  TContext
> => {
  const mutationOptions = getPartialUpdateCallMutationOptions(options);

  return useMutation(mutationOptions);
};
export const getAllCalls = (
  params?: GetAllCallsParams,
  options?: SecondParameter<typeof customFetch>,
  signal?: AbortSignal
) => {
  return customFetch<CallDTO[]>({ url: `/api/calls`, method: 'GET', params, signal }, options);
};

export const getGetAllCallsQueryKey = (params?: GetAllCallsParams) => {
  return [`/api/calls`, ...(params ? [params] : [])] as const;
};

export const getGetAllCallsInfiniteQueryOptions = <
  TData = Awaited<ReturnType<typeof getAllCalls>>,
  TError = unknown,
>(
  params?: GetAllCallsParams,
  options?: {
    query?: UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAllCalls>>, TError, TData>;
    request?: SecondParameter<typeof customFetch>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetAllCallsQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getAllCalls>>> = ({ signal, pageParam }) =>
    getAllCalls({ ...params, page: pageParam || params?.['page'] }, requestOptions, signal);

  return { queryKey, queryFn, staleTime: 10000, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof getAllCalls>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetAllCallsInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getAllCalls>>>;
export type GetAllCallsInfiniteQueryError = unknown;

export function useGetAllCallsInfinite<
  TData = Awaited<ReturnType<typeof getAllCalls>>,
  TError = unknown,
>(
  params?: GetAllCallsParams,
  options?: {
    query?: UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAllCalls>>, TError, TData>;
    request?: SecondParameter<typeof customFetch>;
  }
): UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetAllCallsInfiniteQueryOptions(params, options);

  const query = useInfiniteQuery(queryOptions) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGetAllCallsQueryOptions = <
  TData = Awaited<ReturnType<typeof getAllCalls>>,
  TError = unknown,
>(
  params?: GetAllCallsParams,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof getAllCalls>>, TError, TData>;
    request?: SecondParameter<typeof customFetch>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetAllCallsQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getAllCalls>>> = ({ signal }) =>
    getAllCalls(params, requestOptions, signal);

  return { queryKey, queryFn, staleTime: 10000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getAllCalls>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetAllCallsQueryResult = NonNullable<Awaited<ReturnType<typeof getAllCalls>>>;
export type GetAllCallsQueryError = unknown;

export function useGetAllCalls<TData = Awaited<ReturnType<typeof getAllCalls>>, TError = unknown>(
  params?: GetAllCallsParams,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof getAllCalls>>, TError, TData>;
    request?: SecondParameter<typeof customFetch>;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetAllCallsQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const createCall = (
  callDTO: CallDTO,
  options?: SecondParameter<typeof customFetch>,
  signal?: AbortSignal
) => {
  return customFetch<CallDTO>(
    {
      url: `/api/calls`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: callDTO,
      signal,
    },
    options
  );
};

export const getCreateCallMutationOptions = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createCall>>,
    TError,
    { data: CallDTO },
    TContext
  >;
  request?: SecondParameter<typeof customFetch>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createCall>>,
  TError,
  { data: CallDTO },
  TContext
> => {
  const mutationKey = ['createCall'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createCall>>,
    { data: CallDTO }
  > = props => {
    const { data } = props ?? {};

    return createCall(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateCallMutationResult = NonNullable<Awaited<ReturnType<typeof createCall>>>;
export type CreateCallMutationBody = CallDTO;
export type CreateCallMutationError = unknown;

export const useCreateCall = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createCall>>,
    TError,
    { data: CallDTO },
    TContext
  >;
  request?: SecondParameter<typeof customFetch>;
}): UseMutationResult<
  Awaited<ReturnType<typeof createCall>>,
  TError,
  { data: CallDTO },
  TContext
> => {
  const mutationOptions = getCreateCallMutationOptions(options);

  return useMutation(mutationOptions);
};
export const countCalls = (
  params?: CountCallsParams,
  options?: SecondParameter<typeof customFetch>,
  signal?: AbortSignal
) => {
  return customFetch<number>({ url: `/api/calls/count`, method: 'GET', params, signal }, options);
};

export const getCountCallsQueryKey = (params?: CountCallsParams) => {
  return [`/api/calls/count`, ...(params ? [params] : [])] as const;
};

export const getCountCallsInfiniteQueryOptions = <
  TData = Awaited<ReturnType<typeof countCalls>>,
  TError = unknown,
>(
  params?: CountCallsParams,
  options?: {
    query?: UseInfiniteQueryOptions<Awaited<ReturnType<typeof countCalls>>, TError, TData>;
    request?: SecondParameter<typeof customFetch>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getCountCallsQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof countCalls>>> = ({ signal, pageParam }) =>
    countCalls({ ...params, page: pageParam || params?.['page'] }, requestOptions, signal);

  return { queryKey, queryFn, staleTime: 10000, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof countCalls>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type CountCallsInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof countCalls>>>;
export type CountCallsInfiniteQueryError = unknown;

export function useCountCallsInfinite<
  TData = Awaited<ReturnType<typeof countCalls>>,
  TError = unknown,
>(
  params?: CountCallsParams,
  options?: {
    query?: UseInfiniteQueryOptions<Awaited<ReturnType<typeof countCalls>>, TError, TData>;
    request?: SecondParameter<typeof customFetch>;
  }
): UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getCountCallsInfiniteQueryOptions(params, options);

  const query = useInfiniteQuery(queryOptions) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getCountCallsQueryOptions = <
  TData = Awaited<ReturnType<typeof countCalls>>,
  TError = unknown,
>(
  params?: CountCallsParams,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof countCalls>>, TError, TData>;
    request?: SecondParameter<typeof customFetch>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getCountCallsQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof countCalls>>> = ({ signal }) =>
    countCalls(params, requestOptions, signal);

  return { queryKey, queryFn, staleTime: 10000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof countCalls>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type CountCallsQueryResult = NonNullable<Awaited<ReturnType<typeof countCalls>>>;
export type CountCallsQueryError = unknown;

export function useCountCalls<TData = Awaited<ReturnType<typeof countCalls>>, TError = unknown>(
  params?: CountCallsParams,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof countCalls>>, TError, TData>;
    request?: SecondParameter<typeof customFetch>;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getCountCallsQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const searchCalls = (
  params: SearchCallsParams,
  options?: SecondParameter<typeof customFetch>,
  signal?: AbortSignal
) => {
  return customFetch<CallDTO[]>(
    { url: `/api/calls/_search`, method: 'GET', params, signal },
    options
  );
};

export const getSearchCallsQueryKey = (params: SearchCallsParams) => {
  return [`/api/calls/_search`, ...(params ? [params] : [])] as const;
};

export const getSearchCallsInfiniteQueryOptions = <
  TData = Awaited<ReturnType<typeof searchCalls>>,
  TError = unknown,
>(
  params: SearchCallsParams,
  options?: {
    query?: UseInfiniteQueryOptions<Awaited<ReturnType<typeof searchCalls>>, TError, TData>;
    request?: SecondParameter<typeof customFetch>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getSearchCallsQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof searchCalls>>> = ({ signal, pageParam }) =>
    searchCalls({ ...params, page: pageParam || params?.['page'] }, requestOptions, signal);

  return { queryKey, queryFn, staleTime: 10000, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof searchCalls>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type SearchCallsInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof searchCalls>>>;
export type SearchCallsInfiniteQueryError = unknown;

export function useSearchCallsInfinite<
  TData = Awaited<ReturnType<typeof searchCalls>>,
  TError = unknown,
>(
  params: SearchCallsParams,
  options?: {
    query?: UseInfiniteQueryOptions<Awaited<ReturnType<typeof searchCalls>>, TError, TData>;
    request?: SecondParameter<typeof customFetch>;
  }
): UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getSearchCallsInfiniteQueryOptions(params, options);

  const query = useInfiniteQuery(queryOptions) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getSearchCallsQueryOptions = <
  TData = Awaited<ReturnType<typeof searchCalls>>,
  TError = unknown,
>(
  params: SearchCallsParams,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof searchCalls>>, TError, TData>;
    request?: SecondParameter<typeof customFetch>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getSearchCallsQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof searchCalls>>> = ({ signal }) =>
    searchCalls(params, requestOptions, signal);

  return { queryKey, queryFn, staleTime: 10000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof searchCalls>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type SearchCallsQueryResult = NonNullable<Awaited<ReturnType<typeof searchCalls>>>;
export type SearchCallsQueryError = unknown;

export function useSearchCalls<TData = Awaited<ReturnType<typeof searchCalls>>, TError = unknown>(
  params: SearchCallsParams,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof searchCalls>>, TError, TData>;
    request?: SecondParameter<typeof customFetch>;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getSearchCallsQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey;

  return query;
}
