/**
 * Generated by orval v7.8.0 üç∫
 * Do not edit manually.
 * Crm Backend API
 * Crm Backend API documentation
 * OpenAPI spec version: 0.0.1
 */
import { useInfiniteQuery, useMutation, useQuery } from '@tanstack/react-query';
import type {
  MutationFunction,
  QueryFunction,
  QueryKey,
  UseInfiniteQueryOptions,
  UseInfiniteQueryResult,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult,
} from '@tanstack/react-query';

import type {
  CountPartiesParams,
  GetAllPartiesParams,
  PartyDTO,
  SearchPartiesParams,
} from '../../schemas';

import { customFetch } from '../../../client/fetch-client';

type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];

export const getParty = (
  id: number,
  options?: SecondParameter<typeof customFetch>,
  signal?: AbortSignal
) => {
  return customFetch<PartyDTO>({ url: `/api/parties/${id}`, method: 'GET', signal }, options);
};

export const getGetPartyQueryKey = (id: number) => {
  return [`/api/parties/${id}`] as const;
};

export const getGetPartyInfiniteQueryOptions = <
  TData = Awaited<ReturnType<typeof getParty>>,
  TError = unknown,
>(
  id: number,
  options?: {
    query?: UseInfiniteQueryOptions<Awaited<ReturnType<typeof getParty>>, TError, TData>;
    request?: SecondParameter<typeof customFetch>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetPartyQueryKey(id);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getParty>>> = ({ signal }) =>
    getParty(id, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    staleTime: 10000,
    ...queryOptions,
  } as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getParty>>, TError, TData> & {
    queryKey: QueryKey;
  };
};

export type GetPartyInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getParty>>>;
export type GetPartyInfiniteQueryError = unknown;

export function useGetPartyInfinite<TData = Awaited<ReturnType<typeof getParty>>, TError = unknown>(
  id: number,
  options?: {
    query?: UseInfiniteQueryOptions<Awaited<ReturnType<typeof getParty>>, TError, TData>;
    request?: SecondParameter<typeof customFetch>;
  }
): UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetPartyInfiniteQueryOptions(id, options);

  const query = useInfiniteQuery(queryOptions) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGetPartyQueryOptions = <
  TData = Awaited<ReturnType<typeof getParty>>,
  TError = unknown,
>(
  id: number,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof getParty>>, TError, TData>;
    request?: SecondParameter<typeof customFetch>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetPartyQueryKey(id);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getParty>>> = ({ signal }) =>
    getParty(id, requestOptions, signal);

  return { queryKey, queryFn, enabled: !!id, staleTime: 10000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getParty>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetPartyQueryResult = NonNullable<Awaited<ReturnType<typeof getParty>>>;
export type GetPartyQueryError = unknown;

export function useGetParty<TData = Awaited<ReturnType<typeof getParty>>, TError = unknown>(
  id: number,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof getParty>>, TError, TData>;
    request?: SecondParameter<typeof customFetch>;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetPartyQueryOptions(id, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const updateParty = (
  id: number,
  partyDTO: PartyDTO,
  options?: SecondParameter<typeof customFetch>
) => {
  return customFetch<PartyDTO>(
    {
      url: `/api/parties/${id}`,
      method: 'PUT',
      headers: { 'Content-Type': 'application/json' },
      data: partyDTO,
    },
    options
  );
};

export const getUpdatePartyMutationOptions = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateParty>>,
    TError,
    { id: number; data: PartyDTO },
    TContext
  >;
  request?: SecondParameter<typeof customFetch>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateParty>>,
  TError,
  { id: number; data: PartyDTO },
  TContext
> => {
  const mutationKey = ['updateParty'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateParty>>,
    { id: number; data: PartyDTO }
  > = props => {
    const { id, data } = props ?? {};

    return updateParty(id, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdatePartyMutationResult = NonNullable<Awaited<ReturnType<typeof updateParty>>>;
export type UpdatePartyMutationBody = PartyDTO;
export type UpdatePartyMutationError = unknown;

export const useUpdateParty = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateParty>>,
    TError,
    { id: number; data: PartyDTO },
    TContext
  >;
  request?: SecondParameter<typeof customFetch>;
}): UseMutationResult<
  Awaited<ReturnType<typeof updateParty>>,
  TError,
  { id: number; data: PartyDTO },
  TContext
> => {
  const mutationOptions = getUpdatePartyMutationOptions(options);

  return useMutation(mutationOptions);
};
export const deleteParty = (id: number, options?: SecondParameter<typeof customFetch>) => {
  return customFetch<void>({ url: `/api/parties/${id}`, method: 'DELETE' }, options);
};

export const getDeletePartyMutationOptions = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteParty>>,
    TError,
    { id: number },
    TContext
  >;
  request?: SecondParameter<typeof customFetch>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteParty>>,
  TError,
  { id: number },
  TContext
> => {
  const mutationKey = ['deleteParty'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteParty>>,
    { id: number }
  > = props => {
    const { id } = props ?? {};

    return deleteParty(id, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type DeletePartyMutationResult = NonNullable<Awaited<ReturnType<typeof deleteParty>>>;

export type DeletePartyMutationError = unknown;

export const useDeleteParty = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteParty>>,
    TError,
    { id: number },
    TContext
  >;
  request?: SecondParameter<typeof customFetch>;
}): UseMutationResult<
  Awaited<ReturnType<typeof deleteParty>>,
  TError,
  { id: number },
  TContext
> => {
  const mutationOptions = getDeletePartyMutationOptions(options);

  return useMutation(mutationOptions);
};
export const partialUpdateParty = (
  id: number,
  partyDTO: PartyDTO,
  options?: SecondParameter<typeof customFetch>
) => {
  return customFetch<PartyDTO>(
    {
      url: `/api/parties/${id}`,
      method: 'PATCH',
      headers: { 'Content-Type': 'application/json' },
      data: partyDTO,
    },
    options
  );
};

export const getPartialUpdatePartyMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof partialUpdateParty>>,
    TError,
    { id: number; data: PartyDTO },
    TContext
  >;
  request?: SecondParameter<typeof customFetch>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof partialUpdateParty>>,
  TError,
  { id: number; data: PartyDTO },
  TContext
> => {
  const mutationKey = ['partialUpdateParty'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof partialUpdateParty>>,
    { id: number; data: PartyDTO }
  > = props => {
    const { id, data } = props ?? {};

    return partialUpdateParty(id, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PartialUpdatePartyMutationResult = NonNullable<
  Awaited<ReturnType<typeof partialUpdateParty>>
>;
export type PartialUpdatePartyMutationBody = PartyDTO;
export type PartialUpdatePartyMutationError = unknown;

export const usePartialUpdateParty = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof partialUpdateParty>>,
    TError,
    { id: number; data: PartyDTO },
    TContext
  >;
  request?: SecondParameter<typeof customFetch>;
}): UseMutationResult<
  Awaited<ReturnType<typeof partialUpdateParty>>,
  TError,
  { id: number; data: PartyDTO },
  TContext
> => {
  const mutationOptions = getPartialUpdatePartyMutationOptions(options);

  return useMutation(mutationOptions);
};
export const getAllParties = (
  params?: GetAllPartiesParams,
  options?: SecondParameter<typeof customFetch>,
  signal?: AbortSignal
) => {
  return customFetch<PartyDTO[]>({ url: `/api/parties`, method: 'GET', params, signal }, options);
};

export const getGetAllPartiesQueryKey = (params?: GetAllPartiesParams) => {
  return [`/api/parties`, ...(params ? [params] : [])] as const;
};

export const getGetAllPartiesInfiniteQueryOptions = <
  TData = Awaited<ReturnType<typeof getAllParties>>,
  TError = unknown,
>(
  params?: GetAllPartiesParams,
  options?: {
    query?: UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAllParties>>, TError, TData>;
    request?: SecondParameter<typeof customFetch>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetAllPartiesQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getAllParties>>> = ({
    signal,
    pageParam,
  }) => getAllParties({ ...params, page: pageParam || params?.['page'] }, requestOptions, signal);

  return { queryKey, queryFn, staleTime: 10000, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof getAllParties>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetAllPartiesInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof getAllParties>>
>;
export type GetAllPartiesInfiniteQueryError = unknown;

export function useGetAllPartiesInfinite<
  TData = Awaited<ReturnType<typeof getAllParties>>,
  TError = unknown,
>(
  params?: GetAllPartiesParams,
  options?: {
    query?: UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAllParties>>, TError, TData>;
    request?: SecondParameter<typeof customFetch>;
  }
): UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetAllPartiesInfiniteQueryOptions(params, options);

  const query = useInfiniteQuery(queryOptions) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGetAllPartiesQueryOptions = <
  TData = Awaited<ReturnType<typeof getAllParties>>,
  TError = unknown,
>(
  params?: GetAllPartiesParams,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof getAllParties>>, TError, TData>;
    request?: SecondParameter<typeof customFetch>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetAllPartiesQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getAllParties>>> = ({ signal }) =>
    getAllParties(params, requestOptions, signal);

  return { queryKey, queryFn, staleTime: 10000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getAllParties>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetAllPartiesQueryResult = NonNullable<Awaited<ReturnType<typeof getAllParties>>>;
export type GetAllPartiesQueryError = unknown;

export function useGetAllParties<
  TData = Awaited<ReturnType<typeof getAllParties>>,
  TError = unknown,
>(
  params?: GetAllPartiesParams,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof getAllParties>>, TError, TData>;
    request?: SecondParameter<typeof customFetch>;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetAllPartiesQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const createParty = (
  partyDTO: PartyDTO,
  options?: SecondParameter<typeof customFetch>,
  signal?: AbortSignal
) => {
  return customFetch<PartyDTO>(
    {
      url: `/api/parties`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: partyDTO,
      signal,
    },
    options
  );
};

export const getCreatePartyMutationOptions = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createParty>>,
    TError,
    { data: PartyDTO },
    TContext
  >;
  request?: SecondParameter<typeof customFetch>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createParty>>,
  TError,
  { data: PartyDTO },
  TContext
> => {
  const mutationKey = ['createParty'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createParty>>,
    { data: PartyDTO }
  > = props => {
    const { data } = props ?? {};

    return createParty(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreatePartyMutationResult = NonNullable<Awaited<ReturnType<typeof createParty>>>;
export type CreatePartyMutationBody = PartyDTO;
export type CreatePartyMutationError = unknown;

export const useCreateParty = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createParty>>,
    TError,
    { data: PartyDTO },
    TContext
  >;
  request?: SecondParameter<typeof customFetch>;
}): UseMutationResult<
  Awaited<ReturnType<typeof createParty>>,
  TError,
  { data: PartyDTO },
  TContext
> => {
  const mutationOptions = getCreatePartyMutationOptions(options);

  return useMutation(mutationOptions);
};
export const countParties = (
  params?: CountPartiesParams,
  options?: SecondParameter<typeof customFetch>,
  signal?: AbortSignal
) => {
  return customFetch<number>({ url: `/api/parties/count`, method: 'GET', params, signal }, options);
};

export const getCountPartiesQueryKey = (params?: CountPartiesParams) => {
  return [`/api/parties/count`, ...(params ? [params] : [])] as const;
};

export const getCountPartiesInfiniteQueryOptions = <
  TData = Awaited<ReturnType<typeof countParties>>,
  TError = unknown,
>(
  params?: CountPartiesParams,
  options?: {
    query?: UseInfiniteQueryOptions<Awaited<ReturnType<typeof countParties>>, TError, TData>;
    request?: SecondParameter<typeof customFetch>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getCountPartiesQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof countParties>>> = ({
    signal,
    pageParam,
  }) => countParties({ ...params, page: pageParam || params?.['page'] }, requestOptions, signal);

  return { queryKey, queryFn, staleTime: 10000, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof countParties>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type CountPartiesInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof countParties>>>;
export type CountPartiesInfiniteQueryError = unknown;

export function useCountPartiesInfinite<
  TData = Awaited<ReturnType<typeof countParties>>,
  TError = unknown,
>(
  params?: CountPartiesParams,
  options?: {
    query?: UseInfiniteQueryOptions<Awaited<ReturnType<typeof countParties>>, TError, TData>;
    request?: SecondParameter<typeof customFetch>;
  }
): UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getCountPartiesInfiniteQueryOptions(params, options);

  const query = useInfiniteQuery(queryOptions) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getCountPartiesQueryOptions = <
  TData = Awaited<ReturnType<typeof countParties>>,
  TError = unknown,
>(
  params?: CountPartiesParams,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof countParties>>, TError, TData>;
    request?: SecondParameter<typeof customFetch>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getCountPartiesQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof countParties>>> = ({ signal }) =>
    countParties(params, requestOptions, signal);

  return { queryKey, queryFn, staleTime: 10000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof countParties>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type CountPartiesQueryResult = NonNullable<Awaited<ReturnType<typeof countParties>>>;
export type CountPartiesQueryError = unknown;

export function useCountParties<TData = Awaited<ReturnType<typeof countParties>>, TError = unknown>(
  params?: CountPartiesParams,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof countParties>>, TError, TData>;
    request?: SecondParameter<typeof customFetch>;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getCountPartiesQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const searchParties = (
  params: SearchPartiesParams,
  options?: SecondParameter<typeof customFetch>,
  signal?: AbortSignal
) => {
  return customFetch<PartyDTO[]>(
    { url: `/api/parties/_search`, method: 'GET', params, signal },
    options
  );
};

export const getSearchPartiesQueryKey = (params: SearchPartiesParams) => {
  return [`/api/parties/_search`, ...(params ? [params] : [])] as const;
};

export const getSearchPartiesInfiniteQueryOptions = <
  TData = Awaited<ReturnType<typeof searchParties>>,
  TError = unknown,
>(
  params: SearchPartiesParams,
  options?: {
    query?: UseInfiniteQueryOptions<Awaited<ReturnType<typeof searchParties>>, TError, TData>;
    request?: SecondParameter<typeof customFetch>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getSearchPartiesQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof searchParties>>> = ({
    signal,
    pageParam,
  }) => searchParties({ ...params, page: pageParam || params?.['page'] }, requestOptions, signal);

  return { queryKey, queryFn, staleTime: 10000, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof searchParties>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type SearchPartiesInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof searchParties>>
>;
export type SearchPartiesInfiniteQueryError = unknown;

export function useSearchPartiesInfinite<
  TData = Awaited<ReturnType<typeof searchParties>>,
  TError = unknown,
>(
  params: SearchPartiesParams,
  options?: {
    query?: UseInfiniteQueryOptions<Awaited<ReturnType<typeof searchParties>>, TError, TData>;
    request?: SecondParameter<typeof customFetch>;
  }
): UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getSearchPartiesInfiniteQueryOptions(params, options);

  const query = useInfiniteQuery(queryOptions) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getSearchPartiesQueryOptions = <
  TData = Awaited<ReturnType<typeof searchParties>>,
  TError = unknown,
>(
  params: SearchPartiesParams,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof searchParties>>, TError, TData>;
    request?: SecondParameter<typeof customFetch>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getSearchPartiesQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof searchParties>>> = ({ signal }) =>
    searchParties(params, requestOptions, signal);

  return { queryKey, queryFn, staleTime: 10000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof searchParties>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type SearchPartiesQueryResult = NonNullable<Awaited<ReturnType<typeof searchParties>>>;
export type SearchPartiesQueryError = unknown;

export function useSearchParties<
  TData = Awaited<ReturnType<typeof searchParties>>,
  TError = unknown,
>(
  params: SearchPartiesParams,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof searchParties>>, TError, TData>;
    request?: SecondParameter<typeof customFetch>;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getSearchPartiesQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey;

  return query;
}
