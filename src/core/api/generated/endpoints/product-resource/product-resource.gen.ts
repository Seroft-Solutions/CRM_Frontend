/**
 * Generated by orval v7.8.0 üç∫
 * Do not edit manually.
 * Crm Backend API
 * Crm Backend API documentation
 * OpenAPI spec version: 0.0.1
 */
import { useInfiniteQuery, useMutation, useQuery } from '@tanstack/react-query';
import type {
  MutationFunction,
  QueryFunction,
  QueryKey,
  UseInfiniteQueryOptions,
  UseInfiniteQueryResult,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult,
} from '@tanstack/react-query';

import type {
  CountProductsParams,
  GetAllProductsParams,
  ProductDTO,
  SearchProductsParams,
} from '../../schemas';

import { customFetch } from '../../../client/fetch-client';

type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];

export const getProduct = (
  id: number,
  options?: SecondParameter<typeof customFetch>,
  signal?: AbortSignal
) => {
  return customFetch<ProductDTO>({ url: `/api/products/${id}`, method: 'GET', signal }, options);
};

export const getGetProductQueryKey = (id: number) => {
  return [`/api/products/${id}`] as const;
};

export const getGetProductInfiniteQueryOptions = <
  TData = Awaited<ReturnType<typeof getProduct>>,
  TError = unknown,
>(
  id: number,
  options?: {
    query?: UseInfiniteQueryOptions<Awaited<ReturnType<typeof getProduct>>, TError, TData>;
    request?: SecondParameter<typeof customFetch>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetProductQueryKey(id);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getProduct>>> = ({ signal }) =>
    getProduct(id, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    staleTime: 10000,
    ...queryOptions,
  } as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getProduct>>, TError, TData> & {
    queryKey: QueryKey;
  };
};

export type GetProductInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getProduct>>>;
export type GetProductInfiniteQueryError = unknown;

export function useGetProductInfinite<
  TData = Awaited<ReturnType<typeof getProduct>>,
  TError = unknown,
>(
  id: number,
  options?: {
    query?: UseInfiniteQueryOptions<Awaited<ReturnType<typeof getProduct>>, TError, TData>;
    request?: SecondParameter<typeof customFetch>;
  }
): UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetProductInfiniteQueryOptions(id, options);

  const query = useInfiniteQuery(queryOptions) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGetProductQueryOptions = <
  TData = Awaited<ReturnType<typeof getProduct>>,
  TError = unknown,
>(
  id: number,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof getProduct>>, TError, TData>;
    request?: SecondParameter<typeof customFetch>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetProductQueryKey(id);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getProduct>>> = ({ signal }) =>
    getProduct(id, requestOptions, signal);

  return { queryKey, queryFn, enabled: !!id, staleTime: 10000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getProduct>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetProductQueryResult = NonNullable<Awaited<ReturnType<typeof getProduct>>>;
export type GetProductQueryError = unknown;

export function useGetProduct<TData = Awaited<ReturnType<typeof getProduct>>, TError = unknown>(
  id: number,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof getProduct>>, TError, TData>;
    request?: SecondParameter<typeof customFetch>;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetProductQueryOptions(id, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const updateProduct = (
  id: number,
  productDTO: ProductDTO,
  options?: SecondParameter<typeof customFetch>
) => {
  return customFetch<ProductDTO>(
    {
      url: `/api/products/${id}`,
      method: 'PUT',
      headers: { 'Content-Type': 'application/json' },
      data: productDTO,
    },
    options
  );
};

export const getUpdateProductMutationOptions = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateProduct>>,
    TError,
    { id: number; data: ProductDTO },
    TContext
  >;
  request?: SecondParameter<typeof customFetch>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateProduct>>,
  TError,
  { id: number; data: ProductDTO },
  TContext
> => {
  const mutationKey = ['updateProduct'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateProduct>>,
    { id: number; data: ProductDTO }
  > = props => {
    const { id, data } = props ?? {};

    return updateProduct(id, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdateProductMutationResult = NonNullable<Awaited<ReturnType<typeof updateProduct>>>;
export type UpdateProductMutationBody = ProductDTO;
export type UpdateProductMutationError = unknown;

export const useUpdateProduct = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateProduct>>,
    TError,
    { id: number; data: ProductDTO },
    TContext
  >;
  request?: SecondParameter<typeof customFetch>;
}): UseMutationResult<
  Awaited<ReturnType<typeof updateProduct>>,
  TError,
  { id: number; data: ProductDTO },
  TContext
> => {
  const mutationOptions = getUpdateProductMutationOptions(options);

  return useMutation(mutationOptions);
};
export const deleteProduct = (id: number, options?: SecondParameter<typeof customFetch>) => {
  return customFetch<void>({ url: `/api/products/${id}`, method: 'DELETE' }, options);
};

export const getDeleteProductMutationOptions = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteProduct>>,
    TError,
    { id: number },
    TContext
  >;
  request?: SecondParameter<typeof customFetch>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteProduct>>,
  TError,
  { id: number },
  TContext
> => {
  const mutationKey = ['deleteProduct'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteProduct>>,
    { id: number }
  > = props => {
    const { id } = props ?? {};

    return deleteProduct(id, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type DeleteProductMutationResult = NonNullable<Awaited<ReturnType<typeof deleteProduct>>>;

export type DeleteProductMutationError = unknown;

export const useDeleteProduct = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteProduct>>,
    TError,
    { id: number },
    TContext
  >;
  request?: SecondParameter<typeof customFetch>;
}): UseMutationResult<
  Awaited<ReturnType<typeof deleteProduct>>,
  TError,
  { id: number },
  TContext
> => {
  const mutationOptions = getDeleteProductMutationOptions(options);

  return useMutation(mutationOptions);
};
export const partialUpdateProduct = (
  id: number,
  productDTO: ProductDTO,
  options?: SecondParameter<typeof customFetch>
) => {
  return customFetch<ProductDTO>(
    {
      url: `/api/products/${id}`,
      method: 'PATCH',
      headers: { 'Content-Type': 'application/json' },
      data: productDTO,
    },
    options
  );
};

export const getPartialUpdateProductMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof partialUpdateProduct>>,
    TError,
    { id: number; data: ProductDTO },
    TContext
  >;
  request?: SecondParameter<typeof customFetch>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof partialUpdateProduct>>,
  TError,
  { id: number; data: ProductDTO },
  TContext
> => {
  const mutationKey = ['partialUpdateProduct'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof partialUpdateProduct>>,
    { id: number; data: ProductDTO }
  > = props => {
    const { id, data } = props ?? {};

    return partialUpdateProduct(id, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PartialUpdateProductMutationResult = NonNullable<
  Awaited<ReturnType<typeof partialUpdateProduct>>
>;
export type PartialUpdateProductMutationBody = ProductDTO;
export type PartialUpdateProductMutationError = unknown;

export const usePartialUpdateProduct = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof partialUpdateProduct>>,
    TError,
    { id: number; data: ProductDTO },
    TContext
  >;
  request?: SecondParameter<typeof customFetch>;
}): UseMutationResult<
  Awaited<ReturnType<typeof partialUpdateProduct>>,
  TError,
  { id: number; data: ProductDTO },
  TContext
> => {
  const mutationOptions = getPartialUpdateProductMutationOptions(options);

  return useMutation(mutationOptions);
};
export const getAllProducts = (
  params?: GetAllProductsParams,
  options?: SecondParameter<typeof customFetch>,
  signal?: AbortSignal
) => {
  return customFetch<ProductDTO[]>(
    { url: `/api/products`, method: 'GET', params, signal },
    options
  );
};

export const getGetAllProductsQueryKey = (params?: GetAllProductsParams) => {
  return [`/api/products`, ...(params ? [params] : [])] as const;
};

export const getGetAllProductsInfiniteQueryOptions = <
  TData = Awaited<ReturnType<typeof getAllProducts>>,
  TError = unknown,
>(
  params?: GetAllProductsParams,
  options?: {
    query?: UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAllProducts>>, TError, TData>;
    request?: SecondParameter<typeof customFetch>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetAllProductsQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getAllProducts>>> = ({
    signal,
    pageParam,
  }) => getAllProducts({ ...params, page: pageParam || params?.['page'] }, requestOptions, signal);

  return { queryKey, queryFn, staleTime: 10000, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof getAllProducts>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetAllProductsInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof getAllProducts>>
>;
export type GetAllProductsInfiniteQueryError = unknown;

export function useGetAllProductsInfinite<
  TData = Awaited<ReturnType<typeof getAllProducts>>,
  TError = unknown,
>(
  params?: GetAllProductsParams,
  options?: {
    query?: UseInfiniteQueryOptions<Awaited<ReturnType<typeof getAllProducts>>, TError, TData>;
    request?: SecondParameter<typeof customFetch>;
  }
): UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetAllProductsInfiniteQueryOptions(params, options);

  const query = useInfiniteQuery(queryOptions) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGetAllProductsQueryOptions = <
  TData = Awaited<ReturnType<typeof getAllProducts>>,
  TError = unknown,
>(
  params?: GetAllProductsParams,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof getAllProducts>>, TError, TData>;
    request?: SecondParameter<typeof customFetch>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetAllProductsQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getAllProducts>>> = ({ signal }) =>
    getAllProducts(params, requestOptions, signal);

  return { queryKey, queryFn, staleTime: 10000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getAllProducts>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetAllProductsQueryResult = NonNullable<Awaited<ReturnType<typeof getAllProducts>>>;
export type GetAllProductsQueryError = unknown;

export function useGetAllProducts<
  TData = Awaited<ReturnType<typeof getAllProducts>>,
  TError = unknown,
>(
  params?: GetAllProductsParams,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof getAllProducts>>, TError, TData>;
    request?: SecondParameter<typeof customFetch>;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetAllProductsQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const createProduct = (
  productDTO: ProductDTO,
  options?: SecondParameter<typeof customFetch>,
  signal?: AbortSignal
) => {
  return customFetch<ProductDTO>(
    {
      url: `/api/products`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: productDTO,
      signal,
    },
    options
  );
};

export const getCreateProductMutationOptions = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createProduct>>,
    TError,
    { data: ProductDTO },
    TContext
  >;
  request?: SecondParameter<typeof customFetch>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createProduct>>,
  TError,
  { data: ProductDTO },
  TContext
> => {
  const mutationKey = ['createProduct'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createProduct>>,
    { data: ProductDTO }
  > = props => {
    const { data } = props ?? {};

    return createProduct(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateProductMutationResult = NonNullable<Awaited<ReturnType<typeof createProduct>>>;
export type CreateProductMutationBody = ProductDTO;
export type CreateProductMutationError = unknown;

export const useCreateProduct = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createProduct>>,
    TError,
    { data: ProductDTO },
    TContext
  >;
  request?: SecondParameter<typeof customFetch>;
}): UseMutationResult<
  Awaited<ReturnType<typeof createProduct>>,
  TError,
  { data: ProductDTO },
  TContext
> => {
  const mutationOptions = getCreateProductMutationOptions(options);

  return useMutation(mutationOptions);
};
export const countProducts = (
  params?: CountProductsParams,
  options?: SecondParameter<typeof customFetch>,
  signal?: AbortSignal
) => {
  return customFetch<number>(
    { url: `/api/products/count`, method: 'GET', params, signal },
    options
  );
};

export const getCountProductsQueryKey = (params?: CountProductsParams) => {
  return [`/api/products/count`, ...(params ? [params] : [])] as const;
};

export const getCountProductsInfiniteQueryOptions = <
  TData = Awaited<ReturnType<typeof countProducts>>,
  TError = unknown,
>(
  params?: CountProductsParams,
  options?: {
    query?: UseInfiniteQueryOptions<Awaited<ReturnType<typeof countProducts>>, TError, TData>;
    request?: SecondParameter<typeof customFetch>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getCountProductsQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof countProducts>>> = ({
    signal,
    pageParam,
  }) => countProducts({ ...params, page: pageParam || params?.['page'] }, requestOptions, signal);

  return { queryKey, queryFn, staleTime: 10000, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof countProducts>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type CountProductsInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof countProducts>>
>;
export type CountProductsInfiniteQueryError = unknown;

export function useCountProductsInfinite<
  TData = Awaited<ReturnType<typeof countProducts>>,
  TError = unknown,
>(
  params?: CountProductsParams,
  options?: {
    query?: UseInfiniteQueryOptions<Awaited<ReturnType<typeof countProducts>>, TError, TData>;
    request?: SecondParameter<typeof customFetch>;
  }
): UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getCountProductsInfiniteQueryOptions(params, options);

  const query = useInfiniteQuery(queryOptions) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getCountProductsQueryOptions = <
  TData = Awaited<ReturnType<typeof countProducts>>,
  TError = unknown,
>(
  params?: CountProductsParams,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof countProducts>>, TError, TData>;
    request?: SecondParameter<typeof customFetch>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getCountProductsQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof countProducts>>> = ({ signal }) =>
    countProducts(params, requestOptions, signal);

  return { queryKey, queryFn, staleTime: 10000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof countProducts>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type CountProductsQueryResult = NonNullable<Awaited<ReturnType<typeof countProducts>>>;
export type CountProductsQueryError = unknown;

export function useCountProducts<
  TData = Awaited<ReturnType<typeof countProducts>>,
  TError = unknown,
>(
  params?: CountProductsParams,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof countProducts>>, TError, TData>;
    request?: SecondParameter<typeof customFetch>;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getCountProductsQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const searchProducts = (
  params: SearchProductsParams,
  options?: SecondParameter<typeof customFetch>,
  signal?: AbortSignal
) => {
  return customFetch<ProductDTO[]>(
    { url: `/api/products/_search`, method: 'GET', params, signal },
    options
  );
};

export const getSearchProductsQueryKey = (params: SearchProductsParams) => {
  return [`/api/products/_search`, ...(params ? [params] : [])] as const;
};

export const getSearchProductsInfiniteQueryOptions = <
  TData = Awaited<ReturnType<typeof searchProducts>>,
  TError = unknown,
>(
  params: SearchProductsParams,
  options?: {
    query?: UseInfiniteQueryOptions<Awaited<ReturnType<typeof searchProducts>>, TError, TData>;
    request?: SecondParameter<typeof customFetch>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getSearchProductsQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof searchProducts>>> = ({
    signal,
    pageParam,
  }) => searchProducts({ ...params, page: pageParam || params?.['page'] }, requestOptions, signal);

  return { queryKey, queryFn, staleTime: 10000, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof searchProducts>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type SearchProductsInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof searchProducts>>
>;
export type SearchProductsInfiniteQueryError = unknown;

export function useSearchProductsInfinite<
  TData = Awaited<ReturnType<typeof searchProducts>>,
  TError = unknown,
>(
  params: SearchProductsParams,
  options?: {
    query?: UseInfiniteQueryOptions<Awaited<ReturnType<typeof searchProducts>>, TError, TData>;
    request?: SecondParameter<typeof customFetch>;
  }
): UseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getSearchProductsInfiniteQueryOptions(params, options);

  const query = useInfiniteQuery(queryOptions) as UseInfiniteQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getSearchProductsQueryOptions = <
  TData = Awaited<ReturnType<typeof searchProducts>>,
  TError = unknown,
>(
  params: SearchProductsParams,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof searchProducts>>, TError, TData>;
    request?: SecondParameter<typeof customFetch>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getSearchProductsQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof searchProducts>>> = ({ signal }) =>
    searchProducts(params, requestOptions, signal);

  return { queryKey, queryFn, staleTime: 10000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof searchProducts>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type SearchProductsQueryResult = NonNullable<Awaited<ReturnType<typeof searchProducts>>>;
export type SearchProductsQueryError = unknown;

export function useSearchProducts<
  TData = Awaited<ReturnType<typeof searchProducts>>,
  TError = unknown,
>(
  params: SearchProductsParams,
  options?: {
    query?: UseQueryOptions<Awaited<ReturnType<typeof searchProducts>>, TError, TData>;
    request?: SecondParameter<typeof customFetch>;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getSearchProductsQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey;

  return query;
}
